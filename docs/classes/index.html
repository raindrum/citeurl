<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Classes - CiteURL</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Classes", url: "#_top", children: [
              {title: "Citator", url: "#citator" },
              {title: "Schema", url: "#schema" },
              {title: "Citation", url: "#citation" },
              {title: "Authority", url: "#authority" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../functions/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Getting Started
      </a>
    </div>
    
  </div>

    

    <h1 id="classes">Classes</h1>
<h2 id="citator">Citator</h2>
<div class="doc doc-object doc-class">
<h3 class="hidden-toc" id="citeurl.Citator" style="visibility: hidden; position: absolute;">
        </h3>
<div class="doc doc-contents first">
<p>CiteURL's main feature: a collection of schemas, and the tools
to apply them to text, to find all kinds of citations in a text.</p>
<p><strong>Attributes:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>schemas</code></td>
<td><code>list</code></td>
<td>
<p>A list of schema objects that this citator will try to
match against.</p>
</td>
</tr>
<tr>
<td><code>generic_id</code></td>
<td><code>str</code></td>
<td>
<p>A common regex the citator will append to each
schema when it is loaded, to recognize a simple citation to
the most-recently cited source.</p>
</td>
</tr>
</tbody>
</table>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.__init__">

<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yaml_paths</span><span class="o">=</span><span class="p">[],</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">generic_id</span><span class="o">=</span><span class="s1">'</span><span class="se">\\</span><span class="s1">b(Ib)?[Ii]d</span><span class="se">\\</span><span class="s1">.(&lt;</span><span class="se">\\</span><span class="s1">/(i|em|u)&gt;)?'</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

      </h3>
<div class="doc doc-contents ">
<p>Calls load_yaml one or more times, to load the citator with
schemas.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>defaults</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to load CiteURL's default schemas</p>
</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>yaml_paths</code></td>
<td><code>list</code></td>
<td>
<p>paths to additional YAML files with schemas that
should be loaded to supplement or replace the defaults.</p>
</td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>generic_id</code></td>
<td><code>str</code></td>
<td>
<p>a common regex to append to all schemas, to
recognize a simple citation to the most-recently cited
source. Detects "id." or "ibid." by default. To
disable, set to None.</p>
</td>
<td><code>'\\b(Ib)?[Ii]d\\.(&lt;\\/(i|em|u)&gt;)?'</code></td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">yaml_paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">defaults</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">generic_id</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">GENERIC_ID</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Calls load_yaml one or more times, to load the citator with</span>
<span class="sd">    schemas.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        defaults: Whether to load CiteURL's default schemas</span>
<span class="sd">        yaml_paths: paths to additional YAML files with schemas that</span>
<span class="sd">            should be loaded to supplement or replace the defaults.</span>
<span class="sd">        generic_id: a common regex to append to all schemas, to</span>
<span class="sd">            recognize a simple citation to the most-recently cited</span>
<span class="sd">            source. Detects "id." or "ibid." by default. To</span>
<span class="sd">            disable, set to None.</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generic_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">generic_id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">schemas</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">defaults</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_yaml</span><span class="p">(</span><span class="n">DEFAULT_YAML_PATH</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">yaml_paths</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_yaml</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.insert_links">

<code class="highlight language-python"><span class="n">insert_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">'class'</span><span class="p">:</span> <span class="s1">'citation'</span><span class="p">},</span> <span class="n">url_optional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">link_detailed_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">link_plain_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">id_break_regex</span><span class="o">=</span><span class="s1">'L</span><span class="se">\\</span><span class="s1">. ?Rev</span><span class="se">\\</span><span class="s1">.|J</span><span class="se">\\</span><span class="s1">. ?Law|</span><span class="se">\\</span><span class="s1">. ?([Cc]ode|[Cc]onst)'</span><span class="p">,</span> <span class="n">id_break_indices</span><span class="o">=</span><span class="p">[])</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Convenience method to return a copy of the given text, with
citation hyperlinks inserted.</p>
<p>If you plan to do more than just insert links, it's better to
get a list of citations with list_citations first, then insert
those links with the module-wide insert_links function.</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">insert_links</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="p">{</span><span class="s1">'class'</span><span class="p">:</span> <span class="s1">'citation'</span><span class="p">},</span>
    <span class="n">url_optional</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">link_detailed_ids</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">link_plain_ids</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">id_break_regex</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">DEFAULT_ID_BREAKS</span><span class="p">,</span>
    <span class="n">id_break_indices</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Convenience method to return a copy of the given text, with</span>
<span class="sd">    citation hyperlinks inserted.</span>

<span class="sd">    If you plan to do more than just insert links, it's better to</span>
<span class="sd">    get a list of citations with list_citations first, then insert</span>
<span class="sd">    those links with the module-wide insert_links function.</span>
<span class="sd">    """</span>
    <span class="n">citations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_citations</span><span class="p">(</span>
        <span class="n">text</span><span class="p">,</span>
        <span class="n">id_break_regex</span><span class="o">=</span><span class="n">id_break_regex</span><span class="p">,</span>
        <span class="n">id_break_indices</span><span class="o">=</span><span class="n">id_break_indices</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">insert_links</span><span class="p">(</span>
        <span class="n">citations</span><span class="p">,</span>
        <span class="n">text</span><span class="p">,</span>
        <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
        <span class="n">link_detailed_ids</span><span class="o">=</span><span class="n">link_detailed_ids</span><span class="p">,</span>
        <span class="n">link_plain_ids</span><span class="o">=</span><span class="n">link_plain_ids</span><span class="p">,</span>
        <span class="n">url_optional</span><span class="o">=</span><span class="n">url_optional</span>
    <span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.list_authorities">

<code class="highlight language-python"><span class="n">list_authorities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Convenience method to list all the authorities cited in a
given text.</p>
<p>If you plan to do more than list authorities, it's better to
get a list of citations with list_citations, then list the
unique authorities with the module-wide list_authorities
function.</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">list_authorities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Convenience method to list all the authorities cited in a</span>
<span class="sd">    given text.</span>

<span class="sd">    If you plan to do more than list authorities, it's better to</span>
<span class="sd">    get a list of citations with list_citations, then list the</span>
<span class="sd">    unique authorities with the module-wide list_authorities</span>
<span class="sd">    function.</span>
<span class="sd">    """</span>
    <span class="n">citations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_citations</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_authorities</span><span class="p">(</span><span class="n">citations</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.list_citations">

<code class="highlight language-python"><span class="n">list_citations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">id_forms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">id_break_regex</span><span class="o">=</span><span class="s1">'L</span><span class="se">\\</span><span class="s1">. ?Rev</span><span class="se">\\</span><span class="s1">.|J</span><span class="se">\\</span><span class="s1">. ?Law|</span><span class="se">\\</span><span class="s1">. ?([Cc]ode|[Cc]onst)'</span><span class="p">,</span> <span class="n">id_break_indices</span><span class="o">=</span><span class="p">[])</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Scan a text and return a list of all citations in it, in
order of appearance.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id_forms</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to detect citations like</p>
</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>id_break_regex</code></td>
<td><code>str</code></td>
<td>
<p>A pattern to look for in the text. Any
occurrence of the pattern will interrupt a chain of
"id." citations as if it were another citation.</p>
</td>
<td><code>'L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst)'</code></td>
</tr>
<tr>
<td><code>id_break_indices</code></td>
<td><code>list</code></td>
<td>
<p>A list of positions in the text
where "id." citations should be interrupted</p>
</td>
<td><code>[]</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>list</code></td>
<td>
<p>A list of citation objects, in order of appearance in the
text.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">list_citations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">id_forms</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">id_break_regex</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">DEFAULT_ID_BREAKS</span><span class="p">,</span>
    <span class="n">id_break_indices</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Scan a text and return a list of all citations in it, in</span>
<span class="sd">    order of appearance.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        id_forms: Whether to detect citations like</span>
<span class="sd">        "Id." and "Id. at 30."</span>
<span class="sd">        id_break_regex: A pattern to look for in the text. Any</span>
<span class="sd">            occurrence of the pattern will interrupt a chain of</span>
<span class="sd">            "id." citations as if it were another citation.</span>
<span class="sd">        id_break_indices: A list of positions in the text</span>
<span class="sd">            where "id." citations should be interrupted</span>
<span class="sd">    Returns:</span>
<span class="sd">        A list of citation objects, in order of appearance in the</span>
<span class="sd">        text.</span>
<span class="sd">    """</span>
    <span class="c1"># First, get full citations:</span>
    <span class="n">citations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">schema</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemas</span><span class="p">:</span>
        <span class="n">citations</span> <span class="o">+=</span> <span class="n">schema</span><span class="o">.</span><span class="n">get_citations</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">shortform_cites</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Then, add shortforms</span>
    <span class="k">for</span> <span class="n">citation</span> <span class="ow">in</span> <span class="n">citations</span><span class="p">:</span>
        <span class="n">shortform_cites</span> <span class="o">+=</span> <span class="n">citation</span><span class="o">.</span><span class="n">_get_shortform_citations</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">citations</span> <span class="o">+=</span> <span class="n">shortform_cites</span>
    <span class="n">citations</span> <span class="o">=</span> <span class="n">_sort_and_remove_overlaps</span><span class="p">(</span><span class="n">citations</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">id_forms</span><span class="p">:</span> <span class="c1"># no need to proceed</span>
        <span class="k">return</span> <span class="n">citations</span>
    <span class="c1"># determine where to break chains of id. citations</span>
    <span class="k">for</span> <span class="n">citation</span> <span class="ow">in</span> <span class="n">citations</span><span class="p">:</span> <span class="c1"># break at full or short citations</span>
        <span class="n">id_break_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">citation</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">id_break_regex</span><span class="p">:</span> <span class="c1">#also break at specified regexes</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">id_break_regex</span><span class="p">)</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">id_break_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">id_break_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">id_break_indices</span><span class="p">))</span>
    <span class="c1"># loop through all citations to find their id citations</span>
    <span class="n">id_citations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">citation</span> <span class="ow">in</span> <span class="n">citations</span><span class="p">:</span>
        <span class="c1"># find the next id break point</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">id_break_indices</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">citation</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">end_point</span> <span class="o">=</span> <span class="n">index</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_point</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">id_break_indices</span> <span class="o">=</span> <span class="n">id_break_indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="c1"># get each citation's id citations until the break point</span>
        <span class="n">id_citations</span> <span class="o">+=</span> <span class="n">citation</span><span class="o">.</span><span class="n">_get_id_citations</span><span class="p">(</span>
            <span class="n">text</span><span class="p">,</span> <span class="n">end_point</span><span class="o">=</span><span class="n">end_point</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">_sort_and_remove_overlaps</span><span class="p">(</span><span class="n">citations</span> <span class="o">+</span> <span class="n">id_citations</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.load_yaml">

<code class="highlight language-python"><span class="n">load_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">use_generic_id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Import schemas from the specified YAML file into the citator.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>path</code></td>
<td><code>str</code></td>
<td>
<p>path to the YAML file to load</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>use_generic_id</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to append the citator's generic_id</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">load_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_generic_id</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Import schemas from the specified YAML file into the citator.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        path: path to the YAML file to load</span>
<span class="sd">        use_generic_id: Whether to append the citator's generic_id</span>
<span class="sd">        citation format to the loaded schemas.</span>
<span class="sd">    """</span>
    <span class="n">yaml_text</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
    <span class="n">yaml_dict</span> <span class="o">=</span> <span class="n">safe_load</span><span class="p">(</span><span class="n">yaml_text</span><span class="p">)</span>

    <span class="c1"># read each item in the YAML into a new schema</span>
    <span class="k">for</span> <span class="n">schema_name</span><span class="p">,</span> <span class="n">schema_data</span> <span class="ow">in</span> <span class="n">yaml_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># if regex is specified in singular form, convert it to a</span>
        <span class="c1"># list with one item, for sake of consistency with multiple-</span>
        <span class="c1"># regex schemas.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'regex'</span><span class="p">,</span> <span class="s1">'broadRegex'</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">schema_data</span><span class="p">:</span>
              <span class="n">schema_data</span><span class="p">[</span><span class="n">key</span> <span class="o">+</span> <span class="s1">'es'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">schema_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

        <span class="c1"># unrelated: if an individual regex is given as a list of</span>
        <span class="c1"># strings (convenient for reusing YAML anchors), concatenate</span>
        <span class="c1"># it to one string.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'regexes'</span><span class="p">,</span> <span class="s1">'broadRegexes'</span><span class="p">,</span> <span class="s1">'idForms'</span><span class="p">,</span> <span class="s1">'shortForms'</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schema_data</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">regex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">schema_data</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">schema_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>

        <span class="c1"># make the schema and add it to the citator, adding the</span>
        <span class="c1"># generic id-form citation if applicable</span>
        <span class="n">new_schema</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">schema_name</span><span class="p">,</span> <span class="o">**</span><span class="n">schema_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_generic_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_id</span><span class="p">:</span>
            <span class="n">new_schema</span><span class="o">.</span><span class="n">idForms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generic_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schemas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_schema</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citator.lookup">

<code class="highlight language-python"><span class="n">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">broad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Convenience method to get the first citation from the first
matching schema, or None.</p>
<p>This is meant for cases where false positives are not an issue,
so it uses broadRegex and case-insensitive matching by default.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>broad</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to use case-insensitive regex matching and,
if available, each schema's broadRegex.</p>
</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>query</code></td>
<td><code>str</code></td>
<td>
<p>The text to scan for a citation</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Citation</code></td>
<td>
<p>A single citation object, or None</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">broad</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Citation</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Convenience method to get the first citation from the first</span>
<span class="sd">    matching schema, or None.</span>

<span class="sd">    This is meant for cases where false positives are not an issue,</span>
<span class="sd">    so it uses broadRegex and case-insensitive matching by default.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        broad: Whether to use case-insensitive regex matching and,</span>
<span class="sd">            if available, each schema's broadRegex.</span>
<span class="sd">        query: The text to scan for a citation</span>
<span class="sd">    Returns:</span>
<span class="sd">        A single citation object, or None</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">schema</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemas</span><span class="p">:</span>
        <span class="n">citation</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">schema</span><span class="o">.</span><span class="n">get_citations</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">broad</span><span class="o">=</span><span class="n">broad</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">citation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">citation</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="schema">Schema</h2>
<div class="doc doc-object doc-class">
<h3 class="hidden-toc" id="citeurl.Schema" style="visibility: hidden; position: absolute;">
        </h3>
<div class="doc doc-contents first">
<p>A pattern to recognize a single kind of citation and generate
URLs from matches.</p>
<p>In most cases, it is more useful to use the Citator class to load
schemas from YAML files and apply them en masse, rather than use
the Schema class directly.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Schema.__init__">

<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">regexes</span><span class="p">,</span> <span class="n">URL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadRegexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idForms</span><span class="o">=</span><span class="p">[],</span> <span class="n">shortForms</span><span class="o">=</span><span class="p">[],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{},</span> <span class="n">operations</span><span class="o">=</span><span class="p">[],</span> <span class="n">parent_citation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_id</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

      </h3>
<div class="doc doc-contents ">
<p>Schema constructor. Primarily meant for use in loading YAML
files and dynamically generating shortform schemas, but can be
run directly if needed.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><code>str</code></td>
<td>
<p>The name of this schema</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>regexes</code></td>
<td><code>list</code></td>
<td>
<p>A list of one or more regexes that this schema will
match. Each regex should be provided as a string, and
should include one or more named capture groups
(i.e. "tokens") that will be used to generate the URL.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>URL</code></td>
<td><code></code></td>
<td>
<p>The template by which to generate URLs from citation
matches. Placeholders in {curly braces} will be replaced
by the value of the token with the same name, after that
token has been processed by the schema</p>
<p>The URL template can be provided either as as a string
or as a list of strings to concatenate. In the latter
case, if a list item contains a placeholder for which
no value is set, the list item will be skipped.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>defaults</code></td>
<td><code>dict</code></td>
<td>
<p>A dictionary of tokens and corresponding default
values which should be set if the token's value is not
otherwise set by a regex capture group.</p>
</td>
<td><code>{}</code></td>
</tr>
<tr>
<td><code>operations</code></td>
<td><code>list</code></td>
<td>
<p>A list of operations to perform on the tokens,
in sequence, to transform them from <code>captured_tokens</code> to
<code>processed_tokens</code>, the tokens that are used for URL
generation.</p>
<p>Each operation must specify a <code>token</code> for its input. It
will also be used as the output of the operation, unless
<code>output</code> is specified. If the specified input token is
not set, the operation will be skipped.</p>
<p>The supported operations are <code>case</code>, <code>sub</code>, <code>lookup</code>,
<code>optionalLookup</code>, <code>lpad</code>, and <code>numberFormat</code>.</p>
<p>The <code>case</code> operation outputs the input token, set to the
specified capitalization, either 'upper', 'lower', or
'title'.</p>
<p>The <code>sub</code> operation performs a regex substitution. It
requires a list of two strings; the first is the regex
to match in the input token, and the second is the text
to replace each match with.</p>
<p>The <code>lookup</code> operation tries to match the input against
a series of dictionary keys (using case-insensitive
regex), and set the output to the corresponding value.
If the dictionary does not contain a matching key, the
entire schema match will retroactively fail.
<code>optionalLookup</code> works the same way, except that failed
lookups will not cause the schema to fail, and will
simply leave tokens unmodified.</p>
<p>The <code>numberFormat</code> operation assumes that the input
token is a number, either in digit form or Roman
numerals. It outputs the same number, converted to the
specified number format, either 'roman' or 'digit'.</p>
</td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>shortForms</code></td>
<td><code>list</code></td>
<td>
<p>A list of regex templates to generate regexes
that recognize short-forms of a parent long-form
citation that has appeared earlier in the text.</p>
<p>Any named section in {curly braces} will be replaced by
the value of the corresponding token from the parent
citation. So if a schema detects a longform citation to
"372 U.S. 335" and has a shortform <code>{volume} {reporter}
at (?P&lt;pincite&gt;\d+)</code>, it will generate the following
regex: <code>372 U.S. at (?P&lt;pincite&gt;\d+)</code>.</p>
</td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>idForms</code></td>
<td><code>list</code></td>
<td>
<p>Think "id.", not ID. Identical to shortForms,
except that these regexes will only match until the
next different citation or other interruption.</p>
</td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>parent_citation</code></td>
<td><code></code></td>
<td>
<p>The citation, if any, that this schema
was created as a shortform of. This argument is
for dynamically-generated schemas, and there is usually
no need to use it manually.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>is_id</code></td>
<td><code></code></td>
<td>
<p>Whether this schema represents an immediate repeat
shortform citation like "id." or "id. at 30". Really
only relevant for procedurally-generated schemas.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">regexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">URL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">broadRegexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">idForms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">shortForms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">defaults</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">operations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">parent_citation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">is_id</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Schema constructor. Primarily meant for use in loading YAML</span>
<span class="sd">    files and dynamically generating shortform schemas, but can be</span>
<span class="sd">    run directly if needed.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        name: The name of this schema</span>

<span class="sd">        regexes: A list of one or more regexes that this schema will</span>
<span class="sd">            match. Each regex should be provided as a string, and</span>
<span class="sd">            should include one or more named capture groups</span>
<span class="sd">            (i.e. "tokens") that will be used to generate the URL.</span>

<span class="sd">        URL: The template by which to generate URLs from citation</span>
<span class="sd">            matches. Placeholders in {curly braces} will be replaced</span>
<span class="sd">            by the value of the token with the same name, after that</span>
<span class="sd">            token has been processed by the schema</span>

<span class="sd">            The URL template can be provided either as as a string</span>
<span class="sd">            or as a list of strings to concatenate. In the latter</span>
<span class="sd">            case, if a list item contains a placeholder for which</span>
<span class="sd">            no value is set, the list item will be skipped.</span>

<span class="sd">        defaults: A dictionary of tokens and corresponding default</span>
<span class="sd">            values which should be set if the token's value is not</span>
<span class="sd">            otherwise set by a regex capture group.</span>

<span class="sd">        operations: A list of operations to perform on the tokens,</span>
<span class="sd">            in sequence, to transform them from `captured_tokens` to</span>
<span class="sd">            `processed_tokens`, the tokens that are used for URL</span>
<span class="sd">            generation.</span>

<span class="sd">            Each operation must specify a `token` for its input. It</span>
<span class="sd">            will also be used as the output of the operation, unless</span>
<span class="sd">            `output` is specified. If the specified input token is</span>
<span class="sd">            not set, the operation will be skipped.</span>

<span class="sd">            The supported operations are `case`, `sub`, `lookup`,</span>
<span class="sd">            `optionalLookup`, `lpad`, and `numberFormat`.</span>

<span class="sd">            The `case` operation outputs the input token, set to the</span>
<span class="sd">            specified capitalization, either 'upper', 'lower', or</span>
<span class="sd">            'title'.</span>

<span class="sd">            The `sub` operation performs a regex substitution. It</span>
<span class="sd">            requires a list of two strings; the first is the regex</span>
<span class="sd">            to match in the input token, and the second is the text</span>
<span class="sd">            to replace each match with.</span>

<span class="sd">            The `lookup` operation tries to match the input against</span>
<span class="sd">            a series of dictionary keys (using case-insensitive</span>
<span class="sd">            regex), and set the output to the corresponding value.</span>
<span class="sd">            If the dictionary does not contain a matching key, the</span>
<span class="sd">            entire schema match will retroactively fail.</span>
<span class="sd">            `optionalLookup` works the same way, except that failed</span>
<span class="sd">            lookups will not cause the schema to fail, and will</span>
<span class="sd">            simply leave tokens unmodified.</span>

<span class="sd">            The `numberFormat` operation assumes that the input</span>
<span class="sd">            token is a number, either in digit form or Roman</span>
<span class="sd">            numerals. It outputs the same number, converted to the</span>
<span class="sd">            specified number format, either 'roman' or 'digit'.</span>

<span class="sd">        shortForms: A list of regex templates to generate regexes</span>
<span class="sd">            that recognize short-forms of a parent long-form</span>
<span class="sd">            citation that has appeared earlier in the text.</span>

<span class="sd">            Any named section in {curly braces} will be replaced by</span>
<span class="sd">            the value of the corresponding token from the parent</span>
<span class="sd">            citation. So if a schema detects a longform citation to</span>
<span class="sd">            "372 U.S. 335" and has a shortform `{volume} {reporter}</span>
<span class="sd">            at (?P&lt;pincite&gt;\d+)`, it will generate the following</span>
<span class="sd">            regex: `372 U.S. at (?P&lt;pincite&gt;\d+)`.</span>

<span class="sd">        idForms: Think "id.", not ID. Identical to shortForms,</span>
<span class="sd">            except that these regexes will only match until the</span>
<span class="sd">            next different citation or other interruption.</span>

<span class="sd">        parent_citation: The citation, if any, that this schema</span>
<span class="sd">            was created as a shortform of. This argument is</span>
<span class="sd">            for dynamically-generated schemas, and there is usually</span>
<span class="sd">            no need to use it manually.</span>

<span class="sd">        is_id: Whether this schema represents an immediate repeat</span>
<span class="sd">            shortform citation like "id." or "id. at 30". Really</span>
<span class="sd">            only relevant for procedurally-generated schemas.</span>
<span class="sd">    """</span>
    <span class="c1"># Basic values</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">regexes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">regexes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_id</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">is_id</span>
    <span class="k">if</span> <span class="n">URL</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">URL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">URL</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> <span class="p">[</span><span class="n">URL</span><span class="p">]</span>
    <span class="c1"># Supplemental regexes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">broadRegexes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">broadRegexes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">idForms</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">idForms</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shortForms</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">shortForms</span>
    <span class="c1"># String operators</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">defaults</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">operations</span>

    <span class="c1"># Extra data for shortform citations</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parent_citation</span><span class="p">:</span> <span class="n">Citation</span> <span class="o">=</span> <span class="n">parent_citation</span>

    <span class="c1"># hack: prevent all regexes from matching mid-word</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'regexes'</span><span class="p">,</span> <span class="s1">'broadRegexes'</span><span class="p">,</span> <span class="s1">'idForms'</span><span class="p">,</span> <span class="s1">'shortForms'</span><span class="p">]:</span>
        <span class="n">regex_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">regex_list</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">regex_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">r</span><span class="s1">'(\b|^)'</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">regex_list</span><span class="p">))</span>

    <span class="c1"># dictionaries of compiled regexes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_regexes</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_broadRegexes</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Schema.get_citations">

<code class="highlight language-python"><span class="n">get_citations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">broad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Generator to return all citations the schema finds in text.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td><code>str</code></td>
<td>
<p>The text to scan for a citation</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>broad</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to use case-insensitive regex matching and,
if available, the schema's broadRegex.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>span</code></td>
<td><code>tuple</code></td>
<td>
<p>A tuple of one or two values determining
the start and end index of where in the text to search
for citations. Defaults to (0,) to scan the entire text.</p>
</td>
<td><code>(0,)</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Iterable</code></td>
<td>
<p>Generator that yields each citation the schema finds in the
    text, or None.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">get_citations</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">broad</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">span</span><span class="p">:</span> <span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Generator to return all citations the schema finds in text.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        text: The text to scan for a citation</span>
<span class="sd">        broad: Whether to use case-insensitive regex matching and,</span>
<span class="sd">            if available, the schema's broadRegex.</span>
<span class="sd">        span: A tuple of one or two values determining</span>
<span class="sd">            the start and end index of where in the text to search</span>
<span class="sd">            for citations. Defaults to (0,) to scan the entire text.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Generator that yields each citation the schema finds in the</span>
<span class="sd">            text, or None.</span>
<span class="sd">    """</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regexes</span><span class="p">)):</span>
        <span class="n">matches</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_re</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">broad</span><span class="p">)</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">citation</span> <span class="o">=</span> <span class="n">Citation</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># skip citations where lookup failed:</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">citation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">citation</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">citation</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Schema.lookup">

<code class="highlight language-python"><span class="n">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">broad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Returns the first citation it finds in the text, or None.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td><code>str</code></td>
<td>
<p>The text to scan for a citation.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>broad</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to use case-insensitive regex matching
and, if available, the schema's broadRegex.</p>
</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>span</code></td>
<td><code>tuple</code></td>
<td>
<p>A tuple of one or two values determining
the start and end index of where in the text to search
for citations. Defaults to (0,) to scan the entire text.</p>
</td>
<td><code>(0,)</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Citation</code></td>
<td>
<p>The first citation this schema finds in the scanned text,
or None.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">broad</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">span</span><span class="p">:</span> <span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Citation</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Returns the first citation it finds in the text, or None.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        text: The text to scan for a citation.</span>
<span class="sd">        broad: Whether to use case-insensitive regex matching</span>
<span class="sd">            and, if available, the schema's broadRegex.</span>
<span class="sd">        span: A tuple of one or two values determining</span>
<span class="sd">            the start and end index of where in the text to search</span>
<span class="sd">            for citations. Defaults to (0,) to scan the entire text.</span>
<span class="sd">    Returns:</span>
<span class="sd">        The first citation this schema finds in the scanned text,</span>
<span class="sd">        or None.</span>
<span class="sd">    """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_citations</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">broad</span><span class="o">=</span><span class="n">broad</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="citation">Citation</h2>
<div class="doc doc-object doc-class">
<h3 class="hidden-toc" id="citeurl.Citation" style="visibility: hidden; position: absolute;">
        </h3>
<div class="doc doc-contents first">
<p>A single citation found in text.</p>
<p><strong>Attributes:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td><code>str</code></td>
<td>
<p>The text of the citation itself, like "42 USC § 1988(b)"</p>
</td>
</tr>
<tr>
<td><code>span</code></td>
<td><code>tuple</code></td>
<td>
<p>The beginning and end positions of this citation in the
source text.</p>
</td>
</tr>
<tr>
<td><code>schema</code></td>
<td><code>Schema</code></td>
<td>
<p>The schema which recognized this citation</p>
</td>
</tr>
<tr>
<td><code>tokens</code></td>
<td><code>dict</code></td>
<td>
<p>Dictionary of the named capture groups from the regex
this citation matched. For "id." and "shortform" citations,
this includes tokens carried over from the parent citation.</p>
</td>
</tr>
<tr>
<td><code>processed_tokens</code></td>
<td><code>dict</code></td>
<td>
<p>Dictionary of tokens after they have been
modified via the schema's processes.</p>
</td>
</tr>
<tr>
<td><code>URL</code></td>
<td><code>str</code></td>
<td>
<p>The URL where a user can read this citation online</p>
</td>
</tr>
</tbody>
</table>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citation.__init__">

<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

      </h3>
<div class="doc doc-contents ">
<p>For internal use. There should be no need to create citations
by means other than a Citator or Schema object.</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Match</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    For internal use. There should be no need to create citations</span>
<span class="sd">    by means other than a Citator or Schema object.</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">:</span> <span class="n">Schema</span> <span class="o">=</span> <span class="n">schema</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># idForm and shortForm citations get values from parent citation</span>
    <span class="c1"># except where their regexes include space for those values</span>
    <span class="k">if</span> <span class="n">schema</span><span class="o">.</span><span class="n">parent_citation</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">schema</span><span class="o">.</span><span class="n">parent_citation</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">processed_tokens</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">_process_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">URL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">()</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Citation.get_link">

<code class="highlight language-python"><span class="n">get_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">'class'</span><span class="p">:</span> <span class="s1">'citation'</span><span class="p">})</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Return citation's link element, with given attributes</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">get_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="p">{</span><span class="s1">'class'</span><span class="p">:</span> <span class="s1">'citation'</span><span class="p">}):</span>
    <span class="sd">"""Return citation's link element, with given attributes"""</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">URL</span><span class="p">:</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">'href'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URL</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">attrs</span><span class="p">[</span><span class="s1">'href'</span><span class="p">]</span>
    <span class="n">attr_str</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">attr_str</span> <span class="o">+=</span> <span class="s1">' </span><span class="si">%s</span><span class="s1">="</span><span class="si">%s</span><span class="s1">"'</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">'&lt;a</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">&lt;/a&gt;'</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="authority">Authority</h2>
<div class="doc doc-object doc-class">
<h3 class="hidden-toc" id="citeurl.Authority" style="visibility: hidden; position: absolute;">
        </h3>
<div class="doc doc-contents first">
<p>A single source cited one or more times in a text.</p>
<p><strong>Attributes:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>defining_tokens</code></td>
<td><code>dict</code></td>
<td>
<p>A dictionary of tokens that define this
authority, such that any citations with incompatible
token values will not match it. Note that this uses
processed_tokens (those which have been modified by
the schema's operations).</p>
</td>
</tr>
<tr>
<td><code>schema</code></td>
<td><code>Schema</code></td>
<td>
<p>The schema which found all the citations to this
authority</p>
</td>
</tr>
<tr>
<td><code>citations</code></td>
<td><code>list</code></td>
<td>
<p>The list of all the citations that refer to
this authority.</p>
</td>
</tr>
<tr>
<td><code>base_citation</code></td>
<td><code></code></td>
<td>
<p>A citation object representing the hypothetical
generic citation to this authority.</p>
</td>
</tr>
<tr>
<td><code>name</code></td>
<td><code>str</code></td>
<td>
<p>The text of base_cite</p>
</td>
</tr>
</tbody>
</table>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Authority.__init__">

<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_cite</span><span class="p">,</span> <span class="n">allowed_differences</span><span class="o">=</span><span class="p">[])</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

      </h3>
<div class="doc doc-contents ">
<p>Define an authority by providing a single long-form citation,
and the list of tokens which, if present in the citation, should
be discarded from the definition of the authority.</p>
<p>Generates a base_citation to represent the generic instance of
this authority.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>first_cite</code></td>
<td><code></code></td>
<td>
<p>A long-form citation object representing the
first and archetypal citation to this authority. The
first_cite will be added as the first entry in the
authority's citation list, and it will be used as the
basis to generate the authority's base_cite.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>allowed_differences</code></td>
<td><code>list</code></td>
<td>
<p>A list of tokens whose values can
differ among citations to the same authority</p>
</td>
<td><code>[]</code></td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_cite</span><span class="p">,</span> <span class="n">allowed_differences</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">"""</span>
<span class="sd">    Define an authority by providing a single long-form citation,</span>
<span class="sd">    and the list of tokens which, if present in the citation, should</span>
<span class="sd">    be discarded from the definition of the authority.</span>

<span class="sd">    Generates a base_citation to represent the generic instance of</span>
<span class="sd">    this authority.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        first_cite: A long-form citation object representing the</span>
<span class="sd">            first and archetypal citation to this authority. The</span>
<span class="sd">            first_cite will be added as the first entry in the</span>
<span class="sd">            authority's citation list, and it will be used as the</span>
<span class="sd">            basis to generate the authority's base_cite.</span>
<span class="sd">        allowed_differences: A list of tokens whose values can</span>
<span class="sd">            differ among citations to the same authority</span>
<span class="sd">    """</span>
    <span class="n">long_cite</span> <span class="o">=</span> <span class="n">first_cite</span><span class="o">.</span><span class="n">_original_cite</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">:</span> <span class="n">Schema</span> <span class="o">=</span> <span class="n">long_cite</span><span class="o">.</span><span class="n">schema</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">citations</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_cite</span><span class="p">]</span>
    <span class="c1"># List the token values that distinguish this authority from</span>
    <span class="c1"># others in the same schema. This uses processed tokens, not</span>
    <span class="c1"># raw, so that a citation to "50 U.S. 5" will match</span>
    <span class="c1"># a citation to "50 U. S. 5", etc.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">defining_tokens</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">first_cite</span><span class="o">.</span><span class="n">processed_tokens</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">first_cite</span><span class="o">.</span><span class="n">processed_tokens</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_differences</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defining_tokens</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_cite</span><span class="o">.</span><span class="n">processed_tokens</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="c1"># Next, derive a base citation to represent this authority.</span>
    <span class="c1"># If the first_citation to this authority isn't a longform, use</span>
    <span class="c1"># whatever longform it's a child of.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_citation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derive_base_citation</span><span class="p">(</span><span class="n">long_cite</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_citation</span> <span class="o">=</span> <span class="n">first_cite</span>
    <span class="c1"># Set other instance variables</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_citation</span><span class="o">.</span><span class="n">text</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">URL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_citation</span><span class="o">.</span><span class="n">URL</span>
    <span class="c1"># finally, give the first citation a reference to this authority</span>
    <span class="n">first_cite</span><span class="o">.</span><span class="n">authority</span> <span class="o">=</span> <span class="bp">self</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Authority.include">

<code class="highlight language-python"><span class="n">include</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">citation</span><span class="p">)</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Adds the citation to this schema's list of citations. Also,
adds the <code>authority</code> tag to the citation, referring back to this
authority.</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">include</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">citation</span><span class="p">):</span>
    <span class="sd">"""Adds the citation to this schema's list of citations. Also,</span>
<span class="sd">    adds the `authority` tag to the citation, referring back to this</span>
<span class="sd">    authority."""</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">citations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">citation</span><span class="p">)</span>
    <span class="n">citation</span><span class="o">.</span><span class="n">authority</span> <span class="o">=</span> <span class="bp">self</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="citeurl.Authority.matches">

<code class="highlight language-python"><span class="n">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">citation</span><span class="p">)</span></code>


      </h3>
<div class="doc doc-contents ">
<p>Checks whether a given citation matches the schema and defining
tokens of this authority.</p>
<details class="quote">
          <summary>Source code in <code>citeurl/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">citation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Checks whether a given citation matches the schema and defining</span>
<span class="sd">    tokens of this authority.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">citation</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defining_tokens</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">citation</span><span class="o">.</span><span class="n">processed_tokens</span>
            <span class="ow">or</span> <span class="n">citation</span><span class="o">.</span><span class="n">processed_tokens</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../functions/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Getting Started
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>