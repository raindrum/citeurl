<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Writing Your Own Schemas - CiteURL</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Writing Your Own Schemas", url: "#_top", children: [
              {title: "The Basic Schema Format", url: "#the-basic-schema-format" },
              {title: "idForms and shortForms", url: "#idforms-and-shortforms" },
              {title: "broadRegex", url: "#broadregex" },
              {title: "operations", url: "#operations" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../schema-yamls/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../schema-yamls/" class="btn btn-xs btn-link">
        Writing Your Own Schemas
      </a>
    </div>
    
  </div>

    

    <h1 id="writing-your-own-schemas">Writing Your Own Schemas</h1>
<p>CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it will never support every possible kind of citation, and you might want to treat certain citations differently than CiteURL does by default.</p>
<p>Schemas <a href="classes/#citeurl.Schema.__init__">can be created at runtime</a>, but it is more practical to write a list of them in a YAML file, and load them when instantiating the <a href="classes#citator">Citator</a>. </p>
<p>Before you proceed, make sure you are fairly familiar with <a href="https://docs.python.org/3/howto/regex.html">Python Regular Expressions</a>, because schemas rely on them heavily.</p>
<p>If you want more examples of schemas after reading this, look at <a href="https://github.com/raindrum/citeurl/blob/main/citeurl/default-schemas.yaml">CiteURL's built-in schemas</a>.</p>
<h2 id="the-basic-schema-format">The Basic Schema Format</h2>
<p>Here is a simplified example of a schema in YAML format:</p>
<pre><code class="language-yaml">- name: United States Code
  regex: (?P&lt;title&gt;\d+) USC § (?P&lt;section&gt;\d+)
  URL: https://www.law.cornell.edu/uscode/text/{title}/{section}
</code></pre>
<p>This schema recognizes any series of one or more digits, followed by " USC § ", followed by another series of digits. It knows that the first string of digits are something called a "title" and the second is a "section". We will call these stored values <code>tokens</code>. Finally, the schema contains a template to generate a URL based on the recognized citation. It does this by replacing the placeholders in {curly braces} with the values from the captured tokens.</p>
<p>Note that any regex, including idForms and shortForms, can be provided as <strong>either as a string or a list of strings</strong>. In the latter case, they will be concatenated (without any separator) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using <a href="https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd">YAML anchors</a>.</p>
<p>URLs can also be specified in list form, but this serves a functional role: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. </p>
<h2 id="idforms-and-shortforms">idForms and shortForms</h2>
<p>The example schema above does not have any way recognize subsequent shortform citations. The schema will recognize "42 USC § 1983", but it will not know that a subsequent "Id. at § 1988" is referring to 42 USC § 1988. For that, you can add a list of <code>idForms</code> to the schema, to recognize a reference to the immediately-preceding citation:</p>
<pre><code class="language-yaml">  idForms:
    - Id\. at § (?P&lt;section&gt;\d+)
</code></pre>
<p>With this field present, the parser will know that when it sees "Id. at § 1988" shortly after a full citation to 42 USC § 1983, this is a child citation, which will retain all the tokens from the parent citation except those which are present in the idForm regex.</p>
<p>While it's not relevant to the example above, you can also define <code>shortForms</code>. These work the same as <code>idForms</code>, except that they match text <em>anywhere</em> after the original long-form citation, whereas <code>idForms</code> will only match until the next different citation (or until a different interruptor defined in <a href="classes/#citator">Citator.list_citations()</a>).</p>
<p>Another feature of <code>idForms</code> and <code>shortForms</code> is that, like URL templates, they can contain placeholders in {curly braces}. These placeholders will be replaced with the text from the long-form citation so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a schema to recognize court cases:</p>
<pre><code class="language-yaml">- name: Caselaw
  regex: (?P&lt;volume&gt;\d+) (?P&lt;reporter&gt;.{3,15}?) (?P&lt;page&gt;\d+)(, (?P&lt;pincite&gt;\d+))?
  shortForms:
    - {volume} {reporter} at (?P&lt;pincite&gt;\d+)
</code></pre>
<p>This schema will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex <code>372 U\.S\. at (?P&lt;pincite&gt;\d+)</code>, to recognize later citations to different pincites in the same case.</p>
<p>To be precise, placeholders in shortforms are replaced by the text <em>as originally matched</em> in the original regex capture group, before any <a href="#mutations">mutations</a> and <a href="#substitutions">substitutions</a> are applied. This is normally the desired behavior, since mutations often turn a token into something that would never be recognized.</p>
<p>An exception applies where the placeholder refers to a token that does not exist in the regex, but which exists as a substitution's <code>outputToken</code>. In those cases, the substitution's output value is used.</p>
<p>This exception is useful in a few situations. For instance, a California court opinion might reference "California Civil Code § 1946.2" once early on, but then shift to a format like "CIV § 1946.2" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the "Civil Code" token, either. But this can be solved by using a substitution to recognize "Civil Code" and, from it, generate a new token "CIV", then generating a short citation form from that:</p>
<pre><code class="language-yaml">- name: California Codes
  regex: California (?P&lt;longCode&gt;Civil Code|Penal Code) § (?P&lt;section&gt;\d+)
  substitutions:
    - token: longCode
      outputToken: abbreviatedCode
      index: {'Civil Code':'CIV', 'Penal Code':'PEN'}
  shortForms:
    - {abbreviatedCode} § (?P&lt;section&gt;\d+)
    - {longCode} § (?P&lt;section&gt;\d+)
</code></pre>
<p>Using the example schema above, CiteURL will be able to recognize a longform citation to "California Civil Code § 1946.2", and then recognize subsequent citations <em>either</em> to "Civil Code" sections <em>or</em> "CIV" sections.</p>
<h2 id="broadregex">broadRegex</h2>
<p><code>broadRegex</code> is an optional alternative regex which, if present, will be used instead of <code>regex</code> in methods like <a href="classes/#citeurl.Schema.lookup">lookup()</a>, where false-positives are not a problem.</p>
<h3 id="defaults">defaults</h3>
<p><code>defaults</code> is a dictionary of tokens whose values will be set to specified values, if they are not set by the regex:</p>
<pre><code class="language-yaml">- name: Demo
  regex: If no number here, assume 3:( (?P&lt;number&gt;\d+))?
  defaults: {'number': '3'}
</code></pre>
<h2 id="operations">operations</h2>
<p>If the captured tokens don't directly correspond to the values that need to be inserted into the URL, you'll need to provide the schema with a list of <code>operations</code> to perform on the dictionary of tokens, to produce values for each placeholder in the URL.</p>
<p>Operations are applied in order of how they are listed in the YAML. Each operation is a dictionary, and it must contain a <code>token</code> corresponding to the token that will be processed. By default, operations modify tokens in place, unless the operation has an <code>output</code> value, specifying a different token to write the output to, leaving the input token unchanged.</p>
<p>Besides a <code>token</code> and optional <code>output</code>, an operation needs one other value to determine the actual operation to perform. These are the options:</p>
<ul>
<li><code>case</code>: Outputs the input token, set to the specified capitalization, either 'upper', 'lower', or 'title'.</li>
<li><code>sub</code>: Given a list containing a regex string followed by a replacement string, this operation will replace all occurrences of the regex with the replacement.</li>
<li></li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../schema-yamls/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../schema-yamls/" class="btn btn-xs btn-link">
        Writing Your Own Schemas
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>