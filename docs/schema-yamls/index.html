<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Writing Your Own Schemas - CiteURL</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Writing Your Own Schemas", url: "#_top", children: [
              {title: "The Basic Schema Format", url: "#the-basic-schema-format" },
              {title: "Token Processing", url: "#token-processing" },
              {title: "Recognizing Shortform Citations", url: "#recognizing-shortform-citations" },
              {title: "Miscellaneous Keys", url: "#miscellaneous-keys" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../functions/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
  </div>

    

    <h1 id="writing-your-own-schemas">Writing Your Own Schemas</h1>
<p>CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it will never support every possible kind of citation, and you might want to treat certain citations differently than CiteURL does by default.</p>
<p>Schemas <a href="classes/#citeurl.Schema.__init__">can be created at runtime</a>, but it is more practical to write a list of them in a YAML file, and load them when instantiating a <a href="classes#citator">Citator</a>. As such, all of <a href="https://github.com/raindrum/citeurl/blob/main/citeurl/default-schemas.yaml">CiteURL's built-in schemas</a>, and the schemas described on this page, are in YAML format.</p>
<p>Before you proceed, make sure you're fairly familiar with <a href="https://docs.python.org/3/howto/regex.html">Python Regular Expressions</a>, because schemas rely on them heavily. You'll also need some basic knowledge of <a href="https://www.w3schools.io/file/yaml-introduction/">YAML</a>.</p>
<h2 id="the-basic-schema-format">The Basic Schema Format</h2>
<p>Here is a simplified example of a schema that you might write to recognize citations to the U.S. Code:</p>
<pre><code class="language-yaml">United States Code:
  regex: (?P&lt;title&gt;\d+) USC § (?P&lt;section&gt;\d+)
  URL: https://www.law.cornell.edu/uscode/text/{title}/{section}
</code></pre>
<p>This schema recognizes any series of one or more digits, followed by " USC § ", followed by another series of digits. It knows that the first string of digits is something called a "title" and the second is a "section". We will call these stored values <code>tokens</code>. Finally, the schema contains a template to generate a URL based on the recognized citation. It does this by replacing the placeholders (i.e. the parts in curly braces) with the values from the captured tokens.</p>
<h3 id="regex-complications">Regex Complications</h3>
<p>In the example above, the regex is provided as a single string. This is perfectly valid, but schemas' regexes can be much more complicated than this, for two reasons:</p>
<ol>
<li>A regex can be provided either as a string (as shown above), <em>or</em> as a list of strings. In the latter case, they will be concatenated (with no spaces) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using <a href="https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd">YAML anchors</a>.</li>
<li>Independent of the first reason, it is possible to give a schema <em>multiple</em> regexes to match, by using the <code>regexes</code> key instead of <code>regex</code>. Normally, this will not be necessary, because the usual solution is to just write one regex to recognize multiple citation formats. However, regexes are limited in that capture groups cannot be rearranged.</li>
</ol>
<p>The example schema above can be rewritten to take advantage of these two features, like so:</p>
<pre><code class="language-yaml">United States Code
  regexes:
    - [&amp;title '(?P&lt;title&gt;\d+)', ' USC ', &amp;section '(Section|§) (?P&lt;section&gt;\d+)']
    - [*section, ' of Title ', *title, ' of the United States Code']
  URL: https://www.law.cornell.edu/uscode/text/{title}/{section}
</code></pre>
<p>The above schema looks unwieldy, and it is; it is a list of lists. However, it provides two advantages over the first schema: First, it is possible to recognize both "42 USC § 1983" and "Section 1983 of Title 42 of the United States Code," which would be impossible with a single regex, since <code>title</code> and <code>section</code> are in a different order. Second, by using YAML anchors it is possible to reuse common pieces of regex, like <code>*section</code>, which can recognize either the word "Section" or a section sign ("§"). This can make it much easier to write and maintain large libraries of schemas.</p>
<h3 id="url-complications">URL Complications</h3>
<p>Another important feature is that a schema's URL, like its regex(es), can be specified as a list of strings to concatenate. However, this serves a functional purpose: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. For instance, the schema below can generate anchor links to subsections of the U.S. Code, but if no subsection is provided, it simply links to the overall page for the section itself:</p>
<pre><code class="language-yaml">United States Code
  regex: (?P&lt;title&gt;\d+) USC § (?P&lt;section&gt;\d+)( \((?P&lt;subsection&gt;[a-z])\)?
  URL:
    - 'https://www.law.cornell.edu/uscode/text/{title}/{section}''
    - '#{subsection}'
</code></pre>
<h2 id="token-processing">Token Processing</h2>
<p>In many cases, the tokens matched in a citation won't directly correspond with the values that need to be inserted into the URL placeholder. For example, your schema might detect a court reporter called "F. App'x." or "Pa. D. &amp; C.4th", but <a href="https://case.law/">Case.Law</a>'s URL scheme needs those reporters to be called "<a href="https://cite.case.law/f-appx/">f-appx</a>" and "<a href="https://cite.case.law/pa-d-c4th/">pa-d-c4th</a>", respectively.</p>
<p>To solve this problem, CiteURL schemas can specify <code>operations</code> that will be performed on the dictionary of matched tokens to turn them into a new dictionary (i.e. <code>processed_tokens</code>) before using it to populate the URL.</p>
<p>This example schema solves the problem by converting the <code>reporter</code> token to lowercase, deleting some common special characters from it, and then replacing spaces with dashes:</p>
<pre><code class="language-yaml">Caselaw Access Project (Simplified):
  regex: (?P&lt;volume&gt;\d+) (?P&lt;reporter&gt;(\D|\d(d|th|rd))+?) (?P&lt;page&gt;\d+)
  operations:
    - token: reporter
      case: lower
    - token: reporter
      sub: [&quot;[.()&amp;,']&quot;, '']
    - token: reporter
      sub: [' ', '-']
  URL: https://cite.case.law/{reporter}/{volume}/{page}
</code></pre>
<p>As shown above, a schema's <code>operations</code> value is a list of operations that will be performed in sequence. Each operation is a dictionary that must specify a <code>token</code> to process, and the kind of operation to perform. Operations process a token in place by default, but if an <code>output</code> is specified, that token will be set or modified instead.</p>
<p>The above example shows two kinds of operation: case modification (<code>case</code>), and regex substitution (<code>sub</code>), but CiteURL supports others as well:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
<th>Required Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>case</code></td>
<td>sets the input token to the specified capitalization</td>
<td><code>upper</code>, <code>lower</code>, or <code>title</code></td>
</tr>
<tr>
<td><code>sub</code></td>
<td>replaces all instances of the provided regex pattern with the replacement string</td>
<td><code>[PATTERN, REPL]</code></td>
</tr>
<tr>
<td><code>lookup</code></td>
<td>uses case-insensitive regex matching to check the token against each pattern until it fully matches, in which case it outputs the corresponding replacement string. If no pattern is matched, it causes the entire schema match to retroactively fail.</td>
<td><code>{PATTERN: REPL, PATTERN: REPL ...}</code></td>
</tr>
<tr>
<td><code>optionalLookup</code></td>
<td>same as <code>lookup</code>, except that if the lookup fails, it simply proceeds without modifying any tokens</td>
<td><code>{PATTERN: REPL, PATTERN: REPL ...}</code></td>
</tr>
<tr>
<td><code>lpad</code></td>
<td>adds zeros to the beginning of the token until it is the specified length</td>
<td>an integer</td>
</tr>
<tr>
<td><code>numberFormat</code></td>
<td>assumes that the token is an integer in digit or roman numeral form, and converts it to the specified form, irrespective of which format it was originally in. The outputted roman numerals are capitalized.</td>
<td><code>roman</code> or <code>digit</code></td>
</tr>
</tbody>
</table>
<p>One final note: If an operation's input token has not been set (as distinct from being set to an empty string), the operation will be skipped.</p>
<h2 id="recognizing-shortform-citations">Recognizing Shortform Citations</h2>
<p>Often, once a particular authority is cited once, subsequent references to it will take a shorter, more contextual format. For example, if a text cites <em>United States v. An Article Consisting of Boxes of Clacker Balls</em>, 413 F. Supp. 1281 (1976), then immediately cites a specific page of it, the citation might look something like "<em>Id</em>. at 1284." Later, once another authority has been cited, the same citation might be referred back to with a citation like "413 F. Supp. at 1289."</p>
<p>To address this, CiteURL can essentially generate new schemas on the fly, whenever it detects a citation. These schemas can be of two forms: <code>shortForms</code> and <code>idForms</code>. In each case, the schema is only applied to text after the original long-form citation. The difference is that <code>shortForms</code> are applied to <em>all</em> of the remaining text, whereas <code>idForms</code> are only matched against the text in between one citation and the next. The <a href="classes/#citator">Citator.list_citations()</a> function also accepts an interruption regex, all occurrences of which will break chains of "id." citations.</p>
<p>Like URL templates, <code>idForms</code> and <code>shortForms</code> may contain placeholders in curly braces. These placeholders will be replaced with the corresponding token matched in the long-form citation, so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a schema to recognize court cases:</p>
<pre><code class="language-yaml">Caselaw Access Project (Simplified):
  regex: (?P&lt;volume&gt;\d+) (?P&lt;reporter&gt;(\D|\d(d|th|rd))+?) (?P&lt;page&gt;\d+)(, (?P&lt;pincite&gt;\d+))?
  idForms:
    - Id\. at (?P&lt;pincite&gt;\d+)
  shortForms:
    - {volume} {reporter} at (?P&lt;pincite&gt;\d+)
</code></pre>
<p>This schema will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex <code>372 U\.S\. at (?P&lt;pincite&gt;\d+)</code>, to recognize later citations to different pincites in the same case.</p>
<p>To be precise, placeholders are replaced by the text <em>as originally matched</em> in the original regex capture group, before any <a href="#token-processing">operations</a> are applied. This is normally the desired behavior, since operations often turn a token into something that would never be recognized. An exception applies where the placeholder refers to a token that only exists after operations are applied. In those cases, the processed token is used.</p>
<p>This exception is useful in a few situations. For instance, a California court opinion might reference "California Civil Code § 1946.2" once early on, but then shift to a format like "CIV § 1946.2" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the "Civil Code" token, either. But this can be solved by using a substitution to recognize "Civil Code" and, from it, generate a new token "CIV", then generating a short citation form from that:</p>
<pre><code class="language-yaml">California Codes:
  regex: California (?P&lt;code&gt;Civil Code|Penal Code) § (?P&lt;section&gt;\d+)
  operations:
    - token: code
      output: abbreviatedCode
      lookup: {'Civil Code':'CIV', 'Penal Code':'PEN'}
  shortForms:
    - {abbreviatedCode} § (?P&lt;section&gt;\d+)
    - {code} § (?P&lt;section&gt;\d+)
</code></pre>
<p>Using the example schema above, CiteURL will be able to recognize a longform citation to "California Civil Code § 1946.2", and then recognize subsequent citations <em>either</em> to "Civil Code" sections <em>or</em> "CIV" sections.</p>
<p>One last note: Unlike a schema's <code>regex</code>, <code>shortForms</code> and <code>idForms</code> are inherently lists, since they are designed to allow multiple alternative regexes. However, like the <code>regex</code> entry, individual list items can optionally be lists of strings, to accommodate YAML anchors. For instance, the following schema is functionally identical to the Caselaw Access Project example above; the only difference is that I structured it so that I would only need to write <code>(?P&lt;pincite&gt;\d+)</code> once:</p>
<pre><code class="language-yaml">Caselaw Access Project (Simplified):
  regex:
    - '(?P&lt;volume&gt;\d+) (?P&lt;reporter&gt;(\D|\d(d|th|rd))+?) (?P&lt;page&gt;\d+)(, '
    - &amp;pin '(?P&lt;pincite&gt;\d+)'
    - ')?'
  idForms:
    - ['Id\. at ', *pin]
  shortForms:
    - ['{volume} {reporter} at ', *pin]
</code></pre>
<h2 id="miscellaneous-keys">Miscellaneous Keys</h2>
<h3 id="defaults">defaults</h3>
<p><code>defaults</code> is a dictionary of tokens whose values will be set to specified values, if they are not set by the regex. Defaults are applied prior to any <a href="#token-processing">operations</a>.</p>
<pre><code class="language-yaml">Example Schema:
  regex: If no number here, assume 3:( (?P&lt;number&gt;\d+))?
  defaults: {'number': '3'}
</code></pre>
<h3 id="broadregex">broadRegex</h3>
<p><code>broadRegex</code> is an optional alternative regex which, if present, will be used instead of <code>regex</code> in methods like <a href="classes/#citeurl.Schema.lookup">lookup()</a>, where convenience is more important than avoiding false positives.</p>
<p>CiteURL's default schemas mainly use it to provide more permissive detection of federal law subsections, so <a href="https://raindrum.github.io/lawsearch">Law Search</a> users can write things like "nlra 8 b 4" instead of "nlra 8(b)(4)."</p>
<p>Like the <code>regexes</code> key, you can use <code>broadRegexes</code> instead of <code>broadRegex</code> if you want to provide a list of multiple regexes. </p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../functions/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>