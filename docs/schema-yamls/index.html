<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Writing Your Own Schemas - CiteURL</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Writing Your Own Schemas", url: "#_top", children: [
              {title: "The Basic Schema Format", url: "#the-basic-schema-format" },
              {title: "idForms and shortForms", url: "#idforms-and-shortforms" },
              {title: "broadRegex", url: "#broadregex" },
              {title: "Token Processing", url: "#token-processing" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../functions/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
  </div>

    

    <h1 id="writing-your-own-schemas">Writing Your Own Schemas</h1>
<p>CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it will never support every possible kind of citation, and you might want to treat certain citations differently than CiteURL does by default.</p>
<p>Schemas <a href="classes/#citeurl.Schema.__init__">can be created at runtime</a>, but it is more practical to write a list of them in a YAML file, and load them when instantiating the <a href="classes#citator">Citator</a>. </p>
<p>Before you proceed, make sure you are fairly familiar with <a href="https://docs.python.org/3/howto/regex.html">Python Regular Expressions</a>, because schemas rely on them heavily.</p>
<p>If you want more examples of schemas after reading this, look at <a href="https://github.com/raindrum/citeurl/blob/main/citeurl/default-schemas.yaml">CiteURL's built-in schemas</a>.</p>
<h2 id="the-basic-schema-format">The Basic Schema Format</h2>
<p>Here is a simplified example of a schema in YAML format:</p>
<pre><code class="language-yaml">- name: United States Code
  regex: (?P&lt;title&gt;\d+) USC § (?P&lt;section&gt;\d+)
  URL: https://www.law.cornell.edu/uscode/text/{title}/{section}
</code></pre>
<p>This schema recognizes any series of one or more digits, followed by " USC § ", followed by another series of digits. It knows that the first string of digits are something called a "title" and the second is a "section". We will call these stored values <code>tokens</code>. Finally, the schema contains a template to generate a URL based on the recognized citation. It does this by replacing the placeholders in {curly braces} with the values from the captured tokens.</p>
<p>Note that any regex, including idForms and shortForms, can be provided as <strong>either as a string or a list of strings</strong>. In the latter case, they will be concatenated (without any separator) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using <a href="https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd">YAML anchors</a>.</p>
<p>URLs can also be specified in list form, but this serves a functional role: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. </p>
<h2 id="idforms-and-shortforms">idForms and shortForms</h2>
<p>The example schema above does not have any way recognize subsequent shortform citations. The schema will recognize "42 USC § 1983", but it will not know that a subsequent "Id. at § 1988" is referring to 42 USC § 1988. For that, you can add a list of <code>idForms</code> to the schema, to recognize a reference to the immediately-preceding citation:</p>
<pre><code class="language-yaml">  idForms:
    - Id\. at § (?P&lt;section&gt;\d+)
</code></pre>
<p>With this field present, the parser will know that when it sees "Id. at § 1988" shortly after a full citation to 42 USC § 1983, this is a child citation, which will retain all the tokens from the parent citation except those which are present in the idForm regex.</p>
<p>While it's not relevant to the example above, you can also define <code>shortForms</code>. These work the same as <code>idForms</code>, except that they match text <em>anywhere</em> after the original long-form citation, whereas <code>idForms</code> will only match until the next different citation (or until a different interruptor defined in <a href="classes/#citator">Citator.list_citations()</a>).</p>
<p>Another feature of <code>idForms</code> and <code>shortForms</code> is that, like URL templates, they can contain placeholders in {curly braces}. These placeholders will be replaced with the text from the long-form citation so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a schema to recognize court cases:</p>
<pre><code class="language-yaml">- name: Caselaw
  regex: (?P&lt;volume&gt;\d+) (?P&lt;reporter&gt;.{3,15}?) (?P&lt;page&gt;\d+)(, (?P&lt;pincite&gt;\d+))?
  shortForms:
    - {volume} {reporter} at (?P&lt;pincite&gt;\d+)
</code></pre>
<p>This schema will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex <code>372 U\.S\. at (?P&lt;pincite&gt;\d+)</code>, to recognize later citations to different pincites in the same case.</p>
<p>To be precise, placeholders in shortforms are replaced by the text <em>as originally matched</em> in the original regex capture group, before any <a href="#mutations">mutations</a> and <a href="#substitutions">substitutions</a> are applied. This is normally the desired behavior, since mutations often turn a token into something that would never be recognized.</p>
<p>An exception applies where the placeholder refers to a token that does not exist in the regex, but which exists as a substitution's <code>outputToken</code>. In those cases, the substitution's output value is used.</p>
<p>This exception is useful in a few situations. For instance, a California court opinion might reference "California Civil Code § 1946.2" once early on, but then shift to a format like "CIV § 1946.2" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the "Civil Code" token, either. But this can be solved by using a substitution to recognize "Civil Code" and, from it, generate a new token "CIV", then generating a short citation form from that:</p>
<pre><code class="language-yaml">- name: California Codes
  regex: California (?P&lt;longCode&gt;Civil Code|Penal Code) § (?P&lt;section&gt;\d+)
  substitutions:
    - token: longCode
      outputToken: abbreviatedCode
      index: {'Civil Code':'CIV', 'Penal Code':'PEN'}
  shortForms:
    - {abbreviatedCode} § (?P&lt;section&gt;\d+)
    - {longCode} § (?P&lt;section&gt;\d+)
</code></pre>
<p>Using the example schema above, CiteURL will be able to recognize a longform citation to "California Civil Code § 1946.2", and then recognize subsequent citations <em>either</em> to "Civil Code" sections <em>or</em> "CIV" sections.</p>
<h2 id="broadregex">broadRegex</h2>
<p><code>broadRegex</code> is an optional alternative regex which, if present, will be used instead of <code>regex</code> in methods like <a href="classes/#citeurl.Schema.lookup">lookup()</a>, where false-positives are not a problem.</p>
<h2 id="token-processing">Token Processing</h2>
<p>What if the captured tokens don't directly correspond to the values that need to be inserted into the URL? For these situations, you'll need to use some combination of <code>defaults</code>, <code>mutations</code>, and <code>substitutions</code> to process the tokens before inserting them into the URL.</p>
<h3 id="mutations">mutations</h3>
<p><code>mutations</code> is a list of dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called <code>token</code>, representing the token to affect.</p>
<p>The supported mutations are <code>case</code>, <code>omit</code>, and the combination of <code>splitter</code> and <code>joiner</code>.</p>
<ul>
<li>
<p><code>case</code> forces the token to the specified capitalization, either 'upper' or 'lower'.</p>
</li>
<li>
<p><code>omit</code> is a string, parsed as regex, all occurrences of which will be removed from the token.</p>
</li>
<li><code>splitter</code> and <code>joiner</code> must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. The <code>joiner</code> string will be placed between the pieces.</li>
</ul>
<p>The following example uses a mutation to convert subsection strings like "(a)(1)(B)" into "a_1_B", the format used on <a href="https://www.law.cornell.edu/">the Cornell website</a>:</p>
<pre><code class="language-yaml">- Name: United States Code
  regex: (?P&lt;title&gt;\d+) USC § (?P&lt;section&gt;\d+)(?P&lt;subsection&gt;(\(\w+\))+)?
  mutations:
    - token: subsection
      splitter: \W
      joiner: _
</code></pre>
<h3 id="substitutions">substitutions</h3>
<p><code>substitutions</code> is a list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain 'token', a string representing the input token for the lookup. It must also contain <code>index</code>, a dict of input values and their corresponding outputs.</p>
<p>By default, the value of <code>token</code> will be changed to the value of the lookup. Alternatively, if you specify an <code>outputToken</code>, that token will be set instead, leaving the input token unchanged. Note that <code>outputToken</code> does not need to exist in the original regex.</p>
<p>If the <code>inputToken</code> does not match a key in the index, the citation match fails, unless the substitution specifies that <code>allowUnmatched</code> is True, in which case a failed substitution simply won't change any values.</p>
<p>You can also include <code>useRegex: true</code> to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy.</p>
<p>The following example uses substitutions to convert citations to the National Labor Relations Act into URLs pointing to the corresponding sections of the U.S. Code:</p>
<pre><code class="language-yaml">- name: National Labor Relations Act
  regex: NLRA § (?P&lt;section&gt;\d+)
  substitutions:
    - inputToken: section
      index: {'1':'151', '2':'152', '3':'153', '4':'154', '5':'155', '6':'156', '7':'157', '8':'158', '9':'159', '10':'160', '11':'161', '12':'162', '13':'163', '14':'164', '15':'165', '16':'166', '17':'167', '18':'168', '19':'169'}
  URL: https://www.law.cornell.edu/uscode/text/8/{section}
</code></pre>
<h3 id="defaults">defaults</h3>
<p><code>defaults</code> is a dictionary of tokens whose values will be set to specified values, if they are not set by the regex:</p>
<pre><code class="language-yaml">- name: Demo
  regex: If no number here, assume 3:( (?P&lt;number&gt;\d+))?
  defaults: {'number': '3'}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../functions/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../functions/" class="btn btn-xs btn-link">
        Functions
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>