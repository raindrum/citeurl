{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started CiteURL is an extensible tool to process legal citations in text and generate links to sites where you can view the cited language online. By default, it supports Bluebook-style citations to the following bodies of law, among others: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico The full list is available here . You can also customize CiteURL to support more bodies of law by writing your own citation schemas in YAML format. Installation CiteURL has been tested with Python version 3.9, but earlier versions probably work. Install Python if you don't have it, then run this command: python -m pip install citeurl Frontends Most of the documentation on this site concerns CiteURL as a Python library you can use in your own projects. But there are a few built-in ways to use it as well. These interfaces are simpler, so their documentation is contained below: LawSearch If you want to try out the citation lookup features without installing anything, you can use LawSearch , a JavaScript implementation of CiteURL that I maintain on my website. LawSearch is mainly meant for end users who just want to look up laws, but it's also helpful as a developer tool to understand the basic process CiteURL uses to generate URLs from citations. Whenever LawSearch is run, it describes the process step-by-step in the developer console. Command-Line Interface Besides LawSearch, the next-simplest way to use CiteURL is via the citeurl command. To create a hyperlink for each citation in input.html and save the result as output.html , use a command like this: citeurl -i input.html -o output.html You can also pipe the output of a command into CiteURL, and read the output in a web browser: curl https://www.courtlistener.com/opinion/109815/carey-v-piphus/ | citeurl -b If you want to look up a single citation instead of processing a block of text, use the -l option, like so: citeurl -l \"42 USC 1983\" If you want to return the top 10 authorities cited in a text, you can use this: citeurl -i input.html -a 10 And if you want to use a your own set of citation schemas , you can use the -s option, followed by the path to a YAML file. If you want to prevent loading CiteURL's default set of schemas, use -n . Markdown Extension CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_schemas : A list of paths to YAML files containing custom citation schemas . Defaults to none. use_defaults : Whether CiteURL should load the default citation schemas. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . link_detailed_ids : Whether to insert links for citations like Id. at 305 . Defaults to True . link_plain_ids : Whether to insert links for citations like Id. . Defaults to False . GNOME Shell Search Provider If you use the GNOME desktop environment, you can install my other project to look up citations right from your desktop! Python Library To use CiteURL as a Python library, you'll need to import the Citator class, which contains most of the important features. Then, instantiate a citator to recognize citations: from citeurl import Citator citator = Citator() After that, you can feed text to the citator to return Citation objects: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, see 42 USC \u00a7 1988(b), and, by discretion, expert fees, see id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on the condition that they waive attorneys fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator.list_citations(text) Once you have a list of citations, you can get information about them: for citation in citations: print(citation.text + ' --- ' + str(citation.schema) + ' --- ' + citation.URL # 42 USC \u00a7 1988(b) --- United States Code --- https://www.law.cornell.edu/uscode/text/42/1988#b # id. at (c) --- United States Code --- https://www.law.cornell.edu/uscode/text/42/1988#c # 477 U.S. 561 --- Caselaw Access Project --- https://cite.case.law/us/477/561 # 475 U.S. 717 --- Caselaw Access Project --- https://cite.case.law/us/475/717 # 477 U.S. at 574-78 --- Caselaw Access Project --- https://cite.case.law/us/477/561#p574 You can also use insert_links() to insert the citations back into the source text as hyperlinks: from citeurl import insert_links output = insert_links(citations, text) print(output) # Federal law provides that courts should award prevailing civil # rights plaintiffs reasonable attorneys fees, see <a class=\"citation\" # href=\"https://www.law.cornell.edu/uscode/text/42/1988#b\">42 USC \u00a7 1988(b)</a>, # and, by discretion, expert fees, see <a class=\"citation\" # href=\"https://www.law.cornell.edu/uscode/text/42/1988#c\">id. at (c)</a>. # This is because the importance of civil rights litigation cannot be # measured by a damages judgment. See Riverside v. Rivera, <a class=\"citation\" # href=\"https://cite.case.law/us/477/561\">477 U.S. 561</a> (1986). # But Evans v. Jeff D. upheld a settlement where the plaintiffs got # everything they wanted, on the condition that they waive attorneys # fees. <a class=\"citation\" href=\"https://cite.case.law/us/475/717\">475 U.S. # 717</a> (1986). This ruling lets savvy defendants create a wedge between # plaintiffs and their attorneys, discouraging civil rights suits and # undermining the court's logic in Riverside, <a class=\"citation\" # href=\"https://cite.case.law/us/477/561#p574\">477 U.S. at 574-78</a>. Or, you can use list_authorities to combine the citations into a list of authorities cited in the text, and see how often each one is cited: from citeurl import list_authorities authorities = list_authorities(citations) for authority in authorities: print(authority) print(len(authority.citations)) # 42 USC \u00a7 1988 # 2 # 477 U.S. 561 # 2 # 475 U.S. 717 # 1 If you want to use CiteURL to recognize citations that aren't supported by its default library, you can create custom citation schemas in YAML files . For more information, see the documentation on the CiteURL module's classes and module-level functions .","title":"Getting Started"},{"location":"#getting-started","text":"CiteURL is an extensible tool to process legal citations in text and generate links to sites where you can view the cited language online. By default, it supports Bluebook-style citations to the following bodies of law, among others: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico The full list is available here . You can also customize CiteURL to support more bodies of law by writing your own citation schemas in YAML format.","title":"Getting Started"},{"location":"#installation","text":"CiteURL has been tested with Python version 3.9, but earlier versions probably work. Install Python if you don't have it, then run this command: python -m pip install citeurl","title":"Installation"},{"location":"#frontends","text":"Most of the documentation on this site concerns CiteURL as a Python library you can use in your own projects. But there are a few built-in ways to use it as well. These interfaces are simpler, so their documentation is contained below:","title":"Frontends"},{"location":"#lawsearch","text":"If you want to try out the citation lookup features without installing anything, you can use LawSearch , a JavaScript implementation of CiteURL that I maintain on my website. LawSearch is mainly meant for end users who just want to look up laws, but it's also helpful as a developer tool to understand the basic process CiteURL uses to generate URLs from citations. Whenever LawSearch is run, it describes the process step-by-step in the developer console.","title":"LawSearch"},{"location":"#command-line-interface","text":"Besides LawSearch, the next-simplest way to use CiteURL is via the citeurl command. To create a hyperlink for each citation in input.html and save the result as output.html , use a command like this: citeurl -i input.html -o output.html You can also pipe the output of a command into CiteURL, and read the output in a web browser: curl https://www.courtlistener.com/opinion/109815/carey-v-piphus/ | citeurl -b If you want to look up a single citation instead of processing a block of text, use the -l option, like so: citeurl -l \"42 USC 1983\" If you want to return the top 10 authorities cited in a text, you can use this: citeurl -i input.html -a 10 And if you want to use a your own set of citation schemas , you can use the -s option, followed by the path to a YAML file. If you want to prevent loading CiteURL's default set of schemas, use -n .","title":"Command-Line Interface"},{"location":"#markdown-extension","text":"CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_schemas : A list of paths to YAML files containing custom citation schemas . Defaults to none. use_defaults : Whether CiteURL should load the default citation schemas. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . link_detailed_ids : Whether to insert links for citations like Id. at 305 . Defaults to True . link_plain_ids : Whether to insert links for citations like Id. . Defaults to False .","title":"Markdown Extension"},{"location":"#gnome-shell-search-provider","text":"If you use the GNOME desktop environment, you can install my other project to look up citations right from your desktop!","title":"GNOME Shell Search Provider"},{"location":"#python-library","text":"To use CiteURL as a Python library, you'll need to import the Citator class, which contains most of the important features. Then, instantiate a citator to recognize citations: from citeurl import Citator citator = Citator() After that, you can feed text to the citator to return Citation objects: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, see 42 USC \u00a7 1988(b), and, by discretion, expert fees, see id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on the condition that they waive attorneys fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator.list_citations(text) Once you have a list of citations, you can get information about them: for citation in citations: print(citation.text + ' --- ' + str(citation.schema) + ' --- ' + citation.URL # 42 USC \u00a7 1988(b) --- United States Code --- https://www.law.cornell.edu/uscode/text/42/1988#b # id. at (c) --- United States Code --- https://www.law.cornell.edu/uscode/text/42/1988#c # 477 U.S. 561 --- Caselaw Access Project --- https://cite.case.law/us/477/561 # 475 U.S. 717 --- Caselaw Access Project --- https://cite.case.law/us/475/717 # 477 U.S. at 574-78 --- Caselaw Access Project --- https://cite.case.law/us/477/561#p574 You can also use insert_links() to insert the citations back into the source text as hyperlinks: from citeurl import insert_links output = insert_links(citations, text) print(output) # Federal law provides that courts should award prevailing civil # rights plaintiffs reasonable attorneys fees, see <a class=\"citation\" # href=\"https://www.law.cornell.edu/uscode/text/42/1988#b\">42 USC \u00a7 1988(b)</a>, # and, by discretion, expert fees, see <a class=\"citation\" # href=\"https://www.law.cornell.edu/uscode/text/42/1988#c\">id. at (c)</a>. # This is because the importance of civil rights litigation cannot be # measured by a damages judgment. See Riverside v. Rivera, <a class=\"citation\" # href=\"https://cite.case.law/us/477/561\">477 U.S. 561</a> (1986). # But Evans v. Jeff D. upheld a settlement where the plaintiffs got # everything they wanted, on the condition that they waive attorneys # fees. <a class=\"citation\" href=\"https://cite.case.law/us/475/717\">475 U.S. # 717</a> (1986). This ruling lets savvy defendants create a wedge between # plaintiffs and their attorneys, discouraging civil rights suits and # undermining the court's logic in Riverside, <a class=\"citation\" # href=\"https://cite.case.law/us/477/561#p574\">477 U.S. at 574-78</a>. Or, you can use list_authorities to combine the citations into a list of authorities cited in the text, and see how often each one is cited: from citeurl import list_authorities authorities = list_authorities(citations) for authority in authorities: print(authority) print(len(authority.citations)) # 42 USC \u00a7 1988 # 2 # 477 U.S. 561 # 2 # 475 U.S. 717 # 1 If you want to use CiteURL to recognize citations that aren't supported by its default library, you can create custom citation schemas in YAML files . For more information, see the documentation on the CiteURL module's classes and module-level functions .","title":"Python Library"},{"location":"classes/","text":"Classes Citator CiteURL's main feature: a collection of schemas, and the tools to apply them to text, to find all kinds of citations in a text. Attributes: Name Type Description schemas list A list of schema objects that this citator will try to match against. generic_id str A common regex the citator will append to each schema when it is loaded, to recognize a simple citation to the most-recently cited source. __init__ ( self , yaml_paths = [], defaults = True , generic_id = ' \\\\ b(Ib)?[Ii]d \\\\ .(< \\\\ /(i|em|u)>)?' ) special Calls load_yaml one or more times, to load the citator with schemas. Parameters: Name Type Description Default defaults bool Whether to load CiteURL's default schemas True yaml_paths list paths to additional YAML files with schemas that should be loaded to supplement or replace the defaults. [] generic_id str a common regex to append to all schemas, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. '\\\\b(Ib)?[Ii]d\\\\.(<\\\\/(i|em|u)>)?' Source code in citeurl/__init__.py def __init__ ( self , yaml_paths : list [ str ] = [], defaults : bool = True , generic_id : str = GENERIC_ID ): \"\"\" Calls load_yaml one or more times, to load the citator with schemas. Arguments: defaults: Whether to load CiteURL's default schemas yaml_paths: paths to additional YAML files with schemas that should be loaded to supplement or replace the defaults. generic_id: a common regex to append to all schemas, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. \"\"\" self . generic_id : str = generic_id self . schemas : list = [] if defaults : self . load_yaml ( DEFAULT_YAML_PATH ) for path in yaml_paths : self . load_yaml ( path ) insert_links ( self , text , attrs = { 'class' : 'citation' }, url_optional = False , link_detailed_ids = True , link_plain_ids = False , id_break_regex = 'L \\\\ . ?Rev \\\\ .|J \\\\ . ?Law| \\\\ . ?([Cc]ode|[Cc]onst)' , id_break_indices = []) Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. Source code in citeurl/__init__.py def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, url_optional : bool = False , link_detailed_ids : bool = True , link_plain_ids : bool = False , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = []) -> str : \"\"\" Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. \"\"\" citations = self . list_citations ( text , id_break_regex = id_break_regex , id_break_indices = id_break_indices ) return insert_links ( citations , text , attrs = attrs , link_detailed_ids = link_detailed_ids , link_plain_ids = link_plain_ids , url_optional = url_optional ) list_authorities ( self , text ) Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. Source code in citeurl/__init__.py def list_authorities ( self , text : str ) -> list : \"\"\" Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. \"\"\" citations = self . list_citations ( text ) return list_authorities ( citations ) list_citations ( self , text , id_forms = True , id_break_regex = 'L \\\\ . ?Rev \\\\ .|J \\\\ . ?Law| \\\\ . ?([Cc]ode|[Cc]onst)' , id_break_indices = []) Scan a text and return a list of all citations in it, in order of appearance. Parameters: Name Type Description Default id_forms bool Whether to detect citations like True id_break_regex str A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. 'L\\\\. ?Rev\\\\.|J\\\\. ?Law|\\\\. ?([Cc]ode|[Cc]onst)' id_break_indices list A list of positions in the text where \"id.\" citations should be interrupted [] Returns: Type Description list A list of citation objects, in order of appearance in the text. Source code in citeurl/__init__.py def list_citations ( self , text : str , id_forms : bool = True , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = [], ) -> list : \"\"\" Scan a text and return a list of all citations in it, in order of appearance. Arguments: id_forms: Whether to detect citations like \"Id.\" and \"Id. at 30.\" id_break_regex: A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. id_break_indices: A list of positions in the text where \"id.\" citations should be interrupted Returns: A list of citation objects, in order of appearance in the text. \"\"\" # First, get full citations: citations = [] for schema in self . schemas : citations += schema . get_citations ( text ) shortform_cites = [] # Then, add shortforms for citation in citations : shortform_cites += citation . _get_shortform_citations ( text ) citations += shortform_cites citations = _sort_and_remove_overlaps ( citations ) if not id_forms : # no need to proceed return citations # determine where to break chains of id. citations for citation in citations : # break at full or short citations id_break_indices . append ( citation . span [ 0 ]) if id_break_regex : #also break at specified regexes matches = re . compile ( id_break_regex ) . finditer ( text ) for match in matches : id_break_indices . append ( match . span ()[ 0 ]) id_break_indices = sorted ( set ( id_break_indices )) # loop through all citations to find their id citations id_citations = [] for citation in citations : # find the next id break point i = - 1 for index in id_break_indices : i += 1 if index > citation . span [ 1 ]: end_point = index break else : end_point = None id_break_indices = id_break_indices [ i :] # get each citation's id citations until the break point id_citations += citation . _get_id_citations ( text , end_point = end_point ) return _sort_and_remove_overlaps ( citations + id_citations ) load_yaml ( self , path , use_generic_id = True ) Import schemas from the specified YAML file into the citator. Parameters: Name Type Description Default path str path to the YAML file to load required use_generic_id bool Whether to append the citator's generic_id True Source code in citeurl/__init__.py def load_yaml ( self , path : str , use_generic_id : bool = True ): \"\"\" Import schemas from the specified YAML file into the citator. Arguments: path: path to the YAML file to load use_generic_id: Whether to append the citator's generic_id citation format to the loaded schemas. \"\"\" yaml_text = Path ( path ) . read_text () yaml_nodes = safe_load ( yaml_text ) for node in yaml_nodes : new_schema = Schema ( ** node ) if use_generic_id and self . generic_id : new_schema . idForms . append ( self . generic_id ) self . schemas . append ( new_schema ) lookup ( self , query , broad = True ) Get Convenience method to get the first citation from the first matching schema, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Parameters: Name Type Description Default broad bool Whether to use case-insensitive regex matching and, if available, each schema's broadRegex. True query str The text to scan for a citation required Returns: Type Description Citation A single citation object, or None Source code in citeurl/__init__.py def lookup ( self , query : str , broad : bool = True ) -> Citation : \"\"\" Get Convenience method to get the first citation from the first matching schema, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Arguments: broad: Whether to use case-insensitive regex matching and, if available, each schema's broadRegex. query: The text to scan for a citation Returns: A single citation object, or None \"\"\" for schema in self . schemas : citation = next ( schema . get_citations ( query , broad = broad ), None ) if citation : return citation return None Schema A pattern to recognize a single kind of citation and generate URLs from matches. In most cases, it is more useful to use the Citator class to load schemas from YAML files and apply them en masse, rather than use the Schema class directly. __init__ ( self , name , regex , URL = None , broadRegex = None , idForms = [], shortForms = [], defaults = {}, mutations = [], substitutions = [], parent_citation = None , is_id = False ) special Schema constructor. Primarily meant for use in loading YAML files and dynamically generating shortform schemas, but can be run directly if needed. Parameters: Name Type Description Default name str The name of this schema required regex The pattern to recognize citations. Can be either a string, or a list of strings. In the latter case, they will be concatenated (without any separator) to form one string. In any case, the regex should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. required URL The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed with mutations and substitutions. The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. None defaults dict A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. {} mutations list Dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called token , representing the token to affect. The supported mutations are case , omit , and the combination of 'splitter' and 'joiner'. 'Case' forces the token to the specified capitalization, either \"upper\" or \"lower\". omit is a string, parsed as regex, all occurrences of which will be removed from the token. splitter and joiner must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. Next, the 'joiner' string will be placed between the pieces. [] substitutions list A list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain token , a string representing the input token for the lookup. It must also contain index , a dict of input values and their corresponding outputs. By default, the value of token will be changed to the value of the lookup. Alternatively, if you specify an 'outputToken', that token will be set instead, leaving the input token unchanged. Note that 'outputToken' does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that allowUnmatched is True, in which case a failed substitution simply won't change any values. You can also include useRegex: true to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. [] shortForms list A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a schema detects a longform citation to \"372 U.S. 335\" and has a shortform {volume} {reporter} at (?P<pincite>\\d+) , it will generate the following regex: 372 U.S. at (?P<pincite>\\d+) . Like the regex parameter, each shortform can be given either as a string or as a list of strings. [] idForms list Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. [] parent_citation The citation, if any, that this schema was created as a shortform of. This argument is for dynamically-generated schemas, and there is usually no need to use it manually. None is_id Whether this schema represents an immediate repeat shortform citation like \"id.\" or \"id. at 30\". Really only relevant for procedurally-generated schemas. False Source code in citeurl/__init__.py def __init__ ( self , name : str , regex , URL = None , broadRegex = None , idForms : list = [], shortForms : list = [], defaults : dict = {}, mutations : list = [], substitutions : list = [], parent_citation = None , is_id = False ): \"\"\" Schema constructor. Primarily meant for use in loading YAML files and dynamically generating shortform schemas, but can be run directly if needed. Arguments: name: The name of this schema regex: The pattern to recognize citations. Can be either a string, or a list of strings. In the latter case, they will be concatenated (without any separator) to form one string. In any case, the regex should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. URL: The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed with mutations and substitutions. The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. defaults: A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. mutations: Dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called `token`, representing the token to affect. The supported mutations are `case`, `omit`, and the combination of 'splitter' and 'joiner'. 'Case' forces the token to the specified capitalization, either \"upper\" or \"lower\". `omit` is a string, parsed as regex, all occurrences of which will be removed from the token. `splitter` and `joiner` must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. Next, the 'joiner' string will be placed between the pieces. substitutions: A list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain `token`, a string representing the input token for the lookup. It must also contain `index`, a dict of input values and their corresponding outputs. By default, the value of `token` will be changed to the value of the lookup. Alternatively, if you specify an 'outputToken', that token will be set instead, leaving the input token unchanged. Note that 'outputToken' does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that `allowUnmatched` is True, in which case a failed substitution simply won't change any values. You can also include `useRegex: true` to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. shortForms: A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a schema detects a longform citation to \"372 U.S. 335\" and has a shortform `{volume} {reporter} at (?P<pincite>\\d+)`, it will generate the following regex: `372 U.S. at (?P<pincite>\\d+)`. Like the regex parameter, each shortform can be given either as a string or as a list of strings. idForms: Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. parent_citation: The citation, if any, that this schema was created as a shortform of. This argument is for dynamically-generated schemas, and there is usually no need to use it manually. is_id: Whether this schema represents an immediate repeat shortform citation like \"id.\" or \"id. at 30\". Really only relevant for procedurally-generated schemas. \"\"\" # Basic values self . name : str = name self . regex : str = r '(\\b|^)' + _join_if_list ( regex ) self . is_id : bool = is_id if URL : self . URL : str = URL if type ( URL ) is list else [ URL ] # Supplemental regexes self . broadRegex : str = _join_if_list ( broadRegex ) if broadRegex else None self . idForms : list = [ _join_if_list ( r ) for r in idForms ] self . shortForms : list = [ _join_if_list ( r ) for r in shortForms ] # String operators self . defaults : dict = defaults try : self . mutations : list = [ self . _Mutation ( ** m ) for m in mutations ] except TypeError : self . mutations : list = mutations try : self . substitutions : list = [ self . _Substitution ( ** s ) for s in substitutions ] except TypeError : self . substitutions : list = substitutions # Extra data for shortform citations self . parent_citation : Citation = parent_citation get_citations ( self , text , broad = False , span = ( 0 ,)) Generator to return all citations the schema finds in text. Parameters: Name Type Description Default text str The text to scan for a citation required broad bool Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. False span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Iterable Generator that yields each citation the schema finds in the text, or None. Source code in citeurl/__init__.py def get_citations ( self , text : str , broad : bool = False , span : tuple = ( 0 ,) ) -> Iterable : \"\"\" Generator to return all citations the schema finds in text. Arguments: text: The text to scan for a citation broad: Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: Generator that yields each citation the schema finds in the text, or None. \"\"\" matches = self . _compiled_re ( broad ) . finditer ( text , * span ) for match in matches : try : citation = Citation ( match , self ) # skip citations where substitution failed: except KeyError : citation = None if citation : yield citation return None lookup ( self , text , broad = True , span = ( 0 ,)) Returns the first citation it finds in the text, or None. Parameters: Name Type Description Default text str The text to scan for a citation. required broad bool Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. True span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Citation The first citation this schema finds in the scanned text, or None. Source code in citeurl/__init__.py def lookup ( self , text : str , broad : bool = True , span : tuple = ( 0 ,) ) -> Citation : \"\"\" Returns the first citation it finds in the text, or None. Arguments: text: The text to scan for a citation. broad: Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: The first citation this schema finds in the scanned text, or None. \"\"\" try : return next ( self . get_citations ( text , broad = broad , span = span )) except : return None Citation A single citation found in text. Attributes: Name Type Description text str The text of the citation itself, like \"42 USC \u00a7 1988(b)\" span tuple The beginning and end positions of this citation in the source text. schema Schema The schema which recognized this citation tokens dict Dictionary of the named capture groups from the regex this citation matched. For \"id.\" and \"shortform\" citations, this includes tokens carried over from the parent citation. processed_tokens dict Dictionary of tokens after they have been modified via mutations and substitutions. URL str The URL where a user can read this citation online __init__ ( self , match , schema ) special For internal use. There should be no need to create citations by means other than a Citator or Schema object. Source code in citeurl/__init__.py def __init__ ( self , match : re . Match , schema ): \"\"\" For internal use. There should be no need to create citations by means other than a Citator or Schema object. \"\"\" self . span : tuple = match . span () self . schema : Schema = schema self . text : str = match . group ( 0 ) # idForm and shortForm citations get values from parent citation # except where their regexes include space for those values if schema . parent_citation : self . tokens : dict = dict ( schema . parent_citation . tokens ) for key , val in match . groupdict () . items (): self . tokens [ key ] = val else : self . tokens : dict = match . groupdict () self . processed_tokens : dict = self . schema . _process_tokens ( self . tokens ) self . URL : str = self . _get_url () get_link ( self , attrs = { 'class' : 'citation' }) Return citation's link element, with given attributes Source code in citeurl/__init__.py def get_link ( self , attrs : dict = { 'class' : 'citation' }): \"\"\"Return citation's link element, with given attributes\"\"\" if self . URL : attrs [ 'href' ] = self . URL else : del attrs [ 'href' ] # why is this necessary? attr_str = '' for key , value in attrs . items (): attr_str += ' %s =\" %s \"' % ( key , value ) return '<a %s > %s </a>' % ( attr_str , self . text ) Authority A single source cited one or more times in a text. Attributes: Name Type Description defining_tokens dict A dictionary of tokens that define this authority, such that any citations with incompatible token values will not match it. Note that this uses processed_tokens (those which have been modified by the schema's mutations and substitutions). schema Schema The schema which found all the citations to this authority citations list The list of all the citations that refer to this authority. base_citation A citation object representing the hypothetical generic citation to this authority. name str The text of base_cite __init__ ( self , first_cite , allowed_differences = []) special Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Parameters: Name Type Description Default first_cite A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_cite. required allowed_differences list A list of tokens whose values can differ among citations to the same authority [] Source code in citeurl/__init__.py def __init__ ( self , first_cite , allowed_differences : list = []): \"\"\" Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Arguments: first_cite: A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_cite. allowed_differences: A list of tokens whose values can differ among citations to the same authority \"\"\" long_cite = first_cite . _original_cite () self . schema : Schema = long_cite . schema self . citations : list = [ first_cite ] # List the token values that distinguish this authority from # others in the same schema. This uses processed tokens, not # raw, so that a citation to \"50 U.S. 5\" will match # a citation to \"50 U. S. 5\", etc. self . defining_tokens : dict = {} for t in first_cite . processed_tokens : if ( first_cite . processed_tokens [ t ] != None and t not in allowed_differences ): self . defining_tokens [ t ] = first_cite . processed_tokens [ t ] # Next, derive a base citation to represent this authority. # If the first_citation to this authority isn't a longform, use # whatever longform it's a child of. try : self . base_citation = self . _derive_base_citation ( long_cite ) except TypeError : self . base_citation = first_cite # Set other instance variables self . name : str = self . base_citation . text self . URL : str = self . base_citation . URL # finally, give the first citation a reference to this authority first_cite . authority = self include ( self , citation ) Adds the citation to this schema's list of citations. Also, adds the authority tag to the citation, referring back to this authority. Source code in citeurl/__init__.py def include ( self , citation ): \"\"\"Adds the citation to this schema's list of citations. Also, adds the `authority` tag to the citation, referring back to this authority.\"\"\" self . citations . append ( citation ) citation . authority = self matches ( self , citation ) Checks whether a given citation matches the schema and defining tokens of this authority. Source code in citeurl/__init__.py def matches ( self , citation ) -> bool : \"\"\" Checks whether a given citation matches the schema and defining tokens of this authority. \"\"\" if self . schema . name != citation . schema . name : return False for key , value in self . defining_tokens . items (): if ( key not in citation . processed_tokens or citation . processed_tokens [ key ] != value ): return False return True","title":"Classes"},{"location":"classes/#classes","text":"","title":"Classes"},{"location":"classes/#citator","text":"","title":"Citator"},{"location":"classes/#citeurl.Citator","text":"CiteURL's main feature: a collection of schemas, and the tools to apply them to text, to find all kinds of citations in a text. Attributes: Name Type Description schemas list A list of schema objects that this citator will try to match against. generic_id str A common regex the citator will append to each schema when it is loaded, to recognize a simple citation to the most-recently cited source.","title":"citeurl.Citator"},{"location":"classes/#citeurl.Citator.__init__","text":"Calls load_yaml one or more times, to load the citator with schemas. Parameters: Name Type Description Default defaults bool Whether to load CiteURL's default schemas True yaml_paths list paths to additional YAML files with schemas that should be loaded to supplement or replace the defaults. [] generic_id str a common regex to append to all schemas, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. '\\\\b(Ib)?[Ii]d\\\\.(<\\\\/(i|em|u)>)?' Source code in citeurl/__init__.py def __init__ ( self , yaml_paths : list [ str ] = [], defaults : bool = True , generic_id : str = GENERIC_ID ): \"\"\" Calls load_yaml one or more times, to load the citator with schemas. Arguments: defaults: Whether to load CiteURL's default schemas yaml_paths: paths to additional YAML files with schemas that should be loaded to supplement or replace the defaults. generic_id: a common regex to append to all schemas, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. \"\"\" self . generic_id : str = generic_id self . schemas : list = [] if defaults : self . load_yaml ( DEFAULT_YAML_PATH ) for path in yaml_paths : self . load_yaml ( path )","title":"__init__()"},{"location":"classes/#citeurl.Citator.insert_links","text":"Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. Source code in citeurl/__init__.py def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, url_optional : bool = False , link_detailed_ids : bool = True , link_plain_ids : bool = False , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = []) -> str : \"\"\" Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. \"\"\" citations = self . list_citations ( text , id_break_regex = id_break_regex , id_break_indices = id_break_indices ) return insert_links ( citations , text , attrs = attrs , link_detailed_ids = link_detailed_ids , link_plain_ids = link_plain_ids , url_optional = url_optional )","title":"insert_links()"},{"location":"classes/#citeurl.Citator.list_authorities","text":"Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. Source code in citeurl/__init__.py def list_authorities ( self , text : str ) -> list : \"\"\" Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. \"\"\" citations = self . list_citations ( text ) return list_authorities ( citations )","title":"list_authorities()"},{"location":"classes/#citeurl.Citator.list_citations","text":"Scan a text and return a list of all citations in it, in order of appearance. Parameters: Name Type Description Default id_forms bool Whether to detect citations like True id_break_regex str A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. 'L\\\\. ?Rev\\\\.|J\\\\. ?Law|\\\\. ?([Cc]ode|[Cc]onst)' id_break_indices list A list of positions in the text where \"id.\" citations should be interrupted [] Returns: Type Description list A list of citation objects, in order of appearance in the text. Source code in citeurl/__init__.py def list_citations ( self , text : str , id_forms : bool = True , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = [], ) -> list : \"\"\" Scan a text and return a list of all citations in it, in order of appearance. Arguments: id_forms: Whether to detect citations like \"Id.\" and \"Id. at 30.\" id_break_regex: A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. id_break_indices: A list of positions in the text where \"id.\" citations should be interrupted Returns: A list of citation objects, in order of appearance in the text. \"\"\" # First, get full citations: citations = [] for schema in self . schemas : citations += schema . get_citations ( text ) shortform_cites = [] # Then, add shortforms for citation in citations : shortform_cites += citation . _get_shortform_citations ( text ) citations += shortform_cites citations = _sort_and_remove_overlaps ( citations ) if not id_forms : # no need to proceed return citations # determine where to break chains of id. citations for citation in citations : # break at full or short citations id_break_indices . append ( citation . span [ 0 ]) if id_break_regex : #also break at specified regexes matches = re . compile ( id_break_regex ) . finditer ( text ) for match in matches : id_break_indices . append ( match . span ()[ 0 ]) id_break_indices = sorted ( set ( id_break_indices )) # loop through all citations to find their id citations id_citations = [] for citation in citations : # find the next id break point i = - 1 for index in id_break_indices : i += 1 if index > citation . span [ 1 ]: end_point = index break else : end_point = None id_break_indices = id_break_indices [ i :] # get each citation's id citations until the break point id_citations += citation . _get_id_citations ( text , end_point = end_point ) return _sort_and_remove_overlaps ( citations + id_citations )","title":"list_citations()"},{"location":"classes/#citeurl.Citator.load_yaml","text":"Import schemas from the specified YAML file into the citator. Parameters: Name Type Description Default path str path to the YAML file to load required use_generic_id bool Whether to append the citator's generic_id True Source code in citeurl/__init__.py def load_yaml ( self , path : str , use_generic_id : bool = True ): \"\"\" Import schemas from the specified YAML file into the citator. Arguments: path: path to the YAML file to load use_generic_id: Whether to append the citator's generic_id citation format to the loaded schemas. \"\"\" yaml_text = Path ( path ) . read_text () yaml_nodes = safe_load ( yaml_text ) for node in yaml_nodes : new_schema = Schema ( ** node ) if use_generic_id and self . generic_id : new_schema . idForms . append ( self . generic_id ) self . schemas . append ( new_schema )","title":"load_yaml()"},{"location":"classes/#citeurl.Citator.lookup","text":"Get Convenience method to get the first citation from the first matching schema, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Parameters: Name Type Description Default broad bool Whether to use case-insensitive regex matching and, if available, each schema's broadRegex. True query str The text to scan for a citation required Returns: Type Description Citation A single citation object, or None Source code in citeurl/__init__.py def lookup ( self , query : str , broad : bool = True ) -> Citation : \"\"\" Get Convenience method to get the first citation from the first matching schema, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Arguments: broad: Whether to use case-insensitive regex matching and, if available, each schema's broadRegex. query: The text to scan for a citation Returns: A single citation object, or None \"\"\" for schema in self . schemas : citation = next ( schema . get_citations ( query , broad = broad ), None ) if citation : return citation return None","title":"lookup()"},{"location":"classes/#schema","text":"","title":"Schema"},{"location":"classes/#citeurl.Schema","text":"A pattern to recognize a single kind of citation and generate URLs from matches. In most cases, it is more useful to use the Citator class to load schemas from YAML files and apply them en masse, rather than use the Schema class directly.","title":"citeurl.Schema"},{"location":"classes/#citeurl.Schema.__init__","text":"Schema constructor. Primarily meant for use in loading YAML files and dynamically generating shortform schemas, but can be run directly if needed. Parameters: Name Type Description Default name str The name of this schema required regex The pattern to recognize citations. Can be either a string, or a list of strings. In the latter case, they will be concatenated (without any separator) to form one string. In any case, the regex should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. required URL The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed with mutations and substitutions. The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. None defaults dict A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. {} mutations list Dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called token , representing the token to affect. The supported mutations are case , omit , and the combination of 'splitter' and 'joiner'. 'Case' forces the token to the specified capitalization, either \"upper\" or \"lower\". omit is a string, parsed as regex, all occurrences of which will be removed from the token. splitter and joiner must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. Next, the 'joiner' string will be placed between the pieces. [] substitutions list A list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain token , a string representing the input token for the lookup. It must also contain index , a dict of input values and their corresponding outputs. By default, the value of token will be changed to the value of the lookup. Alternatively, if you specify an 'outputToken', that token will be set instead, leaving the input token unchanged. Note that 'outputToken' does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that allowUnmatched is True, in which case a failed substitution simply won't change any values. You can also include useRegex: true to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. [] shortForms list A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a schema detects a longform citation to \"372 U.S. 335\" and has a shortform {volume} {reporter} at (?P<pincite>\\d+) , it will generate the following regex: 372 U.S. at (?P<pincite>\\d+) . Like the regex parameter, each shortform can be given either as a string or as a list of strings. [] idForms list Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. [] parent_citation The citation, if any, that this schema was created as a shortform of. This argument is for dynamically-generated schemas, and there is usually no need to use it manually. None is_id Whether this schema represents an immediate repeat shortform citation like \"id.\" or \"id. at 30\". Really only relevant for procedurally-generated schemas. False Source code in citeurl/__init__.py def __init__ ( self , name : str , regex , URL = None , broadRegex = None , idForms : list = [], shortForms : list = [], defaults : dict = {}, mutations : list = [], substitutions : list = [], parent_citation = None , is_id = False ): \"\"\" Schema constructor. Primarily meant for use in loading YAML files and dynamically generating shortform schemas, but can be run directly if needed. Arguments: name: The name of this schema regex: The pattern to recognize citations. Can be either a string, or a list of strings. In the latter case, they will be concatenated (without any separator) to form one string. In any case, the regex should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. URL: The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed with mutations and substitutions. The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. defaults: A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. mutations: Dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called `token`, representing the token to affect. The supported mutations are `case`, `omit`, and the combination of 'splitter' and 'joiner'. 'Case' forces the token to the specified capitalization, either \"upper\" or \"lower\". `omit` is a string, parsed as regex, all occurrences of which will be removed from the token. `splitter` and `joiner` must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. Next, the 'joiner' string will be placed between the pieces. substitutions: A list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain `token`, a string representing the input token for the lookup. It must also contain `index`, a dict of input values and their corresponding outputs. By default, the value of `token` will be changed to the value of the lookup. Alternatively, if you specify an 'outputToken', that token will be set instead, leaving the input token unchanged. Note that 'outputToken' does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that `allowUnmatched` is True, in which case a failed substitution simply won't change any values. You can also include `useRegex: true` to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. shortForms: A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a schema detects a longform citation to \"372 U.S. 335\" and has a shortform `{volume} {reporter} at (?P<pincite>\\d+)`, it will generate the following regex: `372 U.S. at (?P<pincite>\\d+)`. Like the regex parameter, each shortform can be given either as a string or as a list of strings. idForms: Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. parent_citation: The citation, if any, that this schema was created as a shortform of. This argument is for dynamically-generated schemas, and there is usually no need to use it manually. is_id: Whether this schema represents an immediate repeat shortform citation like \"id.\" or \"id. at 30\". Really only relevant for procedurally-generated schemas. \"\"\" # Basic values self . name : str = name self . regex : str = r '(\\b|^)' + _join_if_list ( regex ) self . is_id : bool = is_id if URL : self . URL : str = URL if type ( URL ) is list else [ URL ] # Supplemental regexes self . broadRegex : str = _join_if_list ( broadRegex ) if broadRegex else None self . idForms : list = [ _join_if_list ( r ) for r in idForms ] self . shortForms : list = [ _join_if_list ( r ) for r in shortForms ] # String operators self . defaults : dict = defaults try : self . mutations : list = [ self . _Mutation ( ** m ) for m in mutations ] except TypeError : self . mutations : list = mutations try : self . substitutions : list = [ self . _Substitution ( ** s ) for s in substitutions ] except TypeError : self . substitutions : list = substitutions # Extra data for shortform citations self . parent_citation : Citation = parent_citation","title":"__init__()"},{"location":"classes/#citeurl.Schema.get_citations","text":"Generator to return all citations the schema finds in text. Parameters: Name Type Description Default text str The text to scan for a citation required broad bool Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. False span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Iterable Generator that yields each citation the schema finds in the text, or None. Source code in citeurl/__init__.py def get_citations ( self , text : str , broad : bool = False , span : tuple = ( 0 ,) ) -> Iterable : \"\"\" Generator to return all citations the schema finds in text. Arguments: text: The text to scan for a citation broad: Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: Generator that yields each citation the schema finds in the text, or None. \"\"\" matches = self . _compiled_re ( broad ) . finditer ( text , * span ) for match in matches : try : citation = Citation ( match , self ) # skip citations where substitution failed: except KeyError : citation = None if citation : yield citation return None","title":"get_citations()"},{"location":"classes/#citeurl.Schema.lookup","text":"Returns the first citation it finds in the text, or None. Parameters: Name Type Description Default text str The text to scan for a citation. required broad bool Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. True span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Citation The first citation this schema finds in the scanned text, or None. Source code in citeurl/__init__.py def lookup ( self , text : str , broad : bool = True , span : tuple = ( 0 ,) ) -> Citation : \"\"\" Returns the first citation it finds in the text, or None. Arguments: text: The text to scan for a citation. broad: Whether to use case-insensitive regex matching and, if available, the schema's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: The first citation this schema finds in the scanned text, or None. \"\"\" try : return next ( self . get_citations ( text , broad = broad , span = span )) except : return None","title":"lookup()"},{"location":"classes/#citation","text":"","title":"Citation"},{"location":"classes/#citeurl.Citation","text":"A single citation found in text. Attributes: Name Type Description text str The text of the citation itself, like \"42 USC \u00a7 1988(b)\" span tuple The beginning and end positions of this citation in the source text. schema Schema The schema which recognized this citation tokens dict Dictionary of the named capture groups from the regex this citation matched. For \"id.\" and \"shortform\" citations, this includes tokens carried over from the parent citation. processed_tokens dict Dictionary of tokens after they have been modified via mutations and substitutions. URL str The URL where a user can read this citation online","title":"citeurl.Citation"},{"location":"classes/#citeurl.Citation.__init__","text":"For internal use. There should be no need to create citations by means other than a Citator or Schema object. Source code in citeurl/__init__.py def __init__ ( self , match : re . Match , schema ): \"\"\" For internal use. There should be no need to create citations by means other than a Citator or Schema object. \"\"\" self . span : tuple = match . span () self . schema : Schema = schema self . text : str = match . group ( 0 ) # idForm and shortForm citations get values from parent citation # except where their regexes include space for those values if schema . parent_citation : self . tokens : dict = dict ( schema . parent_citation . tokens ) for key , val in match . groupdict () . items (): self . tokens [ key ] = val else : self . tokens : dict = match . groupdict () self . processed_tokens : dict = self . schema . _process_tokens ( self . tokens ) self . URL : str = self . _get_url ()","title":"__init__()"},{"location":"classes/#citeurl.Citation.get_link","text":"Return citation's link element, with given attributes Source code in citeurl/__init__.py def get_link ( self , attrs : dict = { 'class' : 'citation' }): \"\"\"Return citation's link element, with given attributes\"\"\" if self . URL : attrs [ 'href' ] = self . URL else : del attrs [ 'href' ] # why is this necessary? attr_str = '' for key , value in attrs . items (): attr_str += ' %s =\" %s \"' % ( key , value ) return '<a %s > %s </a>' % ( attr_str , self . text )","title":"get_link()"},{"location":"classes/#authority","text":"","title":"Authority"},{"location":"classes/#citeurl.Authority","text":"A single source cited one or more times in a text. Attributes: Name Type Description defining_tokens dict A dictionary of tokens that define this authority, such that any citations with incompatible token values will not match it. Note that this uses processed_tokens (those which have been modified by the schema's mutations and substitutions). schema Schema The schema which found all the citations to this authority citations list The list of all the citations that refer to this authority. base_citation A citation object representing the hypothetical generic citation to this authority. name str The text of base_cite","title":"citeurl.Authority"},{"location":"classes/#citeurl.Authority.__init__","text":"Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Parameters: Name Type Description Default first_cite A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_cite. required allowed_differences list A list of tokens whose values can differ among citations to the same authority [] Source code in citeurl/__init__.py def __init__ ( self , first_cite , allowed_differences : list = []): \"\"\" Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Arguments: first_cite: A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_cite. allowed_differences: A list of tokens whose values can differ among citations to the same authority \"\"\" long_cite = first_cite . _original_cite () self . schema : Schema = long_cite . schema self . citations : list = [ first_cite ] # List the token values that distinguish this authority from # others in the same schema. This uses processed tokens, not # raw, so that a citation to \"50 U.S. 5\" will match # a citation to \"50 U. S. 5\", etc. self . defining_tokens : dict = {} for t in first_cite . processed_tokens : if ( first_cite . processed_tokens [ t ] != None and t not in allowed_differences ): self . defining_tokens [ t ] = first_cite . processed_tokens [ t ] # Next, derive a base citation to represent this authority. # If the first_citation to this authority isn't a longform, use # whatever longform it's a child of. try : self . base_citation = self . _derive_base_citation ( long_cite ) except TypeError : self . base_citation = first_cite # Set other instance variables self . name : str = self . base_citation . text self . URL : str = self . base_citation . URL # finally, give the first citation a reference to this authority first_cite . authority = self","title":"__init__()"},{"location":"classes/#citeurl.Authority.include","text":"Adds the citation to this schema's list of citations. Also, adds the authority tag to the citation, referring back to this authority. Source code in citeurl/__init__.py def include ( self , citation ): \"\"\"Adds the citation to this schema's list of citations. Also, adds the `authority` tag to the citation, referring back to this authority.\"\"\" self . citations . append ( citation ) citation . authority = self","title":"include()"},{"location":"classes/#citeurl.Authority.matches","text":"Checks whether a given citation matches the schema and defining tokens of this authority. Source code in citeurl/__init__.py def matches ( self , citation ) -> bool : \"\"\" Checks whether a given citation matches the schema and defining tokens of this authority. \"\"\" if self . schema . name != citation . schema . name : return False for key , value in self . defining_tokens . items (): if ( key not in citation . processed_tokens or citation . processed_tokens [ key ] != value ): return False return True","title":"matches()"},{"location":"functions/","text":"Functions Most of CiteURL's core features can be accessed through the Citator class. But if you plan to perform multiple operations with the same set of citations, you can use these module-wide functions without generating a whole new list of citations every time. insert_links() Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Parameters: Name Type Description Default citations list A list of citation objects found in the text required text str The text the citations were found in required attrs dict HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. {'class': 'citation'} link_detailed_ids bool Whether to insert hyperlinks for citations like \"Id. at 30.\" True link_plain_ids bool Whether to insert hyperlinks for simple repeat citations like \"id.\" False url_optional bool Whether to insert link elements for citations that do not have an associated URL False Returns: Type Description str The input text, with HTML links inserted for each citation Source code in citeurl/__init__.py def insert_links ( citations : list , text : str , attrs : dict = { 'class' : 'citation' }, link_detailed_ids : bool = True , link_plain_ids : bool = False , url_optional : bool = False ) -> str : \"\"\" Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Arguments: citations: A list of citation objects found in the text text: The text the citations were found in attrs: HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. link_detailed_ids: Whether to insert hyperlinks for citations like \"Id. at 30.\" link_plain_ids: Whether to insert hyperlinks for simple repeat citations like \"id.\" url_optional: Whether to insert link elements for citations that do not have an associated URL Returns: The input text, with HTML links inserted for each citation \"\"\" offset = 0 for citation in citations : if not citation . URL and not url_optional : continue if citation . schema . is_id : if citation . schema . _compiled_re () . groupindex : if not link_detailed_ids : continue elif not link_plain_ids : continue link = citation . get_link ( attrs = attrs ) cite_start = citation . span [ 0 ] + offset cite_end = citation . span [ 1 ] + offset text = '' . join ([ text [: cite_start ], link , text [ cite_end :]]) offset += len ( link ) - len ( citation . text ) return text list_authorities() Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an authority attribute referring to the proper authority. Parameters: Name Type Description Default citations list The list of citations to combine required unimportant_tokens A list of tokens whose values may differ among citations to the same authority. required Returns: Type Description list A list of authority objects, sorted by the number of citations that refer to each, from most to least. Source code in citeurl/__init__.py def list_authorities ( citations : list , irrelevant_tokens : list = NON_AUTHORITY_TOKENS ) -> list : \"\"\" Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an `authority` attribute referring to the proper authority. Arguments: citations: The list of citations to combine unimportant_tokens: A list of tokens whose values may differ among citations to the same authority. Returns: A list of authority objects, sorted by the number of citations that refer to each, from most to least. \"\"\" authorities = [] for citation in citations : for authority in authorities : if authority . matches ( citation ): authority . include ( citation ) break else : authorities . append ( Authority ( citation , irrelevant_tokens )) def authority_sort_key ( authority ): return 0 - len ( authority . citations ) return sorted ( authorities , key = authority_sort_key )","title":"Functions"},{"location":"functions/#functions","text":"Most of CiteURL's core features can be accessed through the Citator class. But if you plan to perform multiple operations with the same set of citations, you can use these module-wide functions without generating a whole new list of citations every time.","title":"Functions"},{"location":"functions/#insert_links","text":"","title":"insert_links()"},{"location":"functions/#citeurl.insert_links","text":"Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Parameters: Name Type Description Default citations list A list of citation objects found in the text required text str The text the citations were found in required attrs dict HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. {'class': 'citation'} link_detailed_ids bool Whether to insert hyperlinks for citations like \"Id. at 30.\" True link_plain_ids bool Whether to insert hyperlinks for simple repeat citations like \"id.\" False url_optional bool Whether to insert link elements for citations that do not have an associated URL False Returns: Type Description str The input text, with HTML links inserted for each citation Source code in citeurl/__init__.py def insert_links ( citations : list , text : str , attrs : dict = { 'class' : 'citation' }, link_detailed_ids : bool = True , link_plain_ids : bool = False , url_optional : bool = False ) -> str : \"\"\" Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Arguments: citations: A list of citation objects found in the text text: The text the citations were found in attrs: HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. link_detailed_ids: Whether to insert hyperlinks for citations like \"Id. at 30.\" link_plain_ids: Whether to insert hyperlinks for simple repeat citations like \"id.\" url_optional: Whether to insert link elements for citations that do not have an associated URL Returns: The input text, with HTML links inserted for each citation \"\"\" offset = 0 for citation in citations : if not citation . URL and not url_optional : continue if citation . schema . is_id : if citation . schema . _compiled_re () . groupindex : if not link_detailed_ids : continue elif not link_plain_ids : continue link = citation . get_link ( attrs = attrs ) cite_start = citation . span [ 0 ] + offset cite_end = citation . span [ 1 ] + offset text = '' . join ([ text [: cite_start ], link , text [ cite_end :]]) offset += len ( link ) - len ( citation . text ) return text","title":"citeurl.insert_links"},{"location":"functions/#list_authorities","text":"","title":"list_authorities()"},{"location":"functions/#citeurl.list_authorities","text":"Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an authority attribute referring to the proper authority. Parameters: Name Type Description Default citations list The list of citations to combine required unimportant_tokens A list of tokens whose values may differ among citations to the same authority. required Returns: Type Description list A list of authority objects, sorted by the number of citations that refer to each, from most to least. Source code in citeurl/__init__.py def list_authorities ( citations : list , irrelevant_tokens : list = NON_AUTHORITY_TOKENS ) -> list : \"\"\" Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an `authority` attribute referring to the proper authority. Arguments: citations: The list of citations to combine unimportant_tokens: A list of tokens whose values may differ among citations to the same authority. Returns: A list of authority objects, sorted by the number of citations that refer to each, from most to least. \"\"\" authorities = [] for citation in citations : for authority in authorities : if authority . matches ( citation ): authority . include ( citation ) break else : authorities . append ( Authority ( citation , irrelevant_tokens )) def authority_sort_key ( authority ): return 0 - len ( authority . citations ) return sorted ( authorities , key = authority_sort_key )","title":"citeurl.list_authorities"},{"location":"schema-yamls/","text":"Writing Your Own Schemas CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it will never support every possible kind of citation, and you might want to treat certain citations differently than CiteURL does by default. Schemas can be created at runtime , but it is more practical to write a list of them in a YAML file, and load them when instantiating the Citator . Before you proceed, make sure you are fairly familiar with Python Regular Expressions , because schemas rely on them heavily. If you want more examples of schemas after reading this, look at CiteURL's built-in schemas . The Basic Schema Format Here is a simplified example of a schema in YAML format: - name: United States Code regex: (?P<title>\\d+) USC \u00a7 (?P<section>\\d+) URL: https://www.law.cornell.edu/uscode/text/{title}/{section} This schema recognizes any series of one or more digits, followed by \" USC \u00a7 \", followed by another series of digits. It knows that the first string of digits are something called a \"title\" and the second is a \"section\". We will call these stored values tokens . Finally, the schema contains a template to generate a URL based on the recognized citation. It does this by replacing the placeholders in {curly braces} with the values from the captured tokens. Note that any regex, including idForms and shortForms, can be provided as either as a string or a list of strings . In the latter case, they will be concatenated (without any separator) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using YAML anchors . URLs can also be specified in list form, but this serves a functional role: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. idForms and shortForms The example schema above does not have any way recognize subsequent shortform citations. The schema will recognize \"42 USC \u00a7 1983\", but it will not know that a subsequent \"Id. at \u00a7 1988\" is referring to 42 USC \u00a7 1988. For that, you can add a list of idForms to the schema, to recognize a reference to the immediately-preceding citation: idForms: - Id\\. at \u00a7 (?P<section>\\d+) With this field present, the parser will know that when it sees \"Id. at \u00a7 1988\" shortly after a full citation to 42 USC \u00a7 1983, this is a child citation, which will retain all the tokens from the parent citation except those which are present in the idForm regex. While it's not relevant to the example above, you can also define shortForms . These work the same as idForms , except that they match text anywhere after the original long-form citation, whereas idForms will only match until the next different citation (or until a different interruptor defined in Citator.list_citations() ). Another feature of idForms and shortForms is that, like URL templates, they can contain placeholders in {curly braces}. These placeholders will be replaced with the text from the long-form citation so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a schema to recognize court cases: - name: Caselaw regex: (?P<volume>\\d+) (?P<reporter>.{3,15}?) (?P<page>\\d+)(, (?P<pincite>\\d+))? shortForms: - {volume} {reporter} at (?P<pincite>\\d+) This schema will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex 372 U\\.S\\. at (?P<pincite>\\d+) , to recognize later citations to different pincites in the same case. To be precise, placeholders in shortforms are replaced by the text as originally matched in the original regex capture group, before any mutations and substitutions are applied. This is normally the desired behavior, since mutations often turn a token into something that would never be recognized. An exception applies where the placeholder refers to a token that does not exist in the regex, but which exists as a substitution's outputToken . In those cases, the substitution's output value is used. This exception is useful in a few situations. For instance, a California court opinion might reference \"California Civil Code \u00a7 1946.2\" once early on, but then shift to a format like \"CIV \u00a7 1946.2\" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the \"Civil Code\" token, either. But this can be solved by using a substitution to recognize \"Civil Code\" and, from it, generate a new token \"CIV\", then generating a short citation form from that: - name: California Codes regex: California (?P<longCode>Civil Code|Penal Code) \u00a7 (?P<section>\\d+) substitutions: - token: longCode outputToken: abbreviatedCode index: {'Civil Code':'CIV', 'Penal Code':'PEN'} shortForms: - {abbreviatedCode} \u00a7 (?P<section>\\d+) - {longCode} \u00a7 (?P<section>\\d+) Using the example schema above, CiteURL will be able to recognize a longform citation to \"California Civil Code \u00a7 1946.2\", and then recognize subsequent citations either to \"Civil Code\" sections or \"CIV\" sections. broadRegex broadRegex is an optional alternative regex which, if present, will be used instead of regex in methods like lookup() , where false-positives are not a problem. Token Processing What if the captured tokens don't directly correspond to the values that need to be inserted into the URL? For these situations, you'll need to use some combination of defaults , mutations , and substitutions to process the tokens before inserting them into the URL. mutations mutations is a list of dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called token , representing the token to affect. The supported mutations are case , omit , and the combination of splitter and joiner . case forces the token to the specified capitalization, either 'upper' or 'lower'. omit is a string, parsed as regex, all occurrences of which will be removed from the token. splitter and joiner must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. The joiner string will be placed between the pieces. The following example uses a mutation to convert subsection strings like \"(a)(1)(B)\" into \"a_1_B\", the format used on the Cornell website : - Name: United States Code regex: (?P<title>\\d+) USC \u00a7 (?P<section>\\d+)(?P<subsection>(\\(\\w+\\))+)? mutations: - token: subsection splitter: \\W joiner: _ substitutions substitutions is a list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain 'token', a string representing the input token for the lookup. It must also contain index , a dict of input values and their corresponding outputs. By default, the value of token will be changed to the value of the lookup. Alternatively, if you specify an outputToken , that token will be set instead, leaving the input token unchanged. Note that outputToken does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that allowUnmatched is True, in which case a failed substitution simply won't change any values. You can also include useRegex: true to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. The following example uses substitutions to convert citations to the National Labor Relations Act into URLs pointing to the corresponding sections of the U.S. Code: - name: National Labor Relations Act regex: NLRA \u00a7 (?P<section>\\d+) substitutions: - inputToken: section index: {'1':'151', '2':'152', '3':'153', '4':'154', '5':'155', '6':'156', '7':'157', '8':'158', '9':'159', '10':'160', '11':'161', '12':'162', '13':'163', '14':'164', '15':'165', '16':'166', '17':'167', '18':'168', '19':'169'} URL: https://www.law.cornell.edu/uscode/text/8/{section} defaults defaults is a dictionary of tokens whose values will be set to specified values, if they are not set by the regex: - name: Demo regex: If no number here, assume 3:( (?P<number>\\d+))? defaults: {'number': '3'}","title":"Writing Your Own Schemas"},{"location":"schema-yamls/#writing-your-own-schemas","text":"CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it will never support every possible kind of citation, and you might want to treat certain citations differently than CiteURL does by default. Schemas can be created at runtime , but it is more practical to write a list of them in a YAML file, and load them when instantiating the Citator . Before you proceed, make sure you are fairly familiar with Python Regular Expressions , because schemas rely on them heavily. If you want more examples of schemas after reading this, look at CiteURL's built-in schemas .","title":"Writing Your Own Schemas"},{"location":"schema-yamls/#the-basic-schema-format","text":"Here is a simplified example of a schema in YAML format: - name: United States Code regex: (?P<title>\\d+) USC \u00a7 (?P<section>\\d+) URL: https://www.law.cornell.edu/uscode/text/{title}/{section} This schema recognizes any series of one or more digits, followed by \" USC \u00a7 \", followed by another series of digits. It knows that the first string of digits are something called a \"title\" and the second is a \"section\". We will call these stored values tokens . Finally, the schema contains a template to generate a URL based on the recognized citation. It does this by replacing the placeholders in {curly braces} with the values from the captured tokens. Note that any regex, including idForms and shortForms, can be provided as either as a string or a list of strings . In the latter case, they will be concatenated (without any separator) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using YAML anchors . URLs can also be specified in list form, but this serves a functional role: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL.","title":"The Basic Schema Format"},{"location":"schema-yamls/#idforms-and-shortforms","text":"The example schema above does not have any way recognize subsequent shortform citations. The schema will recognize \"42 USC \u00a7 1983\", but it will not know that a subsequent \"Id. at \u00a7 1988\" is referring to 42 USC \u00a7 1988. For that, you can add a list of idForms to the schema, to recognize a reference to the immediately-preceding citation: idForms: - Id\\. at \u00a7 (?P<section>\\d+) With this field present, the parser will know that when it sees \"Id. at \u00a7 1988\" shortly after a full citation to 42 USC \u00a7 1983, this is a child citation, which will retain all the tokens from the parent citation except those which are present in the idForm regex. While it's not relevant to the example above, you can also define shortForms . These work the same as idForms , except that they match text anywhere after the original long-form citation, whereas idForms will only match until the next different citation (or until a different interruptor defined in Citator.list_citations() ). Another feature of idForms and shortForms is that, like URL templates, they can contain placeholders in {curly braces}. These placeholders will be replaced with the text from the long-form citation so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a schema to recognize court cases: - name: Caselaw regex: (?P<volume>\\d+) (?P<reporter>.{3,15}?) (?P<page>\\d+)(, (?P<pincite>\\d+))? shortForms: - {volume} {reporter} at (?P<pincite>\\d+) This schema will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex 372 U\\.S\\. at (?P<pincite>\\d+) , to recognize later citations to different pincites in the same case. To be precise, placeholders in shortforms are replaced by the text as originally matched in the original regex capture group, before any mutations and substitutions are applied. This is normally the desired behavior, since mutations often turn a token into something that would never be recognized. An exception applies where the placeholder refers to a token that does not exist in the regex, but which exists as a substitution's outputToken . In those cases, the substitution's output value is used. This exception is useful in a few situations. For instance, a California court opinion might reference \"California Civil Code \u00a7 1946.2\" once early on, but then shift to a format like \"CIV \u00a7 1946.2\" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the \"Civil Code\" token, either. But this can be solved by using a substitution to recognize \"Civil Code\" and, from it, generate a new token \"CIV\", then generating a short citation form from that: - name: California Codes regex: California (?P<longCode>Civil Code|Penal Code) \u00a7 (?P<section>\\d+) substitutions: - token: longCode outputToken: abbreviatedCode index: {'Civil Code':'CIV', 'Penal Code':'PEN'} shortForms: - {abbreviatedCode} \u00a7 (?P<section>\\d+) - {longCode} \u00a7 (?P<section>\\d+) Using the example schema above, CiteURL will be able to recognize a longform citation to \"California Civil Code \u00a7 1946.2\", and then recognize subsequent citations either to \"Civil Code\" sections or \"CIV\" sections.","title":"idForms and shortForms"},{"location":"schema-yamls/#broadregex","text":"broadRegex is an optional alternative regex which, if present, will be used instead of regex in methods like lookup() , where false-positives are not a problem.","title":"broadRegex"},{"location":"schema-yamls/#token-processing","text":"What if the captured tokens don't directly correspond to the values that need to be inserted into the URL? For these situations, you'll need to use some combination of defaults , mutations , and substitutions to process the tokens before inserting them into the URL.","title":"Token Processing"},{"location":"schema-yamls/#mutations","text":"mutations is a list of dictionaries, each one representing a string manipulation that should be performed on a token before it is inserted into the URL template. Each mutation must contain a key called token , representing the token to affect. The supported mutations are case , omit , and the combination of splitter and joiner . case forces the token to the specified capitalization, either 'upper' or 'lower'. omit is a string, parsed as regex, all occurrences of which will be removed from the token. splitter and joiner must be used together if at all. The former is a string, parsed as regex, which will split the token at each occurrence. The joiner string will be placed between the pieces. The following example uses a mutation to convert subsection strings like \"(a)(1)(B)\" into \"a_1_B\", the format used on the Cornell website : - Name: United States Code regex: (?P<title>\\d+) USC \u00a7 (?P<section>\\d+)(?P<subsection>(\\(\\w+\\))+)? mutations: - token: subsection splitter: \\W joiner: _","title":"mutations"},{"location":"schema-yamls/#substitutions","text":"substitutions is a list of dictionaries, each one representing a lookup operation to modify the value of a token. Each dict must contain 'token', a string representing the input token for the lookup. It must also contain index , a dict of input values and their corresponding outputs. By default, the value of token will be changed to the value of the lookup. Alternatively, if you specify an outputToken , that token will be set instead, leaving the input token unchanged. Note that outputToken does not need to exist in the original regex. If the inputToken does not match a key in the index, the citation match fails, unless the substitution specifies that allowUnmatched is True, in which case a failed substitution simply won't change any values. You can also include useRegex: true to make the dictionary lookup use regex matching rather than normal string matching, but this feature is experimental and likely buggy. The following example uses substitutions to convert citations to the National Labor Relations Act into URLs pointing to the corresponding sections of the U.S. Code: - name: National Labor Relations Act regex: NLRA \u00a7 (?P<section>\\d+) substitutions: - inputToken: section index: {'1':'151', '2':'152', '3':'153', '4':'154', '5':'155', '6':'156', '7':'157', '8':'158', '9':'159', '10':'160', '11':'161', '12':'162', '13':'163', '14':'164', '15':'165', '16':'166', '17':'167', '18':'168', '19':'169'} URL: https://www.law.cornell.edu/uscode/text/8/{section}","title":"substitutions"},{"location":"schema-yamls/#defaults","text":"defaults is a dictionary of tokens whose values will be set to specified values, if they are not set by the regex: - name: Demo regex: If no number here, assume 3:( (?P<number>\\d+))? defaults: {'number': '3'}","title":"defaults"}]}