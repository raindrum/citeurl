{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started CiteURL is an extensible tool that parses legal citations and makes links to websites where you can read the cited language for free. It can be used to quickly look up a reference, or to insert a hyperlink for every long- or short-form citation in a longer text. If you want to quickly try it out, it's available as a web app at citation.link . Here's a sample of the links CiteURL can make: Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b) , and, by discretion, expert fees, id. at (c) . This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574 -78. By default, CiteURL supports Bluebook-style citations to over 130 sources of U.S. law, including: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions the codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico. You can also add more sources of law by writing your own citation templates in YAML format. Installation python3 -m pip install citeurl Usage CiteURL provides four command-line tools: citeurl process : Parse a text and insert an HTML hyperlink for every citation it contains, including shortform citations. citeurl lookup : Look up a single citation and display information about it. citeurl host : Host an instance of CiteURL as a web app like citation.link . citeurl makejs : Export an instance of CiteURL's lookup feature as JavaScript or a static web page. More info is available here . Each command has its own command-line arguments you can view with the -h option. They all share the -t option, which allows you to load a list of custom citation templates in YAML form. Here are a few common use cases: # Process a court opinion and output a version where each citation is hyperlinked: citeurl process -i INPUT_FILE.html -o OUTPUT_FILE.html # Look up a single citation and open it directly in a browser citeurl lookup \"42 USC 1983\" -b # List the top ten authorities cited in a text, from most citations to least: cat INPUT_FILE.html | citeurl process -a 10 # Host a lookup tool with custom templates, and serve it on the local network: citeurl host -t PATH_TO_YOUR_TEMPLATES.YAML -s CiteURL is also available in a few other forms besides the command-line tool: citation.link , the web app a flexible Python library an extension to Python-Markdown a desktop search provider for Linux users with the GNOME shell Credits Many thanks to these websites, which CiteURL's default templates frequently link to: Harvard's Caselaw Access Project - for most court cases CourtListener - for other court cases Cornell's Legal Information Institute - for the U.S. Code and many federal rules Ballotpedia - for the vast majority of state constitutions LawServer.com - for statutes in about a dozen states and territories whose websites don't have a compatible URL scheme By the way, if you get a lot of use out of CiteURL and want to support the project, you can use the link below: \u2615 Buy me a coffee","title":"Getting Started"},{"location":"#getting-started","text":"CiteURL is an extensible tool that parses legal citations and makes links to websites where you can read the cited language for free. It can be used to quickly look up a reference, or to insert a hyperlink for every long- or short-form citation in a longer text. If you want to quickly try it out, it's available as a web app at citation.link . Here's a sample of the links CiteURL can make: Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b) , and, by discretion, expert fees, id. at (c) . This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574 -78. By default, CiteURL supports Bluebook-style citations to over 130 sources of U.S. law, including: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions the codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico. You can also add more sources of law by writing your own citation templates in YAML format.","title":"Getting Started"},{"location":"#installation","text":"python3 -m pip install citeurl","title":"Installation"},{"location":"#usage","text":"CiteURL provides four command-line tools: citeurl process : Parse a text and insert an HTML hyperlink for every citation it contains, including shortform citations. citeurl lookup : Look up a single citation and display information about it. citeurl host : Host an instance of CiteURL as a web app like citation.link . citeurl makejs : Export an instance of CiteURL's lookup feature as JavaScript or a static web page. More info is available here . Each command has its own command-line arguments you can view with the -h option. They all share the -t option, which allows you to load a list of custom citation templates in YAML form. Here are a few common use cases: # Process a court opinion and output a version where each citation is hyperlinked: citeurl process -i INPUT_FILE.html -o OUTPUT_FILE.html # Look up a single citation and open it directly in a browser citeurl lookup \"42 USC 1983\" -b # List the top ten authorities cited in a text, from most citations to least: cat INPUT_FILE.html | citeurl process -a 10 # Host a lookup tool with custom templates, and serve it on the local network: citeurl host -t PATH_TO_YOUR_TEMPLATES.YAML -s CiteURL is also available in a few other forms besides the command-line tool: citation.link , the web app a flexible Python library an extension to Python-Markdown a desktop search provider for Linux users with the GNOME shell","title":"Usage"},{"location":"#credits","text":"Many thanks to these websites, which CiteURL's default templates frequently link to: Harvard's Caselaw Access Project - for most court cases CourtListener - for other court cases Cornell's Legal Information Institute - for the U.S. Code and many federal rules Ballotpedia - for the vast majority of state constitutions LawServer.com - for statutes in about a dozen states and territories whose websites don't have a compatible URL scheme By the way, if you get a lot of use out of CiteURL and want to support the project, you can use the link below: \u2615 Buy me a coffee","title":"Credits"},{"location":"frontends/","text":"CiteURL Frontends CiteURL can be used in a few forms besides the command-line tool and the Python library . Here's what they are: CiteURL Server If you just want to use CiteURL from your web browser, it's hosted as a web app at citation.link . You can also host your own instance of it on your local network or beyond. This is useful if you want to add support for your own custom citation templates . The simplest way is to run this command: citeurl host -st PATH_TO_YOUR_TEMPLATES.YAML Or, if you're using a hosting provider like pythonanywhere.com , you can give it direct access to CiteURL as a Flask application: from citeurl.web.server import App from citeurl import Citator APP = App ( Citator ( yaml_paths = [ 'PATH_TO_YOUR_TEMPLATES.YAML' ])) JavaScript Although CiteURL is primarily a Python program, you can also use it to generate a JavaScript implementation of its citation lookup functionality, including any extra citation templates you've written. This allows it to be hosted on a static website (like mine , for example), or distributed as an HTML file that people can save to their own computers and bookmark as a custom search engine . To make a JavaScript implementation, first make a YAML file with any custom citation templates you'd like to support. Next, open a command line and run the following command: citeurl makejs -e -o output.html -t PATH_TO_YOUR_TEMPLATES.YAML Alternatively, to omit CiteURL's default templates, include the -n option in that command. For more info, run citeurl makejs -h . Markdown Extension CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_templates : A list of paths to YAML files containing custom citation templates . Defaults to none. use_defaults : Whether CiteURL should load the default citation templates. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . redundant_links : Whether to insert a link even when its URL would be the same as the last one. URL_optional : Whether to insert a link even when it doesn't have a URL. break_id_on_regex : Anywhere this string (parsed as regex) appears in the text, chains of citations like id. will be interrupted. Note that this is based on the output HTML, not the original Markdown text. Defaults to L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst) ignore_markup : Whether CiteURL should detect citations even when they are interrupted by markup, like \"\\ Id.\\ at 37.\" Defaults to True . GNOME Shell Search Provider If you use the GNOME desktop environment, you can install my other project to look up citations directly from your desktop!","title":"CiteURL Frontends"},{"location":"frontends/#citeurl-frontends","text":"CiteURL can be used in a few forms besides the command-line tool and the Python library . Here's what they are:","title":"CiteURL Frontends"},{"location":"frontends/#citeurl-server","text":"If you just want to use CiteURL from your web browser, it's hosted as a web app at citation.link . You can also host your own instance of it on your local network or beyond. This is useful if you want to add support for your own custom citation templates . The simplest way is to run this command: citeurl host -st PATH_TO_YOUR_TEMPLATES.YAML Or, if you're using a hosting provider like pythonanywhere.com , you can give it direct access to CiteURL as a Flask application: from citeurl.web.server import App from citeurl import Citator APP = App ( Citator ( yaml_paths = [ 'PATH_TO_YOUR_TEMPLATES.YAML' ]))","title":"CiteURL Server"},{"location":"frontends/#javascript","text":"Although CiteURL is primarily a Python program, you can also use it to generate a JavaScript implementation of its citation lookup functionality, including any extra citation templates you've written. This allows it to be hosted on a static website (like mine , for example), or distributed as an HTML file that people can save to their own computers and bookmark as a custom search engine . To make a JavaScript implementation, first make a YAML file with any custom citation templates you'd like to support. Next, open a command line and run the following command: citeurl makejs -e -o output.html -t PATH_TO_YOUR_TEMPLATES.YAML Alternatively, to omit CiteURL's default templates, include the -n option in that command. For more info, run citeurl makejs -h .","title":"JavaScript"},{"location":"frontends/#markdown-extension","text":"CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_templates : A list of paths to YAML files containing custom citation templates . Defaults to none. use_defaults : Whether CiteURL should load the default citation templates. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . redundant_links : Whether to insert a link even when its URL would be the same as the last one. URL_optional : Whether to insert a link even when it doesn't have a URL. break_id_on_regex : Anywhere this string (parsed as regex) appears in the text, chains of citations like id. will be interrupted. Note that this is based on the output HTML, not the original Markdown text. Defaults to L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst) ignore_markup : Whether CiteURL should detect citations even when they are interrupted by markup, like \"\\ Id.\\ at 37.\" Defaults to True .","title":"Markdown Extension"},{"location":"frontends/#gnome-shell-search-provider","text":"If you use the GNOME desktop environment, you can install my other project to look up citations directly from your desktop!","title":"GNOME Shell Search Provider"},{"location":"library/","text":"Library Reference This page documents how to include CiteURL in your Python programming projects. The first step is to instantiate a Citator , which by default contains all of CiteURL's built-in Templates : from citeurl import Citator citator = Citator () After that, you can feed it text to return a list of Citations it finds: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator . list_cites ( text ) Once you have a list of citations, you can get information about each one: print ( citations [ 0 ] . text ) # 42 USC \u00a7 1988(b) print ( citations [ 0 ] . tokens ) # {'Title': '42', 'Section': '1988', 'subsection': '(b)'} print ( citations [ 0 ] . URL ) # https://www.law.cornell.edu/uscode/text/42/1988#b You can also compare citations to one another, to determine whether they reference the same material or a subsection thereof: art_I = citator . cite ( 'U.S. Const. Art. I' ) also_art_I = citator . cite ( 'Article I of the U.S. Constitution' ) art_I_sec_3 = citator . cite ( 'U.S. Const. Art. I, \u00a7 3' ) assert art_I == also_art_I assert art_I_sec_3 in art_I Finally, if you don't want to bother with all the details, you can also just use insert_links() to turn all the citations in a text into hyperlinks: from citeurl import insert_links text = \"42 USC \u00a7 1988. <i>Id.</i> at (b).\" output = insert_links ( text ) assert output == '<a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988\" title=\"42 U.S.C. \u00a7 1988\">42 USC \u00a7 1988</a>. <a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988#b\" title=\"42 U.S.C. \u00a7 1988(b)\"><i>Id.</i> at (b)</a>.' Citator A collection of citation templates, and the tools to match text against them en masse. Attributes: Name Type Description templates a dictionary of citation templates that this citator will try to match against Source code in citeurl/citator.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 class Citator : \"\"\" A collection of citation templates, and the tools to match text against them en masse. Attributes: templates: a dictionary of citation templates that this citator will try to match against \"\"\" def __init__ ( self , defaults = [ 'caselaw' , 'general federal law' , 'specific federal laws' , 'state law' , 'secondary sources' , ], yaml_paths : list [ str ] = [], templates : dict [ str , Template ] = {}, ): \"\"\" Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Arguments: defaults: names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. yaml_paths: paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. templates: optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. \"\"\" self . templates = {} yamls_path = Path ( __file__ ) . parent . absolute () / 'templates' for name in defaults or []: yaml_file = yamls_path / f ' { name } .yaml' self . load_yaml ( yaml_file . read_text ()) for path in yaml_paths : self . load_yaml ( Path ( path ) . read_text ()) self . templates . update ( templates ) @classmethod def from_yaml ( cls , yaml : str ): \"\"\" Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. \"\"\" citator = cls ( defaults = None ) citator . load_yaml ( yaml ) return citator def to_yaml ( self ): \"Save this citator to a YAML string to load later\" yamls = [ t . to_yaml () for t in self . templates . values ()] return ' \\n\\n ' . join ( yamls ) def load_yaml ( self , yaml : str ): \"\"\" Load templates from the given YAML, overwriting any existing templates with the same name. \"\"\" for name , data in safe_load ( yaml ) . items (): self . templates [ name ] = Template . from_dict ( name , data , inheritables = self . templates ) def cite ( self , text : str , broad : bool = True ) -> Citation : \"\"\" Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. \"\"\" for template in self . templates . values (): cite = template . cite ( text , broad = broad ) if cite : return cite else : return None def list_cites ( self , text : str , id_breaks : re . Pattern = None , ) -> list [ Citation ]: \"\"\" Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. \"\"\" # first get a list of all long and shortform (not id.) citations longforms = [] for template in self . templates . values (): longforms += template . list_longform_cites ( text ) shortforms = [] for citation in longforms : shortforms += citation . get_shortform_cites () citations = longforms + shortforms _sort_and_remove_overlaps ( citations ) # Figure out where to interrupt chains of idform citations, # i.e. anywhere a longform or shortform citation starts, plus # the start of any substring that matches the id_breaks pattern breakpoints = [ c . span [ 0 ] for c in citations ] if id_breaks : breakpoints += [ match . span ()[ 0 ] for match in id_breaks . finditer ( text ) ] breakpoints = sorted ( set ( breakpoints )) # for each cite, look for idform citations until the next cite # or until the next breakpoint idforms = [] for cite in citations : # find the next relevant breakpoint, and delete any # breakpoints that are already behind the current citation for i , breakpoint in enumerate ( breakpoints ): if breakpoint >= cite . span [ 1 ]: breakpoints = breakpoints [ i :] break try : breakpoint = breakpoints [ 0 ] except IndexError : breakpoint = None # find the first idform reference to the citation, then the # first idform reference to that idform, and so on, until # the breakpoint idform = cite . get_idform_cite ( until_index = breakpoint ) while idform : idforms . append ( idform ) idform = idform . get_idform_cite ( until_index = breakpoint ) citations += idforms _sort_and_remove_overlaps ( citations ) return citations def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , ) -> str : \"\"\" Scan a text for citations, and return a text with each citation converted to a hyperlink. Arguments: text: the string to scan for citations. attrs: various HTML link attributes to give to each link add_title: whether to use citation.name for link titles URL_optional: whether to insert a hyperlink even when the citation does not have an associated URL redundant_links: whether to insert a hyperlink if it would point to the same URL as the previous link id_breaks: wherever this regex appears, interrupt chains of \"Id.\"-type citations. ignore_markup: whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \"<i>Id.</i> at 32\" Returns: text, with an HTML `a` element for each citation. \"\"\" # pull out all the inline HTML tags, e.g. <b>, # so they don't interfere with citation matching if ignore_markup : text , stored_tags = _strip_inline_tags ( text ) cite_offsets = [] running_offset = 0 last_URL = None for cite in self . list_cites ( text , id_breaks = id_breaks ): attrs [ 'href' ] = cite . URL if not cite . URL and not URL_optional : continue if not redundant_links and cite . URL == last_URL : continue if add_title : attrs [ 'title' ] = cite . name attr_str = '' . join ([ f ' { k } =\" { v } \"' for k , v in attrs . items () if v ]) link = f '<a { attr_str } > { cite . text } </a>' cite_offset = len ( link ) - len ( cite . text ) cite_offsets . append (( cite . span [ 0 ], # beginning of citation cite_offset , cite . text , )) span = ( cite . span [ 0 ] + running_offset , cite . span [ 1 ] + running_offset ) text = text [: span [ 0 ]] + link + text [ span [ 1 ]:] running_offset += cite_offset last_URL = cite . URL if ignore_markup : running_offset = 0 for tag in stored_tags : temp_offset = 0 while len ( cite_offsets ) > 0 : # only offset by a cite if the tag # is after the cite start if tag [ 1 ] >= cite_offsets [ 0 ][ 0 ]: offset = cite_offsets [ 0 ] # check if the tag is after the cite end tag_start = tag [ 1 ] cite_end = offset [ 0 ] + len ( offset [ 2 ]) if tag_start >= cite_end : running_offset += offset [ 1 ] cite_offsets . pop ( 0 ) # otherwise, don't offset by the length of # the cite's closing </a> tag (length of 4) else : temp_offset = offset [ 1 ] - 4 break else : break tag_pos = tag [ 1 ] + running_offset + temp_offset text = text [: tag_pos ] + tag [ 0 ] + text [ tag_pos :] running_offset += tag [ 2 ] return text def __iter__ ( self ): return self . templates . values () . __iter__ () def __getitem__ ( self , key ): return self . templates [ key ] def __setitem__ ( self , key , value ): self . templates [ key ] = value def __eq__ ( self , other_citator ): return self . templates == other_citator . templates __init__ ( defaults = [ 'caselaw' , 'general federal law' , 'specific federal laws' , 'state law' , 'secondary sources' ], yaml_paths = [], templates = {}) Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Parameters: Name Type Description Default defaults names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. ['caselaw', 'general federal law', 'specific federal laws', 'state law', 'secondary sources'] yaml_paths list [ str ] paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. [] templates dict [ str , Template ] optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. {} Source code in citeurl/citator.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , defaults = [ 'caselaw' , 'general federal law' , 'specific federal laws' , 'state law' , 'secondary sources' , ], yaml_paths : list [ str ] = [], templates : dict [ str , Template ] = {}, ): \"\"\" Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Arguments: defaults: names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. yaml_paths: paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. templates: optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. \"\"\" self . templates = {} yamls_path = Path ( __file__ ) . parent . absolute () / 'templates' for name in defaults or []: yaml_file = yamls_path / f ' { name } .yaml' self . load_yaml ( yaml_file . read_text ()) for path in yaml_paths : self . load_yaml ( Path ( path ) . read_text ()) self . templates . update ( templates ) cite ( text , broad = True ) Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. Source code in citeurl/citator.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def cite ( self , text : str , broad : bool = True ) -> Citation : \"\"\" Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. \"\"\" for template in self . templates . values (): cite = template . cite ( text , broad = broad ) if cite : return cite else : return None from_yaml ( yaml ) classmethod Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. Source code in citeurl/citator.py 370 371 372 373 374 375 376 377 378 @classmethod def from_yaml ( cls , yaml : str ): \"\"\" Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. \"\"\" citator = cls ( defaults = None ) citator . load_yaml ( yaml ) return citator insert_links ( text , attrs = { 'class' : 'citation' }, add_title = True , URL_optional = False , redundant_links = True , id_breaks = None , ignore_markup = True ) Scan a text for citations, and return a text with each citation converted to a hyperlink. Parameters: Name Type Description Default text str the string to scan for citations. required attrs dict various HTML link attributes to give to each link {'class': 'citation'} add_title bool whether to use citation.name for link titles True URL_optional bool whether to insert a hyperlink even when the citation does not have an associated URL False redundant_links bool whether to insert a hyperlink if it would point to the same URL as the previous link True id_breaks re . Pattern wherever this regex appears, interrupt chains of \"Id.\"-type citations. None ignore_markup bool whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \" Id. at 32\" True Returns: Type Description str text, with an HTML a element for each citation. Source code in citeurl/citator.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , ) -> str : \"\"\" Scan a text for citations, and return a text with each citation converted to a hyperlink. Arguments: text: the string to scan for citations. attrs: various HTML link attributes to give to each link add_title: whether to use citation.name for link titles URL_optional: whether to insert a hyperlink even when the citation does not have an associated URL redundant_links: whether to insert a hyperlink if it would point to the same URL as the previous link id_breaks: wherever this regex appears, interrupt chains of \"Id.\"-type citations. ignore_markup: whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \"<i>Id.</i> at 32\" Returns: text, with an HTML `a` element for each citation. \"\"\" # pull out all the inline HTML tags, e.g. <b>, # so they don't interfere with citation matching if ignore_markup : text , stored_tags = _strip_inline_tags ( text ) cite_offsets = [] running_offset = 0 last_URL = None for cite in self . list_cites ( text , id_breaks = id_breaks ): attrs [ 'href' ] = cite . URL if not cite . URL and not URL_optional : continue if not redundant_links and cite . URL == last_URL : continue if add_title : attrs [ 'title' ] = cite . name attr_str = '' . join ([ f ' { k } =\" { v } \"' for k , v in attrs . items () if v ]) link = f '<a { attr_str } > { cite . text } </a>' cite_offset = len ( link ) - len ( cite . text ) cite_offsets . append (( cite . span [ 0 ], # beginning of citation cite_offset , cite . text , )) span = ( cite . span [ 0 ] + running_offset , cite . span [ 1 ] + running_offset ) text = text [: span [ 0 ]] + link + text [ span [ 1 ]:] running_offset += cite_offset last_URL = cite . URL if ignore_markup : running_offset = 0 for tag in stored_tags : temp_offset = 0 while len ( cite_offsets ) > 0 : # only offset by a cite if the tag # is after the cite start if tag [ 1 ] >= cite_offsets [ 0 ][ 0 ]: offset = cite_offsets [ 0 ] # check if the tag is after the cite end tag_start = tag [ 1 ] cite_end = offset [ 0 ] + len ( offset [ 2 ]) if tag_start >= cite_end : running_offset += offset [ 1 ] cite_offsets . pop ( 0 ) # otherwise, don't offset by the length of # the cite's closing </a> tag (length of 4) else : temp_offset = offset [ 1 ] - 4 break else : break tag_pos = tag [ 1 ] + running_offset + temp_offset text = text [: tag_pos ] + tag [ 0 ] + text [ tag_pos :] running_offset += tag [ 2 ] return text list_cites ( text , id_breaks = None ) Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. Source code in citeurl/citator.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def list_cites ( self , text : str , id_breaks : re . Pattern = None , ) -> list [ Citation ]: \"\"\" Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. \"\"\" # first get a list of all long and shortform (not id.) citations longforms = [] for template in self . templates . values (): longforms += template . list_longform_cites ( text ) shortforms = [] for citation in longforms : shortforms += citation . get_shortform_cites () citations = longforms + shortforms _sort_and_remove_overlaps ( citations ) # Figure out where to interrupt chains of idform citations, # i.e. anywhere a longform or shortform citation starts, plus # the start of any substring that matches the id_breaks pattern breakpoints = [ c . span [ 0 ] for c in citations ] if id_breaks : breakpoints += [ match . span ()[ 0 ] for match in id_breaks . finditer ( text ) ] breakpoints = sorted ( set ( breakpoints )) # for each cite, look for idform citations until the next cite # or until the next breakpoint idforms = [] for cite in citations : # find the next relevant breakpoint, and delete any # breakpoints that are already behind the current citation for i , breakpoint in enumerate ( breakpoints ): if breakpoint >= cite . span [ 1 ]: breakpoints = breakpoints [ i :] break try : breakpoint = breakpoints [ 0 ] except IndexError : breakpoint = None # find the first idform reference to the citation, then the # first idform reference to that idform, and so on, until # the breakpoint idform = cite . get_idform_cite ( until_index = breakpoint ) while idform : idforms . append ( idform ) idform = idform . get_idform_cite ( until_index = breakpoint ) citations += idforms _sort_and_remove_overlaps ( citations ) return citations load_yaml ( yaml ) Load templates from the given YAML, overwriting any existing templates with the same name. Source code in citeurl/citator.py 385 386 387 388 389 390 391 392 393 def load_yaml ( self , yaml : str ): \"\"\" Load templates from the given YAML, overwriting any existing templates with the same name. \"\"\" for name , data in safe_load ( yaml ) . items (): self . templates [ name ] = Template . from_dict ( name , data , inheritables = self . templates ) to_yaml () Save this citator to a YAML string to load later Source code in citeurl/citator.py 380 381 382 383 def to_yaml ( self ): \"Save this citator to a YAML string to load later\" yamls = [ t . to_yaml () for t in self . templates . values ()] return ' \\n\\n ' . join ( yamls ) Citation A legal reference found in text. Attributes: Name Type Description tokens dictionary of the values that define this citation, such as its volume and page number, or its title, section, and subsection, etc URL str the location, if any, where this citation can be found online, defined by the template's URL_builder name str a uniform, human-readable representation of this citation, written by the template's name_builder text the actual text of this citation as found in the source text source_text the full text that this citation was found in template the template whose regexes found this citation or its parent parent the earlier citation, if any, that this citation is a shortform or idform child of raw_tokens dictionary of tokens as captured in the original regex match, before normalization. Note that for child citations, raw_tokens will include any raw_tokens inferred from the parent citation. idform_regexes list of regex pattern objects to find child citations later in the text, valid until the next different citation appears. shortform_regexes list of regex pattern objects to find child citations anywhere in the subsequent text Source code in citeurl/citation.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class Citation : \"\"\" A legal reference found in text. Attributes: tokens: dictionary of the values that define this citation, such as its volume and page number, or its title, section, and subsection, etc URL: the location, if any, where this citation can be found online, defined by the template's URL_builder name: a uniform, human-readable representation of this citation, written by the template's name_builder text: the actual text of this citation as found in the source text source_text: the full text that this citation was found in template: the template whose regexes found this citation or its parent parent: the earlier citation, if any, that this citation is a shortform or idform child of raw_tokens: dictionary of tokens as captured in the original regex match, before normalization. Note that for child citations, raw_tokens will include any raw_tokens inferred from the parent citation. idform_regexes: list of regex pattern objects to find child citations later in the text, valid until the next different citation appears. shortform_regexes: list of regex pattern objects to find child citations anywhere in the subsequent text \"\"\" def __init__ ( self , match : re . match , template , parent = None , ): self . match = match self . text = match . group ( 0 ) self . source_text = match . string self . span = match . span () self . template = template self . parent = parent self . tokens = {} self . raw_tokens = match . groupdict () # copy raw_tokens (in order) from the parent citation, but # stop at the first one that the child citation overwrites if parent : merged_tokens = {} for k in template . tokens . keys (): if self . raw_tokens . get ( k ): merged_tokens . update ( self . raw_tokens ) break else : merged_tokens [ k ] = parent . raw_tokens . get ( k ) self . raw_tokens = merged_tokens # normalize raw_tokens to get consistent token values across # differently-formatted citations to the same source. # This will raise a SyntaxError if a mandatory edit fails for name , ttype in template . tokens . items (): value = self . raw_tokens . get ( name ) self . tokens [ name ] = ttype . normalize ( value ) # Finally, compile the citation's idform and shortform regexes. # To avoid unneccessary work, first try to copy regexes from the # parent citation if applicable. if parent and parent . raw_tokens == self . raw_tokens : # then we can safely copy the parent's regexes to the child self . idform_regexes = parent . idform_regexes self . shortform_regexes = parent . shortform_regexes return # otherwise we'll need to compile new shortform regexes, # but we can still copy some of them from the parent kwargs = { 'replacements' : self . raw_tokens , 'token_prefix' : 'same' , } if parent : # we can copy regexes, but only if they do not reference a # specific value from the citation, e.g. {same volume}. self . shortform_regexes = [ ( re . compile ( process_pattern ( pattern , ** kwargs )) if '{same ' in pattern else parent . shortform_regexes [ i ] ) for i , pattern in enumerate ( template . _processed_shortforms ) ] self . idform_regexes = [ ( re . compile ( process_pattern ( pattern , ** kwargs )) if '{same ' in pattern else parent . idform_regexes [ i ] ) for i , pattern in enumerate ( template . _processed_idforms ) ] else : # compile all-new idforms and shortforms self . shortform_regexes = [ re . compile ( process_pattern ( pattern , ** kwargs )) for pattern in self . template . _processed_shortforms ] self . idform_regexes = [ re . compile ( process_pattern ( pattern , ** kwargs )) for pattern in self . template . _processed_idforms ] self . idform_regexes . append ( BASIC_ID_REGEX ) @property def URL ( self ) -> str : if self . template . URL_builder : url = self . template . URL_builder ( self . tokens ) if url : url = url . replace ( ' ' , '%20' ) else : url = None return url @property def name ( self ) -> str : if self . template . name_builder : return self . template . name_builder ( self . tokens ) else : return None def get_shortform_cites ( self ) -> Iterable : keep_trying = True span_start = self . span [ 1 ] while keep_trying : try : match = next ( match_regexes ( regexes = self . shortform_regexes , text = self . source_text , span = ( span_start ,), )) span_start = match . span ()[ 1 ] try : yield Citation ( match = match , template = self . template , parent = self , ) except SyntaxError : # it's an invalid citation pass except StopIteration : keep_trying = False def get_idform_cite ( self , until_index : int = None ): try : match = next ( match_regexes ( regexes = self . idform_regexes , text = self . source_text , span = ( self . span [ 1 ], until_index ) )) return Citation ( match = match , template = self . template , parent = self ) except StopIteration : return None except SyntaxError : return None def get_next_child ( self , span : tuple = None ): try : match = next ( match_regexes ( regexes = self . shortform_regexes + self . idform_regexes , text = self . source_text , span = span if span else ( self . span [ 1 ], ), )) return Citation ( match = match , template = self . template , parent = self ) except StopIteration : return None def __str__ ( self ): return str ( self . text ) def __repr__ ( self ): return str ( self . text ) return ( f 'Citation(match= { self . match } , template= { repr ( self . template ) } ' + ( f ', parent= { repr ( self . parent ) } ' if self . parent else '' ) ) def __contains__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value *starts with* this one's. \"\"\" if ( other_cite . template . name != self . template . name or other_cite . tokens == self . tokens ): return False for key , value in self . tokens . items (): if value and other_cite . tokens . get ( key ) != value : if ( self . template . tokens [ key ] . severable and other_cite . tokens [ key ] and other_cite . tokens [ key ] . startswith ( value ) ): continue else : return False else : return True def __eq__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and they have the exact same token values. \"\"\" return ( other_cite . template . name == self . template . name and other_cite . tokens == self . tokens ) def __len__ ( self ): return len ( self . text ) __contains__ ( other_cite ) Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value starts with this one's. Source code in citeurl/citation.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def __contains__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value *starts with* this one's. \"\"\" if ( other_cite . template . name != self . template . name or other_cite . tokens == self . tokens ): return False for key , value in self . tokens . items (): if value and other_cite . tokens . get ( key ) != value : if ( self . template . tokens [ key ] . severable and other_cite . tokens [ key ] and other_cite . tokens [ key ] . startswith ( value ) ): continue else : return False else : return True __eq__ ( other_cite ) Returns True if both citations are from templates with the same name, and they have the exact same token values. Source code in citeurl/citation.py 229 230 231 232 233 234 235 236 237 def __eq__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and they have the exact same token values. \"\"\" return ( other_cite . template . name == self . template . name and other_cite . tokens == self . tokens ) Template A pattern to recognize a single kind of citation and extract information from it. Source code in citeurl/citator.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Template : \"\"\" A pattern to recognize a single kind of citation and extract information from it. \"\"\" def __init__ ( self , name : str , tokens : dict [ str , TokenType ] = {}, meta : dict [ str , str ] = {}, patterns : list [ str ] = [], broad_patterns : list [ str ] = [], shortform_patterns : list [ str ] = [], idform_patterns : list [ str ] = [], name_builder : StringBuilder = None , URL_builder : StringBuilder = None , inherit_template = None , ): \"\"\" Arguments: name: the name of this template tokens: The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. patterns: Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. broad_patterns: Same as `patterns`, except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. shortform_patterns: Same as `patterns`, but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding `raw_token` from the long-form citation. idform_patterns: Same as `shortform_patterns`, except that they will only be used to scan text until the next different citation occurs. URL_builder: `StringBuilder` to construct URLs for found citations name_builder: `StringBuilder` to construct canonical names of found citations meta: Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. inherit_template: another `Template` whose values this one should copy unless expressly overwritten. \"\"\" kwargs = locals () for attr , default in { 'name' : None , 'tokens' : {}, 'patterns' : [], 'broad_patterns' : [], 'shortform_patterns' : [], 'idform_patterns' : [], 'URL_builder' : None , 'name_builder' : None , 'meta' : {}, } . items (): if inherit_template and kwargs [ attr ] == default : value = inherit_template . __dict__ . get ( attr ) elif attr . endswith ( 'patterns' ) and not kwargs [ attr ]: value = [] else : value = kwargs [ attr ] self . __dict__ [ attr ] = value # update inherited StringBuilders with the correct metadata if inherit_template and self . meta : if self . URL_builder : self . URL_builder = copy ( self . URL_builder ) self . URL_builder . defaults = self . meta if self . name_builder : self . name_builder = copy ( self . name_builder ) self . name_builder . defaults = self . meta # use the template's metadata and tokens to make a dictionary # of replacements to insert into the regexes before compilation replacements = { k : str ( v ) for ( k , v ) in self . meta . items ()} replacements . update ({ k : fr '(?P< { k } > { v . regex } )(?!\\w)' for ( k , v ) in self . tokens . items () }) # compile the template's regexes and broad_regexes self . regexes = [] self . broad_regexes = [] for kind in [ 'regexes' , 'broad_regexes' ]: if kind == 'broad_regexes' : pattern_list = self . patterns + self . broad_patterns flags = re . I else : pattern_list = self . patterns flags = 0 for p in pattern_list : pattern = process_pattern ( p , replacements , add_word_breaks = True ) try : regex = re . compile ( pattern , flags ) self . __dict__ [ kind ] . append ( regex ) except re . error as e : i = 'broad ' if kind == 'broad_regexes' else '' raise re . error ( f ' { self } template \\' s { i } pattern \" { pattern } \" has ' f 'an error: { e } ' ) self . _processed_shortforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . shortform_patterns ] self . _processed_idforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . idform_patterns ] @classmethod def from_dict ( cls , name : str , values : dict , inheritables : dict = {}): \"\"\" Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. \"\"\" values = { k . replace ( ' ' , '_' ): v for k , v in values . items () } # when pattern is listed in singular form, # replace it with a one-item list items = values . items () values = {} for key , value in items : if key . endswith ( 'pattern' ): values [ key + 's' ] = [ value ] else : values [ key ] = value # unrelated: when a single pattern is split # into a list (likely to take advantage of # YAML anchors), join it into one string for k , v in values . items (): if not k . endswith ( 'patterns' ): continue elif v is None : values [ k ] = None continue for i , pattern in enumerate ( v ): if type ( pattern ) is list : values [ k ][ i ] = '' . join ( pattern ) inherit = values . get ( 'inherit' ) if inherit : values . pop ( 'inherit' ) try : values [ 'inherit_template' ] = inheritables . get ( inherit ) except KeyError : raise KeyError ( f 'Template \" { name } \" tried to inherit unknown ' + f 'template \" { inherit } \"' ) for key in [ 'name_builder' , 'URL_builder' ]: data = values . get ( key ) if data : data [ 'defaults' ] = values . get ( 'meta' ) or {} values [ key ] = StringBuilder . from_dict ( data ) values [ 'tokens' ] = { k : TokenType . from_dict ( k , v ) for k , v in values . get ( 'tokens' , {}) . items () } return cls ( name = name , ** values ) def to_dict ( self ) -> dict : \"save this Template to a dictionary of values\" output = {} if self . meta : output [ 'meta' ] = self . meta output [ 'tokens' ] = { k : v . to_dict () for k , v in self . tokens . items () } for key in [ 'patterns' , 'shortform_patterns' , 'idform_patterns' ]: value = self . __dict__ . get ( key ) if not value : continue elif len ( value ) > 1 : output [ key ] = value else : # de-pluralize lists that contain only one pattern output [ key [: - 1 ]] = value [ 0 ] for key in [ 'name_builder' , 'URL_builder' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] . to_dict () spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output def to_yaml ( self ) -> str : \"save this Template to a YAML string\" return safe_dump ( { self . name : self . to_dict ()}, sort_keys = False , allow_unicode = True , ) def cite ( self , text , broad : bool = True , span : tuple = ( 0 ,)) -> Citation : \"\"\" Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. \"\"\" regexes = self . broad_regexes if broad else self . regexes matches = match_regexes ( text , regexes , span = span ) for match in matches : try : return Citation ( match , self ) except SyntaxError : # invalid citation continue else : return None def list_longform_cites ( self , text , broad : bool = False , span : tuple = ( 0 ,)): \"\"\" Get a list of all long-form citations to this template found in the given text. \"\"\" cites = [] regexes = self . broad_regexes if broad else self . regexes for match in match_regexes ( text , regexes , span = span ): try : cites . append ( Citation ( match , self )) except SyntaxError : continue return cites def __str__ ( self ): return self . name def __repr__ ( self ): return ( f 'Template(name=\" { self . name } \"' + ( f ', tokens= { self . tokens } ' if self . tokens else '' ) + ( f ', meta= { self . meta } ' if self . meta else '' ) + ( f ', patterns= { self . patterns } ' if self . patterns else '' ) + ( f ', broad_patterns= { self . broad_patterns } ' if self . broad_patterns else '' ) + ( f ', shortform_patterns= { self . shortform_patterns } ' if self . shortform_patterns else '' ) + ( f ', idform_patterns= { self . idform_patterns } ' if self . idform_patterns else '' ) + ( f ', name_builder= { self . name_builder } ' if self . name_builder else '' ) + ( f ', URL_builder= { self . URL_builder } ' if self . URL_builder else '' ) + ')' ) def __contains__ ( self , citation : Citation ): return citation . template . name == self . name def __eq__ ( self , other_template ): return repr ( self ) == repr ( other_template ) __init__ ( name , tokens = {}, meta = {}, patterns = [], broad_patterns = [], shortform_patterns = [], idform_patterns = [], name_builder = None , URL_builder = None , inherit_template = None ) Parameters: Name Type Description Default name str the name of this template required tokens dict [ str , TokenType ] The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. {} patterns list [ str ] Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. [] broad_patterns list [ str ] Same as patterns , except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. [] shortform_patterns list [ str ] Same as patterns , but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding raw_token from the long-form citation. [] idform_patterns list [ str ] Same as shortform_patterns , except that they will only be used to scan text until the next different citation occurs. [] URL_builder StringBuilder StringBuilder to construct URLs for found citations None name_builder StringBuilder StringBuilder to construct canonical names of found citations None meta dict [ str , str ] Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. {} inherit_template another Template whose values this one should copy unless expressly overwritten. None Source code in citeurl/citator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def __init__ ( self , name : str , tokens : dict [ str , TokenType ] = {}, meta : dict [ str , str ] = {}, patterns : list [ str ] = [], broad_patterns : list [ str ] = [], shortform_patterns : list [ str ] = [], idform_patterns : list [ str ] = [], name_builder : StringBuilder = None , URL_builder : StringBuilder = None , inherit_template = None , ): \"\"\" Arguments: name: the name of this template tokens: The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. patterns: Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. broad_patterns: Same as `patterns`, except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. shortform_patterns: Same as `patterns`, but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding `raw_token` from the long-form citation. idform_patterns: Same as `shortform_patterns`, except that they will only be used to scan text until the next different citation occurs. URL_builder: `StringBuilder` to construct URLs for found citations name_builder: `StringBuilder` to construct canonical names of found citations meta: Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. inherit_template: another `Template` whose values this one should copy unless expressly overwritten. \"\"\" kwargs = locals () for attr , default in { 'name' : None , 'tokens' : {}, 'patterns' : [], 'broad_patterns' : [], 'shortform_patterns' : [], 'idform_patterns' : [], 'URL_builder' : None , 'name_builder' : None , 'meta' : {}, } . items (): if inherit_template and kwargs [ attr ] == default : value = inherit_template . __dict__ . get ( attr ) elif attr . endswith ( 'patterns' ) and not kwargs [ attr ]: value = [] else : value = kwargs [ attr ] self . __dict__ [ attr ] = value # update inherited StringBuilders with the correct metadata if inherit_template and self . meta : if self . URL_builder : self . URL_builder = copy ( self . URL_builder ) self . URL_builder . defaults = self . meta if self . name_builder : self . name_builder = copy ( self . name_builder ) self . name_builder . defaults = self . meta # use the template's metadata and tokens to make a dictionary # of replacements to insert into the regexes before compilation replacements = { k : str ( v ) for ( k , v ) in self . meta . items ()} replacements . update ({ k : fr '(?P< { k } > { v . regex } )(?!\\w)' for ( k , v ) in self . tokens . items () }) # compile the template's regexes and broad_regexes self . regexes = [] self . broad_regexes = [] for kind in [ 'regexes' , 'broad_regexes' ]: if kind == 'broad_regexes' : pattern_list = self . patterns + self . broad_patterns flags = re . I else : pattern_list = self . patterns flags = 0 for p in pattern_list : pattern = process_pattern ( p , replacements , add_word_breaks = True ) try : regex = re . compile ( pattern , flags ) self . __dict__ [ kind ] . append ( regex ) except re . error as e : i = 'broad ' if kind == 'broad_regexes' else '' raise re . error ( f ' { self } template \\' s { i } pattern \" { pattern } \" has ' f 'an error: { e } ' ) self . _processed_shortforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . shortform_patterns ] self . _processed_idforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . idform_patterns ] cite ( text , broad = True , span = ( 0 )) Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. Source code in citeurl/citator.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def cite ( self , text , broad : bool = True , span : tuple = ( 0 ,)) -> Citation : \"\"\" Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. \"\"\" regexes = self . broad_regexes if broad else self . regexes matches = match_regexes ( text , regexes , span = span ) for match in matches : try : return Citation ( match , self ) except SyntaxError : # invalid citation continue else : return None from_dict ( name , values , inheritables = {}) classmethod Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. Source code in citeurl/citator.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 @classmethod def from_dict ( cls , name : str , values : dict , inheritables : dict = {}): \"\"\" Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. \"\"\" values = { k . replace ( ' ' , '_' ): v for k , v in values . items () } # when pattern is listed in singular form, # replace it with a one-item list items = values . items () values = {} for key , value in items : if key . endswith ( 'pattern' ): values [ key + 's' ] = [ value ] else : values [ key ] = value # unrelated: when a single pattern is split # into a list (likely to take advantage of # YAML anchors), join it into one string for k , v in values . items (): if not k . endswith ( 'patterns' ): continue elif v is None : values [ k ] = None continue for i , pattern in enumerate ( v ): if type ( pattern ) is list : values [ k ][ i ] = '' . join ( pattern ) inherit = values . get ( 'inherit' ) if inherit : values . pop ( 'inherit' ) try : values [ 'inherit_template' ] = inheritables . get ( inherit ) except KeyError : raise KeyError ( f 'Template \" { name } \" tried to inherit unknown ' + f 'template \" { inherit } \"' ) for key in [ 'name_builder' , 'URL_builder' ]: data = values . get ( key ) if data : data [ 'defaults' ] = values . get ( 'meta' ) or {} values [ key ] = StringBuilder . from_dict ( data ) values [ 'tokens' ] = { k : TokenType . from_dict ( k , v ) for k , v in values . get ( 'tokens' , {}) . items () } return cls ( name = name , ** values ) list_longform_cites ( text , broad = False , span = ( 0 )) Get a list of all long-form citations to this template found in the given text. Source code in citeurl/citator.py 266 267 268 269 270 271 272 273 274 275 276 277 278 def list_longform_cites ( self , text , broad : bool = False , span : tuple = ( 0 ,)): \"\"\" Get a list of all long-form citations to this template found in the given text. \"\"\" cites = [] regexes = self . broad_regexes if broad else self . regexes for match in match_regexes ( text , regexes , span = span ): try : cites . append ( Citation ( match , self )) except SyntaxError : continue return cites to_dict () save this Template to a dictionary of values Source code in citeurl/citator.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def to_dict ( self ) -> dict : \"save this Template to a dictionary of values\" output = {} if self . meta : output [ 'meta' ] = self . meta output [ 'tokens' ] = { k : v . to_dict () for k , v in self . tokens . items () } for key in [ 'patterns' , 'shortform_patterns' , 'idform_patterns' ]: value = self . __dict__ . get ( key ) if not value : continue elif len ( value ) > 1 : output [ key ] = value else : # de-pluralize lists that contain only one pattern output [ key [: - 1 ]] = value [ 0 ] for key in [ 'name_builder' , 'URL_builder' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] . to_dict () spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output to_yaml () save this Template to a YAML string Source code in citeurl/citator.py 242 243 244 245 246 247 248 def to_yaml ( self ) -> str : \"save this Template to a YAML string\" return safe_dump ( { self . name : self . to_dict ()}, sort_keys = False , allow_unicode = True , ) TokenType These objects represent categories of tokens that might be found in a citation. Attributes: Name Type Description regex A regular expression that matches the actual text of the token as found in any document, like the \"42\" in \"42 USC \u00a7 1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\". This regex will automatically be enclosed in a named capture group and inserted into any of the template's match patterns wherever the token's name appears in curly braces. edits Steps to normalize the token as captured in the regex into a value that is consistent across multiple styles. default Set the token to this value if it is not found in the citation. severable If two citations only differ based on this token, and only because one of the tokens extends longer than the other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then severable means that the former citation is thought to encompass the latter. Source code in citeurl/tokens.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class TokenType : \"\"\" These objects represent categories of tokens that might be found in a citation. Attributes: regex: A regular expression that matches the actual text of the token as found in any document, like the \"42\" in \"42 USC \u00a7 1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\". This regex will automatically be enclosed in a named capture group and inserted into any of the template's match patterns wherever the token's name appears in curly braces. edits: Steps to normalize the token as captured in the regex into a value that is consistent across multiple styles. default: Set the token to this value if it is not found in the citation. severable: If two citations only differ based on this token, and only because one of the tokens extends longer than the other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then `severable` means that the former citation is thought to encompass the latter. \"\"\" def __init__ ( self , regex : str = r '\\d+' , edits : list [ TokenOperation ] = [], default : str = None , severable : bool = False , ): self . regex = regex self . edits = edits self . default = default self . severable = severable @classmethod def from_dict ( cls , name : str , data : dict ): \"load a TokenType from a dictionary of values\" return cls ( regex = data [ 'regex' ], default = data . get ( 'default' ), edits = [ TokenOperation . from_dict ( v ) for v in data . get ( 'edits' , []) ], severable = data . get ( 'severable' , False ) ) def to_dict ( self ) -> dict : \"save this TokenType to a dictionary for storage in YAML format\" output = { 'regex' : self . regex } if self . edits : output [ 'edits' ] = [ e . to_dict () for e in self . edits ] if self . default : output [ 'default' ] = self . default if self . severable : output [ 'severable' ] = True return output def normalize ( self , token : str ) -> str : if not token : return self . default for op in self . edits : token = op ( token ) return token def __str__ ( self ): return self . regex def __repr__ ( self ): norms = '[' + ', ' . join ([ repr ( n ) for n in self . edits or [] ]) + ']' return ( f \"TokenType(regex=' { self . regex } '\" + ( f \", default=' { self . default } '\" if self . default else '' ) + ( f ', edits= { norms } ' if self . edits else '' ) + ')' ) from_dict ( name , data ) classmethod load a TokenType from a dictionary of values Source code in citeurl/tokens.py 251 252 253 254 255 256 257 258 259 260 261 262 @classmethod def from_dict ( cls , name : str , data : dict ): \"load a TokenType from a dictionary of values\" return cls ( regex = data [ 'regex' ], default = data . get ( 'default' ), edits = [ TokenOperation . from_dict ( v ) for v in data . get ( 'edits' , []) ], severable = data . get ( 'severable' , False ) ) to_dict () save this TokenType to a dictionary for storage in YAML format Source code in citeurl/tokens.py 264 265 266 267 268 269 270 271 272 273 274 275 def to_dict ( self ) -> dict : \"save this TokenType to a dictionary for storage in YAML format\" output = { 'regex' : self . regex } if self . edits : output [ 'edits' ] = [ e . to_dict () for e in self . edits ] if self . default : output [ 'default' ] = self . default if self . severable : output [ 'severable' ] = True return output TokenOperation A function to perform a predefined string manipulation Source code in citeurl/tokens.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class TokenOperation : \"\"\"A function to perform a predefined string manipulation\"\"\" def __init__ ( self , action : str , data , mandatory : bool = True , token : str = None , output : str = None , ): \"\"\" Arguments: action: The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of `regex`: `replacement` pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. data: any data that a given action needs specified, as described above mandatory: whether a failed lookup or format action should invalidate the entire citation token: Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. output: If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. \"\"\" if action == 'sub' : self . func = lambda x : re . sub ( data [ 0 ], data [ 1 ], x ) elif action == 'lookup' : table = { re . compile ( k , flags = re . I ): v for k , v in data . items () } self . func = lambda x : self . _lookup ( x , table , mandatory ) elif action == 'case' : self . func = lambda x : self . _set_case ( x , data ) elif action == 'lpad' : self . func = lambda x : self . _left_pad ( x , data ) elif action == 'number_style' : action_options = [ 'cardinal' , 'ordinal' , 'roman' , 'digit' ] if data not in action_options : raise SyntaxError ( f ' { data } is not a valid number style. Valid options: ' f ' { action_options } ' ) self . func = lambda x : self . _number_style ( x , data , mandatory ) else : raise SyntaxError ( f ' { action } is not a defined token operation.' ) self . action = action self . data = data self . mandatory = mandatory self . token = token self . output = output @classmethod def from_dict ( cls , data : dict ): \"load a TokenOperation from a dictionary of values\" operations = [] for key in [ 'sub' , 'lookup' , 'case' , 'lpad' , 'number style' ]: value = data . get ( key ) if value : action = key . replace ( ' ' , '_' ) action_data = value break mandatory = data . get ( 'mandatory' , True ) token = data . get ( 'token' ) output = data . get ( 'output' ) return cls ( action , action_data , mandatory , token , output ) def to_dict ( self ) -> dict : \"save this TokenOperation to a dictionary of values\" output = {} for key in [ 'token' , 'output' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] output [ self . action ] = self . data if not self . mandatory : output [ 'mandatory' ] = False spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output def modify_dict ( self , tokens : dict ): \"\"\" apply this operation to a dictionary of tokens, editing them as appropriate \"\"\" if not tokens . get ( self . token ): return if self . output : tokens [ self . output ] = self . func ( tokens [ self . token ]) else : tokens [ self . token ] = self . func ( tokens [ self . token ]) def __call__ ( self , input_value ): return self . func ( input_value ) def __repr__ ( self ): return ( f 'TokenOperation(action=\" { self . action } \", data=\" { self . data } \"' + ( f ', mandatory=False' if not self . mandatory else '' ) + ( f ', token=\" { self . token } \"' if self . token else '' ) + ( f ', output=\" { self . output } \"' if self . output else '' ) + ')' ) # ================ Token Processing Operations =================== # def _lookup ( self , input : str , table : dict [ re . Pattern , str ], mandatory : bool = False , ) -> str : for pattern , repl in table . items (): if pattern . fullmatch ( input ): return repl if mandatory : regexes = [ r . pattern for r in table . keys ()] raise SyntaxError ( f ' { input } could not be found in { table } ' ) else : return input def _set_case ( self , input : str , case : str ) -> str : if case == 'upper' : return input . upper () elif case == 'lower' : return input . lower () elif case == 'title' : return input . title () def _left_pad ( self , input : str , min_length : int , pad_char = '0' ): diff = min_length - len ( input ) if diff > 0 : return ( pad_char * diff + input ) return input def _number_style ( self , input : str , form : str , throw_error : bool = False ): if input . isnumeric (): value = int ( input ) elif input [: - 2 ] . isnumeric (): # e.g. \"2nd\" value = int ( input [: - 2 ]) else : input = input . lower () for i , row in enumerate ( number_words ): if input in row : value = i + 1 break else : if throw_error : raise SyntaxError ( f ' { input } cannot be recognized as a number' ) if form == 'digit' : return str ( value ) forms = [ 'roman' , 'cardinal' , 'ordinal' ] output = number_words [ value - 1 ][ forms . index ( form )] if form == 'roman' : return output . upper () return output __init__ ( action , data , mandatory = True , token = None , output = None ) Parameters: Name Type Description Default action str The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of regex : replacement pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. required data any data that a given action needs specified, as described above required mandatory bool whether a failed lookup or format action should invalidate the entire citation True token str Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. None output str If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. None Source code in citeurl/tokens.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , action : str , data , mandatory : bool = True , token : str = None , output : str = None , ): \"\"\" Arguments: action: The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of `regex`: `replacement` pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. data: any data that a given action needs specified, as described above mandatory: whether a failed lookup or format action should invalidate the entire citation token: Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. output: If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. \"\"\" if action == 'sub' : self . func = lambda x : re . sub ( data [ 0 ], data [ 1 ], x ) elif action == 'lookup' : table = { re . compile ( k , flags = re . I ): v for k , v in data . items () } self . func = lambda x : self . _lookup ( x , table , mandatory ) elif action == 'case' : self . func = lambda x : self . _set_case ( x , data ) elif action == 'lpad' : self . func = lambda x : self . _left_pad ( x , data ) elif action == 'number_style' : action_options = [ 'cardinal' , 'ordinal' , 'roman' , 'digit' ] if data not in action_options : raise SyntaxError ( f ' { data } is not a valid number style. Valid options: ' f ' { action_options } ' ) self . func = lambda x : self . _number_style ( x , data , mandatory ) else : raise SyntaxError ( f ' { action } is not a defined token operation.' ) self . action = action self . data = data self . mandatory = mandatory self . token = token self . output = output from_dict ( data ) classmethod load a TokenOperation from a dictionary of values Source code in citeurl/tokens.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_dict ( cls , data : dict ): \"load a TokenOperation from a dictionary of values\" operations = [] for key in [ 'sub' , 'lookup' , 'case' , 'lpad' , 'number style' ]: value = data . get ( key ) if value : action = key . replace ( ' ' , '_' ) action_data = value break mandatory = data . get ( 'mandatory' , True ) token = data . get ( 'token' ) output = data . get ( 'output' ) return cls ( action , action_data , mandatory , token , output ) modify_dict ( tokens ) apply this operation to a dictionary of tokens, editing them as appropriate Source code in citeurl/tokens.py 138 139 140 141 142 143 144 145 146 147 148 def modify_dict ( self , tokens : dict ): \"\"\" apply this operation to a dictionary of tokens, editing them as appropriate \"\"\" if not tokens . get ( self . token ): return if self . output : tokens [ self . output ] = self . func ( tokens [ self . token ]) else : tokens [ self . token ] = self . func ( tokens [ self . token ]) to_dict () save this TokenOperation to a dictionary of values Source code in citeurl/tokens.py 124 125 126 127 128 129 130 131 132 133 134 135 136 def to_dict ( self ) -> dict : \"save this TokenOperation to a dictionary of values\" output = {} for key in [ 'token' , 'output' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] output [ self . action ] = self . data if not self . mandatory : output [ 'mandatory' ] = False spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output StringBuilder A function to take a dictionary of values and use it to construct a piece of text from them. This is used for citation templates' name builders and URL builders. Attributes: Name Type Description parts A list of strings that will be concatenated to create the string. Parts may contain bracketed references to citations' token values as well as templates' metadata. If a part references a token whose value is not set, the part will be omitted from the created string. edits A list of TokenOperations that will be performed on the provided tokens before the string is constructed. If the edits have output values, it is possible for them to define entirely new tokens for the sole purpose of building the string. defaults A dictionary of default token values to use when not overwritten by the citation. Generally these are provided by the template's meta attribute. Source code in citeurl/tokens.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 class StringBuilder : \"\"\" A function to take a dictionary of values and use it to construct a piece of text from them. This is used for citation templates' name builders and URL builders. Attributes: parts: A list of strings that will be concatenated to create the string. Parts may contain bracketed references to citations' token values as well as templates' metadata. If a part references a token whose value is not set, the part will be omitted from the created string. edits: A list of TokenOperations that will be performed on the provided tokens before the string is constructed. If the edits have `output` values, it is possible for them to define entirely new tokens for the sole purpose of building the string. defaults: A dictionary of default token values to use when not overwritten by the citation. Generally these are provided by the template's meta attribute. \"\"\" def __init__ ( self , parts : list [ str ], edits : list [ TokenOperation ] = [], defaults : dict [ str , str ] = {} ): self . parts = parts self . edits = edits self . defaults = defaults @classmethod def from_dict ( cls , data : dict ): \"load StringBuilder from dictionary of values\" edits = [ TokenOperation . from_dict ( o ) for o in data . get ( 'edits' , []) ] parts = data [ 'parts' ] defaults = data . get ( 'defaults' ) or {} return cls ( parts , edits , defaults ) def to_dict ( self ) -> dict : \"save StringBuilder to a dictionary of values\" output = { 'parts' : self . parts } if self . edits : output [ 'edits' ] = [ op . to_dict () for op in self . edits ] return output def __call__ ( self , tokens : dict [ str , str ], ) -> str : if self . defaults : defaults = copy ( self . defaults ) defaults . update ( tokens ) tokens = defaults else : tokens = copy ( tokens ) tokens = { k : v for k , v in tokens . items () if v } for op in self . edits : try : op . modify_dict ( tokens ) except SyntaxError : # token operation failed; just skip it pass string_parts = [] for part in self . parts : try : string_parts . append ( part . format ( ** tokens )) except KeyError : # skip parts that reference a nonexistent token pass # if a mandatory TokenOperation failed, don't return a URL except SyntaxError : string_parts = [] break t = copy ( tokens ) return '' . join ( string_parts ) or None def __repr__ ( self ): return ( f 'StringBuilder(parts= { self . parts } ' + ( f ', edits= { self . edits } ' if self . edits else '' ) + ( f ', defaults= { self . defaults } ' if self . defaults else '' ) + ')' ) from_dict ( data ) classmethod load StringBuilder from dictionary of values Source code in citeurl/tokens.py 330 331 332 333 334 335 336 337 338 339 @classmethod def from_dict ( cls , data : dict ): \"load StringBuilder from dictionary of values\" edits = [ TokenOperation . from_dict ( o ) for o in data . get ( 'edits' , []) ] parts = data [ 'parts' ] defaults = data . get ( 'defaults' ) or {} return cls ( parts , edits , defaults ) to_dict () save StringBuilder to a dictionary of values Source code in citeurl/tokens.py 341 342 343 344 345 346 def to_dict ( self ) -> dict : \"save StringBuilder to a dictionary of values\" output = { 'parts' : self . parts } if self . edits : output [ 'edits' ] = [ op . to_dict () for op in self . edits ] return output insert_links() Convenience function to hyperlink all citations in a text. For more info, see Citator.insert_links(). Source code in citeurl/citator.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def insert_links ( text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , citator : Citator = None , ): \"\"\" Convenience function to hyperlink all citations in a text. For more info, see Citator.insert_links(). \"\"\" citator = citator or _get_default_citator () return citator . insert_links ( text = text , attrs = attrs , add_title = add_title , redundant_links = redundant_links , id_breaks = id_breaks , ignore_markup = ignore_markup , ) cite() Convenience function to find a single citation in text, or None. See Citator.cite() for more info. Source code in citeurl/citator.py 598 599 600 601 602 603 604 605 606 607 608 def cite ( text : str , broad : bool = True , citator : Citator = None , ) -> Citation : \"\"\" Convenience function to find a single citation in text, or None. See Citator.cite() for more info. \"\"\" citator = citator or _get_default_citator () return citator . cite ( text , broad = broad ) list_cites() Convenience function to list all citations in a text. For more info, see Citator.list_cites(). Source code in citeurl/citator.py 610 611 612 613 614 615 616 def list_cites ( text , citator : Citator = None , id_breaks = None ): \"\"\" Convenience function to list all citations in a text. For more info, see Citator.list_cites(). \"\"\" citator = citator or _get_default_citator () return citator . list_cites ( text , id_breaks = id_breaks )","title":"Library Reference"},{"location":"library/#library-reference","text":"This page documents how to include CiteURL in your Python programming projects. The first step is to instantiate a Citator , which by default contains all of CiteURL's built-in Templates : from citeurl import Citator citator = Citator () After that, you can feed it text to return a list of Citations it finds: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator . list_cites ( text ) Once you have a list of citations, you can get information about each one: print ( citations [ 0 ] . text ) # 42 USC \u00a7 1988(b) print ( citations [ 0 ] . tokens ) # {'Title': '42', 'Section': '1988', 'subsection': '(b)'} print ( citations [ 0 ] . URL ) # https://www.law.cornell.edu/uscode/text/42/1988#b You can also compare citations to one another, to determine whether they reference the same material or a subsection thereof: art_I = citator . cite ( 'U.S. Const. Art. I' ) also_art_I = citator . cite ( 'Article I of the U.S. Constitution' ) art_I_sec_3 = citator . cite ( 'U.S. Const. Art. I, \u00a7 3' ) assert art_I == also_art_I assert art_I_sec_3 in art_I Finally, if you don't want to bother with all the details, you can also just use insert_links() to turn all the citations in a text into hyperlinks: from citeurl import insert_links text = \"42 USC \u00a7 1988. <i>Id.</i> at (b).\" output = insert_links ( text ) assert output == '<a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988\" title=\"42 U.S.C. \u00a7 1988\">42 USC \u00a7 1988</a>. <a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988#b\" title=\"42 U.S.C. \u00a7 1988(b)\"><i>Id.</i> at (b)</a>.'","title":"Library Reference"},{"location":"library/#citator","text":"A collection of citation templates, and the tools to match text against them en masse. Attributes: Name Type Description templates a dictionary of citation templates that this citator will try to match against Source code in citeurl/citator.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 class Citator : \"\"\" A collection of citation templates, and the tools to match text against them en masse. Attributes: templates: a dictionary of citation templates that this citator will try to match against \"\"\" def __init__ ( self , defaults = [ 'caselaw' , 'general federal law' , 'specific federal laws' , 'state law' , 'secondary sources' , ], yaml_paths : list [ str ] = [], templates : dict [ str , Template ] = {}, ): \"\"\" Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Arguments: defaults: names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. yaml_paths: paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. templates: optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. \"\"\" self . templates = {} yamls_path = Path ( __file__ ) . parent . absolute () / 'templates' for name in defaults or []: yaml_file = yamls_path / f ' { name } .yaml' self . load_yaml ( yaml_file . read_text ()) for path in yaml_paths : self . load_yaml ( Path ( path ) . read_text ()) self . templates . update ( templates ) @classmethod def from_yaml ( cls , yaml : str ): \"\"\" Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. \"\"\" citator = cls ( defaults = None ) citator . load_yaml ( yaml ) return citator def to_yaml ( self ): \"Save this citator to a YAML string to load later\" yamls = [ t . to_yaml () for t in self . templates . values ()] return ' \\n\\n ' . join ( yamls ) def load_yaml ( self , yaml : str ): \"\"\" Load templates from the given YAML, overwriting any existing templates with the same name. \"\"\" for name , data in safe_load ( yaml ) . items (): self . templates [ name ] = Template . from_dict ( name , data , inheritables = self . templates ) def cite ( self , text : str , broad : bool = True ) -> Citation : \"\"\" Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. \"\"\" for template in self . templates . values (): cite = template . cite ( text , broad = broad ) if cite : return cite else : return None def list_cites ( self , text : str , id_breaks : re . Pattern = None , ) -> list [ Citation ]: \"\"\" Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. \"\"\" # first get a list of all long and shortform (not id.) citations longforms = [] for template in self . templates . values (): longforms += template . list_longform_cites ( text ) shortforms = [] for citation in longforms : shortforms += citation . get_shortform_cites () citations = longforms + shortforms _sort_and_remove_overlaps ( citations ) # Figure out where to interrupt chains of idform citations, # i.e. anywhere a longform or shortform citation starts, plus # the start of any substring that matches the id_breaks pattern breakpoints = [ c . span [ 0 ] for c in citations ] if id_breaks : breakpoints += [ match . span ()[ 0 ] for match in id_breaks . finditer ( text ) ] breakpoints = sorted ( set ( breakpoints )) # for each cite, look for idform citations until the next cite # or until the next breakpoint idforms = [] for cite in citations : # find the next relevant breakpoint, and delete any # breakpoints that are already behind the current citation for i , breakpoint in enumerate ( breakpoints ): if breakpoint >= cite . span [ 1 ]: breakpoints = breakpoints [ i :] break try : breakpoint = breakpoints [ 0 ] except IndexError : breakpoint = None # find the first idform reference to the citation, then the # first idform reference to that idform, and so on, until # the breakpoint idform = cite . get_idform_cite ( until_index = breakpoint ) while idform : idforms . append ( idform ) idform = idform . get_idform_cite ( until_index = breakpoint ) citations += idforms _sort_and_remove_overlaps ( citations ) return citations def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , ) -> str : \"\"\" Scan a text for citations, and return a text with each citation converted to a hyperlink. Arguments: text: the string to scan for citations. attrs: various HTML link attributes to give to each link add_title: whether to use citation.name for link titles URL_optional: whether to insert a hyperlink even when the citation does not have an associated URL redundant_links: whether to insert a hyperlink if it would point to the same URL as the previous link id_breaks: wherever this regex appears, interrupt chains of \"Id.\"-type citations. ignore_markup: whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \"<i>Id.</i> at 32\" Returns: text, with an HTML `a` element for each citation. \"\"\" # pull out all the inline HTML tags, e.g. <b>, # so they don't interfere with citation matching if ignore_markup : text , stored_tags = _strip_inline_tags ( text ) cite_offsets = [] running_offset = 0 last_URL = None for cite in self . list_cites ( text , id_breaks = id_breaks ): attrs [ 'href' ] = cite . URL if not cite . URL and not URL_optional : continue if not redundant_links and cite . URL == last_URL : continue if add_title : attrs [ 'title' ] = cite . name attr_str = '' . join ([ f ' { k } =\" { v } \"' for k , v in attrs . items () if v ]) link = f '<a { attr_str } > { cite . text } </a>' cite_offset = len ( link ) - len ( cite . text ) cite_offsets . append (( cite . span [ 0 ], # beginning of citation cite_offset , cite . text , )) span = ( cite . span [ 0 ] + running_offset , cite . span [ 1 ] + running_offset ) text = text [: span [ 0 ]] + link + text [ span [ 1 ]:] running_offset += cite_offset last_URL = cite . URL if ignore_markup : running_offset = 0 for tag in stored_tags : temp_offset = 0 while len ( cite_offsets ) > 0 : # only offset by a cite if the tag # is after the cite start if tag [ 1 ] >= cite_offsets [ 0 ][ 0 ]: offset = cite_offsets [ 0 ] # check if the tag is after the cite end tag_start = tag [ 1 ] cite_end = offset [ 0 ] + len ( offset [ 2 ]) if tag_start >= cite_end : running_offset += offset [ 1 ] cite_offsets . pop ( 0 ) # otherwise, don't offset by the length of # the cite's closing </a> tag (length of 4) else : temp_offset = offset [ 1 ] - 4 break else : break tag_pos = tag [ 1 ] + running_offset + temp_offset text = text [: tag_pos ] + tag [ 0 ] + text [ tag_pos :] running_offset += tag [ 2 ] return text def __iter__ ( self ): return self . templates . values () . __iter__ () def __getitem__ ( self , key ): return self . templates [ key ] def __setitem__ ( self , key , value ): self . templates [ key ] = value def __eq__ ( self , other_citator ): return self . templates == other_citator . templates","title":"Citator"},{"location":"library/#citeurl.citator.Citator.__init__","text":"Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Parameters: Name Type Description Default defaults names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. ['caselaw', 'general federal law', 'specific federal laws', 'state law', 'secondary sources'] yaml_paths list [ str ] paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. [] templates dict [ str , Template ] optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. {} Source code in citeurl/citator.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , defaults = [ 'caselaw' , 'general federal law' , 'specific federal laws' , 'state law' , 'secondary sources' , ], yaml_paths : list [ str ] = [], templates : dict [ str , Template ] = {}, ): \"\"\" Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime. Arguments: defaults: names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic. yaml_paths: paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. templates: optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths. \"\"\" self . templates = {} yamls_path = Path ( __file__ ) . parent . absolute () / 'templates' for name in defaults or []: yaml_file = yamls_path / f ' { name } .yaml' self . load_yaml ( yaml_file . read_text ()) for path in yaml_paths : self . load_yaml ( Path ( path ) . read_text ()) self . templates . update ( templates )","title":"__init__()"},{"location":"library/#citeurl.citator.Citator.cite","text":"Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. Source code in citeurl/citator.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def cite ( self , text : str , broad : bool = True ) -> Citation : \"\"\" Check the given text against each of the citator's templates and return the first citation detected, or None. If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes. \"\"\" for template in self . templates . values (): cite = template . cite ( text , broad = broad ) if cite : return cite else : return None","title":"cite()"},{"location":"library/#citeurl.citator.Citator.from_yaml","text":"Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. Source code in citeurl/citator.py 370 371 372 373 374 375 376 377 378 @classmethod def from_yaml ( cls , yaml : str ): \"\"\" Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string. \"\"\" citator = cls ( defaults = None ) citator . load_yaml ( yaml ) return citator","title":"from_yaml()"},{"location":"library/#citeurl.citator.Citator.insert_links","text":"Scan a text for citations, and return a text with each citation converted to a hyperlink. Parameters: Name Type Description Default text str the string to scan for citations. required attrs dict various HTML link attributes to give to each link {'class': 'citation'} add_title bool whether to use citation.name for link titles True URL_optional bool whether to insert a hyperlink even when the citation does not have an associated URL False redundant_links bool whether to insert a hyperlink if it would point to the same URL as the previous link True id_breaks re . Pattern wherever this regex appears, interrupt chains of \"Id.\"-type citations. None ignore_markup bool whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \" Id. at 32\" True Returns: Type Description str text, with an HTML a element for each citation. Source code in citeurl/citator.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , ) -> str : \"\"\" Scan a text for citations, and return a text with each citation converted to a hyperlink. Arguments: text: the string to scan for citations. attrs: various HTML link attributes to give to each link add_title: whether to use citation.name for link titles URL_optional: whether to insert a hyperlink even when the citation does not have an associated URL redundant_links: whether to insert a hyperlink if it would point to the same URL as the previous link id_breaks: wherever this regex appears, interrupt chains of \"Id.\"-type citations. ignore_markup: whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \"<i>Id.</i> at 32\" Returns: text, with an HTML `a` element for each citation. \"\"\" # pull out all the inline HTML tags, e.g. <b>, # so they don't interfere with citation matching if ignore_markup : text , stored_tags = _strip_inline_tags ( text ) cite_offsets = [] running_offset = 0 last_URL = None for cite in self . list_cites ( text , id_breaks = id_breaks ): attrs [ 'href' ] = cite . URL if not cite . URL and not URL_optional : continue if not redundant_links and cite . URL == last_URL : continue if add_title : attrs [ 'title' ] = cite . name attr_str = '' . join ([ f ' { k } =\" { v } \"' for k , v in attrs . items () if v ]) link = f '<a { attr_str } > { cite . text } </a>' cite_offset = len ( link ) - len ( cite . text ) cite_offsets . append (( cite . span [ 0 ], # beginning of citation cite_offset , cite . text , )) span = ( cite . span [ 0 ] + running_offset , cite . span [ 1 ] + running_offset ) text = text [: span [ 0 ]] + link + text [ span [ 1 ]:] running_offset += cite_offset last_URL = cite . URL if ignore_markup : running_offset = 0 for tag in stored_tags : temp_offset = 0 while len ( cite_offsets ) > 0 : # only offset by a cite if the tag # is after the cite start if tag [ 1 ] >= cite_offsets [ 0 ][ 0 ]: offset = cite_offsets [ 0 ] # check if the tag is after the cite end tag_start = tag [ 1 ] cite_end = offset [ 0 ] + len ( offset [ 2 ]) if tag_start >= cite_end : running_offset += offset [ 1 ] cite_offsets . pop ( 0 ) # otherwise, don't offset by the length of # the cite's closing </a> tag (length of 4) else : temp_offset = offset [ 1 ] - 4 break else : break tag_pos = tag [ 1 ] + running_offset + temp_offset text = text [: tag_pos ] + tag [ 0 ] + text [ tag_pos :] running_offset += tag [ 2 ] return text","title":"insert_links()"},{"location":"library/#citeurl.citator.Citator.list_cites","text":"Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. Source code in citeurl/citator.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def list_cites ( self , text : str , id_breaks : re . Pattern = None , ) -> list [ Citation ]: \"\"\" Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about. \"\"\" # first get a list of all long and shortform (not id.) citations longforms = [] for template in self . templates . values (): longforms += template . list_longform_cites ( text ) shortforms = [] for citation in longforms : shortforms += citation . get_shortform_cites () citations = longforms + shortforms _sort_and_remove_overlaps ( citations ) # Figure out where to interrupt chains of idform citations, # i.e. anywhere a longform or shortform citation starts, plus # the start of any substring that matches the id_breaks pattern breakpoints = [ c . span [ 0 ] for c in citations ] if id_breaks : breakpoints += [ match . span ()[ 0 ] for match in id_breaks . finditer ( text ) ] breakpoints = sorted ( set ( breakpoints )) # for each cite, look for idform citations until the next cite # or until the next breakpoint idforms = [] for cite in citations : # find the next relevant breakpoint, and delete any # breakpoints that are already behind the current citation for i , breakpoint in enumerate ( breakpoints ): if breakpoint >= cite . span [ 1 ]: breakpoints = breakpoints [ i :] break try : breakpoint = breakpoints [ 0 ] except IndexError : breakpoint = None # find the first idform reference to the citation, then the # first idform reference to that idform, and so on, until # the breakpoint idform = cite . get_idform_cite ( until_index = breakpoint ) while idform : idforms . append ( idform ) idform = idform . get_idform_cite ( until_index = breakpoint ) citations += idforms _sort_and_remove_overlaps ( citations ) return citations","title":"list_cites()"},{"location":"library/#citeurl.citator.Citator.load_yaml","text":"Load templates from the given YAML, overwriting any existing templates with the same name. Source code in citeurl/citator.py 385 386 387 388 389 390 391 392 393 def load_yaml ( self , yaml : str ): \"\"\" Load templates from the given YAML, overwriting any existing templates with the same name. \"\"\" for name , data in safe_load ( yaml ) . items (): self . templates [ name ] = Template . from_dict ( name , data , inheritables = self . templates )","title":"load_yaml()"},{"location":"library/#citeurl.citator.Citator.to_yaml","text":"Save this citator to a YAML string to load later Source code in citeurl/citator.py 380 381 382 383 def to_yaml ( self ): \"Save this citator to a YAML string to load later\" yamls = [ t . to_yaml () for t in self . templates . values ()] return ' \\n\\n ' . join ( yamls )","title":"to_yaml()"},{"location":"library/#citation","text":"A legal reference found in text. Attributes: Name Type Description tokens dictionary of the values that define this citation, such as its volume and page number, or its title, section, and subsection, etc URL str the location, if any, where this citation can be found online, defined by the template's URL_builder name str a uniform, human-readable representation of this citation, written by the template's name_builder text the actual text of this citation as found in the source text source_text the full text that this citation was found in template the template whose regexes found this citation or its parent parent the earlier citation, if any, that this citation is a shortform or idform child of raw_tokens dictionary of tokens as captured in the original regex match, before normalization. Note that for child citations, raw_tokens will include any raw_tokens inferred from the parent citation. idform_regexes list of regex pattern objects to find child citations later in the text, valid until the next different citation appears. shortform_regexes list of regex pattern objects to find child citations anywhere in the subsequent text Source code in citeurl/citation.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class Citation : \"\"\" A legal reference found in text. Attributes: tokens: dictionary of the values that define this citation, such as its volume and page number, or its title, section, and subsection, etc URL: the location, if any, where this citation can be found online, defined by the template's URL_builder name: a uniform, human-readable representation of this citation, written by the template's name_builder text: the actual text of this citation as found in the source text source_text: the full text that this citation was found in template: the template whose regexes found this citation or its parent parent: the earlier citation, if any, that this citation is a shortform or idform child of raw_tokens: dictionary of tokens as captured in the original regex match, before normalization. Note that for child citations, raw_tokens will include any raw_tokens inferred from the parent citation. idform_regexes: list of regex pattern objects to find child citations later in the text, valid until the next different citation appears. shortform_regexes: list of regex pattern objects to find child citations anywhere in the subsequent text \"\"\" def __init__ ( self , match : re . match , template , parent = None , ): self . match = match self . text = match . group ( 0 ) self . source_text = match . string self . span = match . span () self . template = template self . parent = parent self . tokens = {} self . raw_tokens = match . groupdict () # copy raw_tokens (in order) from the parent citation, but # stop at the first one that the child citation overwrites if parent : merged_tokens = {} for k in template . tokens . keys (): if self . raw_tokens . get ( k ): merged_tokens . update ( self . raw_tokens ) break else : merged_tokens [ k ] = parent . raw_tokens . get ( k ) self . raw_tokens = merged_tokens # normalize raw_tokens to get consistent token values across # differently-formatted citations to the same source. # This will raise a SyntaxError if a mandatory edit fails for name , ttype in template . tokens . items (): value = self . raw_tokens . get ( name ) self . tokens [ name ] = ttype . normalize ( value ) # Finally, compile the citation's idform and shortform regexes. # To avoid unneccessary work, first try to copy regexes from the # parent citation if applicable. if parent and parent . raw_tokens == self . raw_tokens : # then we can safely copy the parent's regexes to the child self . idform_regexes = parent . idform_regexes self . shortform_regexes = parent . shortform_regexes return # otherwise we'll need to compile new shortform regexes, # but we can still copy some of them from the parent kwargs = { 'replacements' : self . raw_tokens , 'token_prefix' : 'same' , } if parent : # we can copy regexes, but only if they do not reference a # specific value from the citation, e.g. {same volume}. self . shortform_regexes = [ ( re . compile ( process_pattern ( pattern , ** kwargs )) if '{same ' in pattern else parent . shortform_regexes [ i ] ) for i , pattern in enumerate ( template . _processed_shortforms ) ] self . idform_regexes = [ ( re . compile ( process_pattern ( pattern , ** kwargs )) if '{same ' in pattern else parent . idform_regexes [ i ] ) for i , pattern in enumerate ( template . _processed_idforms ) ] else : # compile all-new idforms and shortforms self . shortform_regexes = [ re . compile ( process_pattern ( pattern , ** kwargs )) for pattern in self . template . _processed_shortforms ] self . idform_regexes = [ re . compile ( process_pattern ( pattern , ** kwargs )) for pattern in self . template . _processed_idforms ] self . idform_regexes . append ( BASIC_ID_REGEX ) @property def URL ( self ) -> str : if self . template . URL_builder : url = self . template . URL_builder ( self . tokens ) if url : url = url . replace ( ' ' , '%20' ) else : url = None return url @property def name ( self ) -> str : if self . template . name_builder : return self . template . name_builder ( self . tokens ) else : return None def get_shortform_cites ( self ) -> Iterable : keep_trying = True span_start = self . span [ 1 ] while keep_trying : try : match = next ( match_regexes ( regexes = self . shortform_regexes , text = self . source_text , span = ( span_start ,), )) span_start = match . span ()[ 1 ] try : yield Citation ( match = match , template = self . template , parent = self , ) except SyntaxError : # it's an invalid citation pass except StopIteration : keep_trying = False def get_idform_cite ( self , until_index : int = None ): try : match = next ( match_regexes ( regexes = self . idform_regexes , text = self . source_text , span = ( self . span [ 1 ], until_index ) )) return Citation ( match = match , template = self . template , parent = self ) except StopIteration : return None except SyntaxError : return None def get_next_child ( self , span : tuple = None ): try : match = next ( match_regexes ( regexes = self . shortform_regexes + self . idform_regexes , text = self . source_text , span = span if span else ( self . span [ 1 ], ), )) return Citation ( match = match , template = self . template , parent = self ) except StopIteration : return None def __str__ ( self ): return str ( self . text ) def __repr__ ( self ): return str ( self . text ) return ( f 'Citation(match= { self . match } , template= { repr ( self . template ) } ' + ( f ', parent= { repr ( self . parent ) } ' if self . parent else '' ) ) def __contains__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value *starts with* this one's. \"\"\" if ( other_cite . template . name != self . template . name or other_cite . tokens == self . tokens ): return False for key , value in self . tokens . items (): if value and other_cite . tokens . get ( key ) != value : if ( self . template . tokens [ key ] . severable and other_cite . tokens [ key ] and other_cite . tokens [ key ] . startswith ( value ) ): continue else : return False else : return True def __eq__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and they have the exact same token values. \"\"\" return ( other_cite . template . name == self . template . name and other_cite . tokens == self . tokens ) def __len__ ( self ): return len ( self . text )","title":"Citation"},{"location":"library/#citeurl.citation.Citation.__contains__","text":"Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value starts with this one's. Source code in citeurl/citation.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def __contains__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value *starts with* this one's. \"\"\" if ( other_cite . template . name != self . template . name or other_cite . tokens == self . tokens ): return False for key , value in self . tokens . items (): if value and other_cite . tokens . get ( key ) != value : if ( self . template . tokens [ key ] . severable and other_cite . tokens [ key ] and other_cite . tokens [ key ] . startswith ( value ) ): continue else : return False else : return True","title":"__contains__()"},{"location":"library/#citeurl.citation.Citation.__eq__","text":"Returns True if both citations are from templates with the same name, and they have the exact same token values. Source code in citeurl/citation.py 229 230 231 232 233 234 235 236 237 def __eq__ ( self , other_cite ): \"\"\" Returns True if both citations are from templates with the same name, and they have the exact same token values. \"\"\" return ( other_cite . template . name == self . template . name and other_cite . tokens == self . tokens )","title":"__eq__()"},{"location":"library/#template","text":"A pattern to recognize a single kind of citation and extract information from it. Source code in citeurl/citator.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Template : \"\"\" A pattern to recognize a single kind of citation and extract information from it. \"\"\" def __init__ ( self , name : str , tokens : dict [ str , TokenType ] = {}, meta : dict [ str , str ] = {}, patterns : list [ str ] = [], broad_patterns : list [ str ] = [], shortform_patterns : list [ str ] = [], idform_patterns : list [ str ] = [], name_builder : StringBuilder = None , URL_builder : StringBuilder = None , inherit_template = None , ): \"\"\" Arguments: name: the name of this template tokens: The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. patterns: Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. broad_patterns: Same as `patterns`, except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. shortform_patterns: Same as `patterns`, but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding `raw_token` from the long-form citation. idform_patterns: Same as `shortform_patterns`, except that they will only be used to scan text until the next different citation occurs. URL_builder: `StringBuilder` to construct URLs for found citations name_builder: `StringBuilder` to construct canonical names of found citations meta: Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. inherit_template: another `Template` whose values this one should copy unless expressly overwritten. \"\"\" kwargs = locals () for attr , default in { 'name' : None , 'tokens' : {}, 'patterns' : [], 'broad_patterns' : [], 'shortform_patterns' : [], 'idform_patterns' : [], 'URL_builder' : None , 'name_builder' : None , 'meta' : {}, } . items (): if inherit_template and kwargs [ attr ] == default : value = inherit_template . __dict__ . get ( attr ) elif attr . endswith ( 'patterns' ) and not kwargs [ attr ]: value = [] else : value = kwargs [ attr ] self . __dict__ [ attr ] = value # update inherited StringBuilders with the correct metadata if inherit_template and self . meta : if self . URL_builder : self . URL_builder = copy ( self . URL_builder ) self . URL_builder . defaults = self . meta if self . name_builder : self . name_builder = copy ( self . name_builder ) self . name_builder . defaults = self . meta # use the template's metadata and tokens to make a dictionary # of replacements to insert into the regexes before compilation replacements = { k : str ( v ) for ( k , v ) in self . meta . items ()} replacements . update ({ k : fr '(?P< { k } > { v . regex } )(?!\\w)' for ( k , v ) in self . tokens . items () }) # compile the template's regexes and broad_regexes self . regexes = [] self . broad_regexes = [] for kind in [ 'regexes' , 'broad_regexes' ]: if kind == 'broad_regexes' : pattern_list = self . patterns + self . broad_patterns flags = re . I else : pattern_list = self . patterns flags = 0 for p in pattern_list : pattern = process_pattern ( p , replacements , add_word_breaks = True ) try : regex = re . compile ( pattern , flags ) self . __dict__ [ kind ] . append ( regex ) except re . error as e : i = 'broad ' if kind == 'broad_regexes' else '' raise re . error ( f ' { self } template \\' s { i } pattern \" { pattern } \" has ' f 'an error: { e } ' ) self . _processed_shortforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . shortform_patterns ] self . _processed_idforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . idform_patterns ] @classmethod def from_dict ( cls , name : str , values : dict , inheritables : dict = {}): \"\"\" Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. \"\"\" values = { k . replace ( ' ' , '_' ): v for k , v in values . items () } # when pattern is listed in singular form, # replace it with a one-item list items = values . items () values = {} for key , value in items : if key . endswith ( 'pattern' ): values [ key + 's' ] = [ value ] else : values [ key ] = value # unrelated: when a single pattern is split # into a list (likely to take advantage of # YAML anchors), join it into one string for k , v in values . items (): if not k . endswith ( 'patterns' ): continue elif v is None : values [ k ] = None continue for i , pattern in enumerate ( v ): if type ( pattern ) is list : values [ k ][ i ] = '' . join ( pattern ) inherit = values . get ( 'inherit' ) if inherit : values . pop ( 'inherit' ) try : values [ 'inherit_template' ] = inheritables . get ( inherit ) except KeyError : raise KeyError ( f 'Template \" { name } \" tried to inherit unknown ' + f 'template \" { inherit } \"' ) for key in [ 'name_builder' , 'URL_builder' ]: data = values . get ( key ) if data : data [ 'defaults' ] = values . get ( 'meta' ) or {} values [ key ] = StringBuilder . from_dict ( data ) values [ 'tokens' ] = { k : TokenType . from_dict ( k , v ) for k , v in values . get ( 'tokens' , {}) . items () } return cls ( name = name , ** values ) def to_dict ( self ) -> dict : \"save this Template to a dictionary of values\" output = {} if self . meta : output [ 'meta' ] = self . meta output [ 'tokens' ] = { k : v . to_dict () for k , v in self . tokens . items () } for key in [ 'patterns' , 'shortform_patterns' , 'idform_patterns' ]: value = self . __dict__ . get ( key ) if not value : continue elif len ( value ) > 1 : output [ key ] = value else : # de-pluralize lists that contain only one pattern output [ key [: - 1 ]] = value [ 0 ] for key in [ 'name_builder' , 'URL_builder' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] . to_dict () spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output def to_yaml ( self ) -> str : \"save this Template to a YAML string\" return safe_dump ( { self . name : self . to_dict ()}, sort_keys = False , allow_unicode = True , ) def cite ( self , text , broad : bool = True , span : tuple = ( 0 ,)) -> Citation : \"\"\" Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. \"\"\" regexes = self . broad_regexes if broad else self . regexes matches = match_regexes ( text , regexes , span = span ) for match in matches : try : return Citation ( match , self ) except SyntaxError : # invalid citation continue else : return None def list_longform_cites ( self , text , broad : bool = False , span : tuple = ( 0 ,)): \"\"\" Get a list of all long-form citations to this template found in the given text. \"\"\" cites = [] regexes = self . broad_regexes if broad else self . regexes for match in match_regexes ( text , regexes , span = span ): try : cites . append ( Citation ( match , self )) except SyntaxError : continue return cites def __str__ ( self ): return self . name def __repr__ ( self ): return ( f 'Template(name=\" { self . name } \"' + ( f ', tokens= { self . tokens } ' if self . tokens else '' ) + ( f ', meta= { self . meta } ' if self . meta else '' ) + ( f ', patterns= { self . patterns } ' if self . patterns else '' ) + ( f ', broad_patterns= { self . broad_patterns } ' if self . broad_patterns else '' ) + ( f ', shortform_patterns= { self . shortform_patterns } ' if self . shortform_patterns else '' ) + ( f ', idform_patterns= { self . idform_patterns } ' if self . idform_patterns else '' ) + ( f ', name_builder= { self . name_builder } ' if self . name_builder else '' ) + ( f ', URL_builder= { self . URL_builder } ' if self . URL_builder else '' ) + ')' ) def __contains__ ( self , citation : Citation ): return citation . template . name == self . name def __eq__ ( self , other_template ): return repr ( self ) == repr ( other_template )","title":"Template"},{"location":"library/#citeurl.citator.Template.__init__","text":"Parameters: Name Type Description Default name str the name of this template required tokens dict [ str , TokenType ] The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. {} patterns list [ str ] Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. [] broad_patterns list [ str ] Same as patterns , except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. [] shortform_patterns list [ str ] Same as patterns , but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding raw_token from the long-form citation. [] idform_patterns list [ str ] Same as shortform_patterns , except that they will only be used to scan text until the next different citation occurs. [] URL_builder StringBuilder StringBuilder to construct URLs for found citations None name_builder StringBuilder StringBuilder to construct canonical names of found citations None meta dict [ str , str ] Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. {} inherit_template another Template whose values this one should copy unless expressly overwritten. None Source code in citeurl/citator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def __init__ ( self , name : str , tokens : dict [ str , TokenType ] = {}, meta : dict [ str , str ] = {}, patterns : list [ str ] = [], broad_patterns : list [ str ] = [], shortform_patterns : list [ str ] = [], idform_patterns : list [ str ] = [], name_builder : StringBuilder = None , URL_builder : StringBuilder = None , inherit_template = None , ): \"\"\" Arguments: name: the name of this template tokens: The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses. patterns: Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces. Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded. broad_patterns: Same as `patterns`, except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns. shortform_patterns: Same as `patterns`, but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding `raw_token` from the long-form citation. idform_patterns: Same as `shortform_patterns`, except that they will only be used to scan text until the next different citation occurs. URL_builder: `StringBuilder` to construct URLs for found citations name_builder: `StringBuilder` to construct canonical names of found citations meta: Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name. inherit_template: another `Template` whose values this one should copy unless expressly overwritten. \"\"\" kwargs = locals () for attr , default in { 'name' : None , 'tokens' : {}, 'patterns' : [], 'broad_patterns' : [], 'shortform_patterns' : [], 'idform_patterns' : [], 'URL_builder' : None , 'name_builder' : None , 'meta' : {}, } . items (): if inherit_template and kwargs [ attr ] == default : value = inherit_template . __dict__ . get ( attr ) elif attr . endswith ( 'patterns' ) and not kwargs [ attr ]: value = [] else : value = kwargs [ attr ] self . __dict__ [ attr ] = value # update inherited StringBuilders with the correct metadata if inherit_template and self . meta : if self . URL_builder : self . URL_builder = copy ( self . URL_builder ) self . URL_builder . defaults = self . meta if self . name_builder : self . name_builder = copy ( self . name_builder ) self . name_builder . defaults = self . meta # use the template's metadata and tokens to make a dictionary # of replacements to insert into the regexes before compilation replacements = { k : str ( v ) for ( k , v ) in self . meta . items ()} replacements . update ({ k : fr '(?P< { k } > { v . regex } )(?!\\w)' for ( k , v ) in self . tokens . items () }) # compile the template's regexes and broad_regexes self . regexes = [] self . broad_regexes = [] for kind in [ 'regexes' , 'broad_regexes' ]: if kind == 'broad_regexes' : pattern_list = self . patterns + self . broad_patterns flags = re . I else : pattern_list = self . patterns flags = 0 for p in pattern_list : pattern = process_pattern ( p , replacements , add_word_breaks = True ) try : regex = re . compile ( pattern , flags ) self . __dict__ [ kind ] . append ( regex ) except re . error as e : i = 'broad ' if kind == 'broad_regexes' else '' raise re . error ( f ' { self } template \\' s { i } pattern \" { pattern } \" has ' f 'an error: { e } ' ) self . _processed_shortforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . shortform_patterns ] self . _processed_idforms = [ process_pattern ( p , replacements , add_word_breaks = True ) for p in self . idform_patterns ]","title":"__init__()"},{"location":"library/#citeurl.citator.Template.cite","text":"Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. Source code in citeurl/citator.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def cite ( self , text , broad : bool = True , span : tuple = ( 0 ,)) -> Citation : \"\"\" Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None. \"\"\" regexes = self . broad_regexes if broad else self . regexes matches = match_regexes ( text , regexes , span = span ) for match in matches : try : return Citation ( match , self ) except SyntaxError : # invalid citation continue else : return None","title":"cite()"},{"location":"library/#citeurl.citator.Template.from_dict","text":"Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. Source code in citeurl/citator.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 @classmethod def from_dict ( cls , name : str , values : dict , inheritables : dict = {}): \"\"\" Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format. \"\"\" values = { k . replace ( ' ' , '_' ): v for k , v in values . items () } # when pattern is listed in singular form, # replace it with a one-item list items = values . items () values = {} for key , value in items : if key . endswith ( 'pattern' ): values [ key + 's' ] = [ value ] else : values [ key ] = value # unrelated: when a single pattern is split # into a list (likely to take advantage of # YAML anchors), join it into one string for k , v in values . items (): if not k . endswith ( 'patterns' ): continue elif v is None : values [ k ] = None continue for i , pattern in enumerate ( v ): if type ( pattern ) is list : values [ k ][ i ] = '' . join ( pattern ) inherit = values . get ( 'inherit' ) if inherit : values . pop ( 'inherit' ) try : values [ 'inherit_template' ] = inheritables . get ( inherit ) except KeyError : raise KeyError ( f 'Template \" { name } \" tried to inherit unknown ' + f 'template \" { inherit } \"' ) for key in [ 'name_builder' , 'URL_builder' ]: data = values . get ( key ) if data : data [ 'defaults' ] = values . get ( 'meta' ) or {} values [ key ] = StringBuilder . from_dict ( data ) values [ 'tokens' ] = { k : TokenType . from_dict ( k , v ) for k , v in values . get ( 'tokens' , {}) . items () } return cls ( name = name , ** values )","title":"from_dict()"},{"location":"library/#citeurl.citator.Template.list_longform_cites","text":"Get a list of all long-form citations to this template found in the given text. Source code in citeurl/citator.py 266 267 268 269 270 271 272 273 274 275 276 277 278 def list_longform_cites ( self , text , broad : bool = False , span : tuple = ( 0 ,)): \"\"\" Get a list of all long-form citations to this template found in the given text. \"\"\" cites = [] regexes = self . broad_regexes if broad else self . regexes for match in match_regexes ( text , regexes , span = span ): try : cites . append ( Citation ( match , self )) except SyntaxError : continue return cites","title":"list_longform_cites()"},{"location":"library/#citeurl.citator.Template.to_dict","text":"save this Template to a dictionary of values Source code in citeurl/citator.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def to_dict ( self ) -> dict : \"save this Template to a dictionary of values\" output = {} if self . meta : output [ 'meta' ] = self . meta output [ 'tokens' ] = { k : v . to_dict () for k , v in self . tokens . items () } for key in [ 'patterns' , 'shortform_patterns' , 'idform_patterns' ]: value = self . __dict__ . get ( key ) if not value : continue elif len ( value ) > 1 : output [ key ] = value else : # de-pluralize lists that contain only one pattern output [ key [: - 1 ]] = value [ 0 ] for key in [ 'name_builder' , 'URL_builder' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] . to_dict () spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output","title":"to_dict()"},{"location":"library/#citeurl.citator.Template.to_yaml","text":"save this Template to a YAML string Source code in citeurl/citator.py 242 243 244 245 246 247 248 def to_yaml ( self ) -> str : \"save this Template to a YAML string\" return safe_dump ( { self . name : self . to_dict ()}, sort_keys = False , allow_unicode = True , )","title":"to_yaml()"},{"location":"library/#tokentype","text":"These objects represent categories of tokens that might be found in a citation. Attributes: Name Type Description regex A regular expression that matches the actual text of the token as found in any document, like the \"42\" in \"42 USC \u00a7 1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\". This regex will automatically be enclosed in a named capture group and inserted into any of the template's match patterns wherever the token's name appears in curly braces. edits Steps to normalize the token as captured in the regex into a value that is consistent across multiple styles. default Set the token to this value if it is not found in the citation. severable If two citations only differ based on this token, and only because one of the tokens extends longer than the other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then severable means that the former citation is thought to encompass the latter. Source code in citeurl/tokens.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class TokenType : \"\"\" These objects represent categories of tokens that might be found in a citation. Attributes: regex: A regular expression that matches the actual text of the token as found in any document, like the \"42\" in \"42 USC \u00a7 1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\". This regex will automatically be enclosed in a named capture group and inserted into any of the template's match patterns wherever the token's name appears in curly braces. edits: Steps to normalize the token as captured in the regex into a value that is consistent across multiple styles. default: Set the token to this value if it is not found in the citation. severable: If two citations only differ based on this token, and only because one of the tokens extends longer than the other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then `severable` means that the former citation is thought to encompass the latter. \"\"\" def __init__ ( self , regex : str = r '\\d+' , edits : list [ TokenOperation ] = [], default : str = None , severable : bool = False , ): self . regex = regex self . edits = edits self . default = default self . severable = severable @classmethod def from_dict ( cls , name : str , data : dict ): \"load a TokenType from a dictionary of values\" return cls ( regex = data [ 'regex' ], default = data . get ( 'default' ), edits = [ TokenOperation . from_dict ( v ) for v in data . get ( 'edits' , []) ], severable = data . get ( 'severable' , False ) ) def to_dict ( self ) -> dict : \"save this TokenType to a dictionary for storage in YAML format\" output = { 'regex' : self . regex } if self . edits : output [ 'edits' ] = [ e . to_dict () for e in self . edits ] if self . default : output [ 'default' ] = self . default if self . severable : output [ 'severable' ] = True return output def normalize ( self , token : str ) -> str : if not token : return self . default for op in self . edits : token = op ( token ) return token def __str__ ( self ): return self . regex def __repr__ ( self ): norms = '[' + ', ' . join ([ repr ( n ) for n in self . edits or [] ]) + ']' return ( f \"TokenType(regex=' { self . regex } '\" + ( f \", default=' { self . default } '\" if self . default else '' ) + ( f ', edits= { norms } ' if self . edits else '' ) + ')' )","title":"TokenType"},{"location":"library/#citeurl.tokens.TokenType.from_dict","text":"load a TokenType from a dictionary of values Source code in citeurl/tokens.py 251 252 253 254 255 256 257 258 259 260 261 262 @classmethod def from_dict ( cls , name : str , data : dict ): \"load a TokenType from a dictionary of values\" return cls ( regex = data [ 'regex' ], default = data . get ( 'default' ), edits = [ TokenOperation . from_dict ( v ) for v in data . get ( 'edits' , []) ], severable = data . get ( 'severable' , False ) )","title":"from_dict()"},{"location":"library/#citeurl.tokens.TokenType.to_dict","text":"save this TokenType to a dictionary for storage in YAML format Source code in citeurl/tokens.py 264 265 266 267 268 269 270 271 272 273 274 275 def to_dict ( self ) -> dict : \"save this TokenType to a dictionary for storage in YAML format\" output = { 'regex' : self . regex } if self . edits : output [ 'edits' ] = [ e . to_dict () for e in self . edits ] if self . default : output [ 'default' ] = self . default if self . severable : output [ 'severable' ] = True return output","title":"to_dict()"},{"location":"library/#tokenoperation","text":"A function to perform a predefined string manipulation Source code in citeurl/tokens.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class TokenOperation : \"\"\"A function to perform a predefined string manipulation\"\"\" def __init__ ( self , action : str , data , mandatory : bool = True , token : str = None , output : str = None , ): \"\"\" Arguments: action: The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of `regex`: `replacement` pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. data: any data that a given action needs specified, as described above mandatory: whether a failed lookup or format action should invalidate the entire citation token: Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. output: If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. \"\"\" if action == 'sub' : self . func = lambda x : re . sub ( data [ 0 ], data [ 1 ], x ) elif action == 'lookup' : table = { re . compile ( k , flags = re . I ): v for k , v in data . items () } self . func = lambda x : self . _lookup ( x , table , mandatory ) elif action == 'case' : self . func = lambda x : self . _set_case ( x , data ) elif action == 'lpad' : self . func = lambda x : self . _left_pad ( x , data ) elif action == 'number_style' : action_options = [ 'cardinal' , 'ordinal' , 'roman' , 'digit' ] if data not in action_options : raise SyntaxError ( f ' { data } is not a valid number style. Valid options: ' f ' { action_options } ' ) self . func = lambda x : self . _number_style ( x , data , mandatory ) else : raise SyntaxError ( f ' { action } is not a defined token operation.' ) self . action = action self . data = data self . mandatory = mandatory self . token = token self . output = output @classmethod def from_dict ( cls , data : dict ): \"load a TokenOperation from a dictionary of values\" operations = [] for key in [ 'sub' , 'lookup' , 'case' , 'lpad' , 'number style' ]: value = data . get ( key ) if value : action = key . replace ( ' ' , '_' ) action_data = value break mandatory = data . get ( 'mandatory' , True ) token = data . get ( 'token' ) output = data . get ( 'output' ) return cls ( action , action_data , mandatory , token , output ) def to_dict ( self ) -> dict : \"save this TokenOperation to a dictionary of values\" output = {} for key in [ 'token' , 'output' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] output [ self . action ] = self . data if not self . mandatory : output [ 'mandatory' ] = False spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output def modify_dict ( self , tokens : dict ): \"\"\" apply this operation to a dictionary of tokens, editing them as appropriate \"\"\" if not tokens . get ( self . token ): return if self . output : tokens [ self . output ] = self . func ( tokens [ self . token ]) else : tokens [ self . token ] = self . func ( tokens [ self . token ]) def __call__ ( self , input_value ): return self . func ( input_value ) def __repr__ ( self ): return ( f 'TokenOperation(action=\" { self . action } \", data=\" { self . data } \"' + ( f ', mandatory=False' if not self . mandatory else '' ) + ( f ', token=\" { self . token } \"' if self . token else '' ) + ( f ', output=\" { self . output } \"' if self . output else '' ) + ')' ) # ================ Token Processing Operations =================== # def _lookup ( self , input : str , table : dict [ re . Pattern , str ], mandatory : bool = False , ) -> str : for pattern , repl in table . items (): if pattern . fullmatch ( input ): return repl if mandatory : regexes = [ r . pattern for r in table . keys ()] raise SyntaxError ( f ' { input } could not be found in { table } ' ) else : return input def _set_case ( self , input : str , case : str ) -> str : if case == 'upper' : return input . upper () elif case == 'lower' : return input . lower () elif case == 'title' : return input . title () def _left_pad ( self , input : str , min_length : int , pad_char = '0' ): diff = min_length - len ( input ) if diff > 0 : return ( pad_char * diff + input ) return input def _number_style ( self , input : str , form : str , throw_error : bool = False ): if input . isnumeric (): value = int ( input ) elif input [: - 2 ] . isnumeric (): # e.g. \"2nd\" value = int ( input [: - 2 ]) else : input = input . lower () for i , row in enumerate ( number_words ): if input in row : value = i + 1 break else : if throw_error : raise SyntaxError ( f ' { input } cannot be recognized as a number' ) if form == 'digit' : return str ( value ) forms = [ 'roman' , 'cardinal' , 'ordinal' ] output = number_words [ value - 1 ][ forms . index ( form )] if form == 'roman' : return output . upper () return output","title":"TokenOperation"},{"location":"library/#citeurl.tokens.TokenOperation.__init__","text":"Parameters: Name Type Description Default action str The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of regex : replacement pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. required data any data that a given action needs specified, as described above required mandatory bool whether a failed lookup or format action should invalidate the entire citation True token str Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. None output str If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. None Source code in citeurl/tokens.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , action : str , data , mandatory : bool = True , token : str = None , output : str = None , ): \"\"\" Arguments: action: The kind of string manipulation that this operation will perform, using the given data. There are a few different options: 'sub': Regex substitution to perform on the text. Needs a list of two values: [PATTERN, REPLACEMENT] 'lookup': Check if the token matches any of the given regexes (via case-insensitive matching), and if so, replace it with the corresponding value. Needs a dictionary of `regex`: `replacement` pairs. 'case': Capitalize the token in the specified way. Options are 'upper', 'lower', and 'title'. 'lpad': Left pad the token with zeros until it is the specified number of characters long. Requires an int specifying the number of characters. You can also specify the padding character by providing a tuple: (MINIMUM_LENGTH, PADDING_CHARACTER). 'number_style': Assume that the token is a number, either in the form of digits, Roman numerals, or number words like \"thirty-seven\". Convert it into the specified number format, which can be any of these: 'cardinal', e.g. \"twenty-seven\" 'cardinal spaced', e.g. \"twenty seven\" 'cardinal unspaced', e.g. \"twentyseven\" 'ordinal', e.g. \"twenty-seventh\" 'ordinal spaced', e.g. \"twenty seventh\" 'ordinal unspaced', e.g. \"twentyseventh\" 'roman numeral', e.g. 'xxvii' 'digit', e.g. '27' Note that number formatting only works for positive whole numbers that do not exceed 40. data: any data that a given action needs specified, as described above mandatory: whether a failed lookup or format action should invalidate the entire citation token: Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method. output: If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place. \"\"\" if action == 'sub' : self . func = lambda x : re . sub ( data [ 0 ], data [ 1 ], x ) elif action == 'lookup' : table = { re . compile ( k , flags = re . I ): v for k , v in data . items () } self . func = lambda x : self . _lookup ( x , table , mandatory ) elif action == 'case' : self . func = lambda x : self . _set_case ( x , data ) elif action == 'lpad' : self . func = lambda x : self . _left_pad ( x , data ) elif action == 'number_style' : action_options = [ 'cardinal' , 'ordinal' , 'roman' , 'digit' ] if data not in action_options : raise SyntaxError ( f ' { data } is not a valid number style. Valid options: ' f ' { action_options } ' ) self . func = lambda x : self . _number_style ( x , data , mandatory ) else : raise SyntaxError ( f ' { action } is not a defined token operation.' ) self . action = action self . data = data self . mandatory = mandatory self . token = token self . output = output","title":"__init__()"},{"location":"library/#citeurl.tokens.TokenOperation.from_dict","text":"load a TokenOperation from a dictionary of values Source code in citeurl/tokens.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_dict ( cls , data : dict ): \"load a TokenOperation from a dictionary of values\" operations = [] for key in [ 'sub' , 'lookup' , 'case' , 'lpad' , 'number style' ]: value = data . get ( key ) if value : action = key . replace ( ' ' , '_' ) action_data = value break mandatory = data . get ( 'mandatory' , True ) token = data . get ( 'token' ) output = data . get ( 'output' ) return cls ( action , action_data , mandatory , token , output )","title":"from_dict()"},{"location":"library/#citeurl.tokens.TokenOperation.modify_dict","text":"apply this operation to a dictionary of tokens, editing them as appropriate Source code in citeurl/tokens.py 138 139 140 141 142 143 144 145 146 147 148 def modify_dict ( self , tokens : dict ): \"\"\" apply this operation to a dictionary of tokens, editing them as appropriate \"\"\" if not tokens . get ( self . token ): return if self . output : tokens [ self . output ] = self . func ( tokens [ self . token ]) else : tokens [ self . token ] = self . func ( tokens [ self . token ])","title":"modify_dict()"},{"location":"library/#citeurl.tokens.TokenOperation.to_dict","text":"save this TokenOperation to a dictionary of values Source code in citeurl/tokens.py 124 125 126 127 128 129 130 131 132 133 134 135 136 def to_dict ( self ) -> dict : \"save this TokenOperation to a dictionary of values\" output = {} for key in [ 'token' , 'output' ]: if self . __dict__ . get ( key ): output [ key ] = self . __dict__ [ key ] output [ self . action ] = self . data if not self . mandatory : output [ 'mandatory' ] = False spaced_output = { k . replace ( '_' , ' ' ): v for k , v in output . items ()} return spaced_output","title":"to_dict()"},{"location":"library/#stringbuilder","text":"A function to take a dictionary of values and use it to construct a piece of text from them. This is used for citation templates' name builders and URL builders. Attributes: Name Type Description parts A list of strings that will be concatenated to create the string. Parts may contain bracketed references to citations' token values as well as templates' metadata. If a part references a token whose value is not set, the part will be omitted from the created string. edits A list of TokenOperations that will be performed on the provided tokens before the string is constructed. If the edits have output values, it is possible for them to define entirely new tokens for the sole purpose of building the string. defaults A dictionary of default token values to use when not overwritten by the citation. Generally these are provided by the template's meta attribute. Source code in citeurl/tokens.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 class StringBuilder : \"\"\" A function to take a dictionary of values and use it to construct a piece of text from them. This is used for citation templates' name builders and URL builders. Attributes: parts: A list of strings that will be concatenated to create the string. Parts may contain bracketed references to citations' token values as well as templates' metadata. If a part references a token whose value is not set, the part will be omitted from the created string. edits: A list of TokenOperations that will be performed on the provided tokens before the string is constructed. If the edits have `output` values, it is possible for them to define entirely new tokens for the sole purpose of building the string. defaults: A dictionary of default token values to use when not overwritten by the citation. Generally these are provided by the template's meta attribute. \"\"\" def __init__ ( self , parts : list [ str ], edits : list [ TokenOperation ] = [], defaults : dict [ str , str ] = {} ): self . parts = parts self . edits = edits self . defaults = defaults @classmethod def from_dict ( cls , data : dict ): \"load StringBuilder from dictionary of values\" edits = [ TokenOperation . from_dict ( o ) for o in data . get ( 'edits' , []) ] parts = data [ 'parts' ] defaults = data . get ( 'defaults' ) or {} return cls ( parts , edits , defaults ) def to_dict ( self ) -> dict : \"save StringBuilder to a dictionary of values\" output = { 'parts' : self . parts } if self . edits : output [ 'edits' ] = [ op . to_dict () for op in self . edits ] return output def __call__ ( self , tokens : dict [ str , str ], ) -> str : if self . defaults : defaults = copy ( self . defaults ) defaults . update ( tokens ) tokens = defaults else : tokens = copy ( tokens ) tokens = { k : v for k , v in tokens . items () if v } for op in self . edits : try : op . modify_dict ( tokens ) except SyntaxError : # token operation failed; just skip it pass string_parts = [] for part in self . parts : try : string_parts . append ( part . format ( ** tokens )) except KeyError : # skip parts that reference a nonexistent token pass # if a mandatory TokenOperation failed, don't return a URL except SyntaxError : string_parts = [] break t = copy ( tokens ) return '' . join ( string_parts ) or None def __repr__ ( self ): return ( f 'StringBuilder(parts= { self . parts } ' + ( f ', edits= { self . edits } ' if self . edits else '' ) + ( f ', defaults= { self . defaults } ' if self . defaults else '' ) + ')' )","title":"StringBuilder"},{"location":"library/#citeurl.tokens.StringBuilder.from_dict","text":"load StringBuilder from dictionary of values Source code in citeurl/tokens.py 330 331 332 333 334 335 336 337 338 339 @classmethod def from_dict ( cls , data : dict ): \"load StringBuilder from dictionary of values\" edits = [ TokenOperation . from_dict ( o ) for o in data . get ( 'edits' , []) ] parts = data [ 'parts' ] defaults = data . get ( 'defaults' ) or {} return cls ( parts , edits , defaults )","title":"from_dict()"},{"location":"library/#citeurl.tokens.StringBuilder.to_dict","text":"save StringBuilder to a dictionary of values Source code in citeurl/tokens.py 341 342 343 344 345 346 def to_dict ( self ) -> dict : \"save StringBuilder to a dictionary of values\" output = { 'parts' : self . parts } if self . edits : output [ 'edits' ] = [ op . to_dict () for op in self . edits ] return output","title":"to_dict()"},{"location":"library/#insert_links","text":"Convenience function to hyperlink all citations in a text. For more info, see Citator.insert_links(). Source code in citeurl/citator.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def insert_links ( text : str , attrs : dict = { 'class' : 'citation' }, add_title : bool = True , URL_optional : bool = False , redundant_links : bool = True , id_breaks : re . Pattern = None , ignore_markup : bool = True , citator : Citator = None , ): \"\"\" Convenience function to hyperlink all citations in a text. For more info, see Citator.insert_links(). \"\"\" citator = citator or _get_default_citator () return citator . insert_links ( text = text , attrs = attrs , add_title = add_title , redundant_links = redundant_links , id_breaks = id_breaks , ignore_markup = ignore_markup , )","title":"insert_links()"},{"location":"library/#cite","text":"Convenience function to find a single citation in text, or None. See Citator.cite() for more info. Source code in citeurl/citator.py 598 599 600 601 602 603 604 605 606 607 608 def cite ( text : str , broad : bool = True , citator : Citator = None , ) -> Citation : \"\"\" Convenience function to find a single citation in text, or None. See Citator.cite() for more info. \"\"\" citator = citator or _get_default_citator () return citator . cite ( text , broad = broad )","title":"cite()"},{"location":"library/#list_cites","text":"Convenience function to list all citations in a text. For more info, see Citator.list_cites(). Source code in citeurl/citator.py 610 611 612 613 614 615 616 def list_cites ( text , citator : Citator = None , id_breaks = None ): \"\"\" Convenience function to list all citations in a text. For more info, see Citator.list_cites(). \"\"\" citator = citator or _get_default_citator () return citator . list_cites ( text , id_breaks = id_breaks )","title":"list_cites()"},{"location":"template-yamls/","text":"Writing Your Own Templates CiteURL has built-in templates to support most of the major sources of U.S. state and federal law, but that's still a very small fraction of the universe of references a document might contain. Municipal ordinances, other countries' laws, and most subject-specific materials are simply outside the scope of what CiteURL's built-in templates can reasonably cover. This page details how you can write your own citation templates to supplement or replace the built-in ones. Before you proceed, make sure you're a little familiar with regular expressions (regex), because a citation template is essentially a bunch of them glued together. You'll also need some basic knowledge of YAML , because that's the glue. Note : CiteURL's built-in templates are all written in the same format described on this page, so they're a helpful resource to learn and copy from when writing your own. Introduction Essentially, a citation template does three things. First, it recognizes whether a given bit of text is a valid citation. Second, it extracts the relevant data from the citation, like the page or section numbers it references. Third, the template defines how to do useful things with that data, like turn it into a URL. Here's a simple template that does all of those things: U.S. Code : tokens : title : regex : \\d+ section : regex : \\d+[A-Z]? pattern : '{title} U\\.?S\\.?C\\.? ?\u00a7? {section}' URL builder : parts : - 'https://www.law.cornell.edu/uscode/text/{title}/{section}' name builder : parts : - '{title} U.S.C. \u00a7 {section}' First, the template defines two tokens that a U.S. code citation can contain. The first is something called \"title\", and the second is \"section\". The fact that title is listed before section in the tokens list is important; it indicates that titles contain sections. Each token has its own regex that defines what inputs are valid for that part of the citation. Here, titles are just one or more digits, i.e. \\d+ , whereas section numbers can optionally have a single capital letter afterwards. Next, the template provides a pattern for what citations need to look like. The pattern is a regular expression, except that any tokens listed in curly braces are replaced by a regex capture group matching the relevant regex. So, when CiteURL actually runs, the pattern is used to generate this regex: (?P<title>\\d+) U\\.?S\\.?C\\.? \u00a7? ?(?P<section>\\d+[A-Z]?) That regex lets the template know that \"42 U.S.C. \u00a7 1988\" is a reference to section 1988 of Title 42 of the U.S. Code, and so are a few similar-looking things like \"42 USC 1988\". Either way, \"42\" and \"1988\" will be stored as tokens and can be inserted into the URL builder to make this link . The name builder works the same way. Regardless of any formatting differences in the text that was matched, it lets CiteURL display that citation as \"42 U.S.C. \u00a7 1988.\" Now that you've got the basic concept, let's go over the parts in more detail. Tokens Tokens are the discrete pieces of information found in a citation. They can represent anything from a page number to a named chapter of law. Each token must have a regex indicating what text is valid input for that token, and it may also have a list of edits used to process and normalize the token text as soon as it is matched. Sometimes, like in the U.S. Code example above, it's as simple as storing whatever text is found in a particular part of the citation. No edits were needed, because \"1988\" would only be written in one specific way. Other times, however, it is necessary to perform various string processing operations to normalize the data. Consider the following example: U.S. Constitution : ... tokens : article : regex : [ 1-7 ]| [IV]{1,3}|One|Two|Three|Four|Five|Six|Seven edits : - number style : digit ... Here, the regex can recognize a number between one and seven, no matter whether it is given as a digit, a Roman numeral, or a word. But it would not be useful to store this value without normalization---it is important that \"3\", \"III\", and \"Three\" are all treated as equivalent. To accomplish this, the template uses a number style edit to coerce the number into digit format. As a result, no matter whether the template matched \"Article III\", \"Article 3\", or \"Article Three\", the resulting citation will have an article value of \"3\". Edits Edits are simple predefined string operations that can be performed on tokens. They are useful in two contexts. First, as described above, they can be included in the token definition in order to normalize its input. Second, they can be used in string builders in order to temporarily-modify tokens for the sole purpose of building the string. In either case, the following edits are available: Edit Description Example case Convert the given token to the specified capitalization, either upper , lower , or title . In the latter case, only the first letter of every word is capitalized. case: upper sub Perform a regex substitution on the token, replacing each occurrences of the first listed string (treated as a regex) with the second listed string. sub: ['\\W+', '-'] lpad Add zeroes to the left side of the token as necessary until it is the specified length. lpad: 3 lookup * Use case-insensitive regex matching to check whether the token matches any of the keys in the given dictionary. If the token matches a key, it will be replaced with the associated value. lookup: {'[Pp]attern': 'replacement', '[Pp]otato': 'tomato'} number style * Assume that the token is a number, and convert it to the specified format, which can be any of the following: digit , roman numeral , cardinal , or ordinal . The latter two options may be followed with spaced or unspaced to clarify how to handle words like \"twenty-seven\". The default is to use dashes. number style: cardinal Failed Edits The lookup and number style edits are unique in that it is possible for them to fail. A token may fail a lookup if it does not match any of the provided regexes, while it may fail a number style edit if it cannot be recognized as a number. When this happens, the default behavior depends on whether the failed edit is part of a token definition, or instead part of a string builder. If the edit is part of the token definition, it will cause the entire citation to fail as if it had never matched the template in the first place. On the other hand, if the token is being used in a string builder, failure will simply cause the affected token's value to be set to null for purposes of the string builder. You can change the default behavior by adding the following tag to an edit: mandatory: no . If an edit with this tag fails, the edit will simply be ignored. For instance, the following \"reporter\" token can be any string of up to ten characters, but if it is \"F. Supp.\" or \"P. 2d\" it will be replaced with \"F.Supp.\" or \"P.2d\", respectively. Because the lookup is tagged as not mandatory, tokens that don't match either of these strings will be unaffected. Without that tag, the entire citation would be discarded if it did not match either of those values. ... tokens : reporter : regex : .{1,10} edits : - mandatory : no lookup : F\\. ?Supp\\. : F.Supp. P\\. ?2d : P.2d ... Chaining Multiple Edits Edits can be chained, and they will take effect in the order they are listed. For instance, if you wanted to store the article numbers as lower-case Roman numerals, you could do this: tokens : article : regex : [ 1-7 ]| [IV]{1,3}|One|Two|Three|Four|Five|Six|Seven edits : - number style : roman - case : lower Severability Ordinarily, if two citations both have a token and that token differs between the two of them, the two citations are thought to be completely unrelated. For instance, \"33 USC \u00a7 10\" is a totally different law than \"33 USC \u00a7 100\", even though \"100\" starts with \"10\". However, sometimes it is relevant that one token begins with the same value as another. For instance, the Code of Federal Regulations template has a \"subsection\" token that matches a sequence of one or more numbers or letters in parentheses. But ordinarily, CiteURL would treat \"21 CFR \u00a7 820.1(a)\" and \"21 CFR \u00a7 820.1(a)(1)\" as totally unrelated subsections since \"(a)\" is not the same as \"(a)(1)\". This is wrong, since the former citation encompasses the latter. To handle these situations, tokens can be given the severable: yes tag, to indicate that when the only difference between two citations is that the second one has a severable token that extends longer than the first one's, the first citation is thought to include the second one. ... tokens : subsection : regex : '(\\(\\w{1,4}\\))+' severable : yes ... Note that the severable tag is unnecessary when the difference is that one citation is simply missing a possible token. For instance, \"U.S. Const. Article III\" is known to include \"U.S. Const. Article III, \u00a7 2\" just because the U.S. Constitution template defines the article token before the section token. Default Values Often a citation may be valid even if it does not contain all tokens that it possibly could. For instance, a citation to a court opinion may or may not have a pincite to a specific page. Normally, when such a token is omitted, its value is None . However, you can also specify a different default value if you wish: ... tokens : section : regex : \\d+ default : '1' ... Patterns Patterns are essentially the regular expressions that a template uses to detect overall citations. However, a pattern is not a pure regex---instead of including a regex for each token the pattern can recognize, the pattern simply contains a reference to the token itself. This is useful as a way to avoid redefining a token's regex when it is used in multiple patterns. As such. A template's patterns are responsible for recognizing one or more formats of typical long-form citations to the given body of law. In addition to these, a template can also have shortform patterns and idform patterns , which are triggered once a longform citation has already been recognized. When this occurs, CiteURL looks for \"idform\" citations until it encounters a different intervening citation, and it looks for shortforms anywhere until the end of the document. In addition, a template can have broad patterns , which are exactly like longform patterns except that they are only used in search engine-like contexts, where user convenience is more important than avoiding false positives. Pattern Format Regardless of the type of pattern, they share a few key points of formatting. First, it is possible to specify patterns either in singular form or in list form. For instance, either of these would be valid: ... pattern : '{volume} USC \u00a7 {section}' ... ... patterns : - '{volume USC (\u00a7|[Ss]ec(tion|t?\\.) {section}' - '(\u00a7|[Ss]ec(tion|t?\\.) {section} of [Vv]olume {volume} of the U\\.S\\. Code' ... This is not to be confused with another feature of patterns: An individual pattern can be provided either as a single string, or as a list of strings. This is useful so that you can take advantage of YAML anchors to avoid rewriting certain common bits of regex. Consider the following example: ... patterns : - [ '{volume} USC ' , &sec_sign '(\u00a7|[Ss]ec(tion|t?\\.)' , ' {section}' ] - [ *sec_sign , ' {section} of [Vv]olume {volume} of the U\\.S\\. Code' ] ... The above example defines a YAML anchor called sec_sign to represent any string that is either \"\u00a7\", \"Section\", or various abbreviations thereof. Because it would be a pain to write that string repeatedly across a large number of templates, it's useful to reuse it as a YAML anchor. Although each pattern is broken into a list, it is functionally equivalent to the previous example. Shortforms and Idforms These two types of patterns are intended to recognize contextual references to a citation that was found previously in the text. To facilitate this, they both share one special feature: Values from their parent longform citation can be inserted into the shortform pattern so as to only match when the specified value is the same. Consider the following example: U.S. Caselaw : tokens : reporter : { regex : . { 3 , 10 }} volume : { regex : \\d+ } page : { regex : \\d+ } pincite : { regex : \\d+ } pattern : '{volume} {reporter} {page}(, {pincite})?' shortform pattern : '{same volume} {same reporter} at {pincite}' idform pattern : 'Id\\. at {pincite}' This template will recognize longform citations like \"413 F. Supp. 1281\". Once it has found such a citation, it can detect immediate repeat citations like \" Id. at <any number>\", because of its idform pattern . The shortform pattern , meanwhile, will match any subsequent occurrence of \"413 F. Supp. <any number>\" anywhere in the text. String Builders The two kinds of string builder are a template's name builder and its URL builder , and they both work the same way. They use a citation's tokens to fill placeholders in a pattern and output a uniform string representation of that citation. This is the source of each citation's name and URL properties. A string builder is made up of one or more parts , and optionally a list of edits . The first value, parts , is a list of strings that will be concatenated to make the result. Each part can contain placeholder values in curly braces. The placeholders will be replaced with the corresponding token values or metadata values. If a part references a blank token, that part will be omitted from the overall string. edits is a list of token edits that will be performed on the tokens and metadata just before they are inserted into the string. They work just like the token edits described earlier, except for two differences. First, whereas the edits described earlier serve to normalize tokens after they are matched in text, these ones are only used in order to build a string---they do not permanently modify the underlying tokens. Second, because these edits are not listed by token, you must specify which token each one operates on, by giving it a token value. You can also optionally give it an output value, in which the result of the edit will be saved to the specified token instead of modifying the input. Here's an example of each kind of string builder: U.S. Code : ... name builder : parts : - '{title} U.S.C. \u00a7 {section}' - '{subsection}' URL builder : parts : - https://www.law.cornell.edu/uscode/text/{title}/{section} - '#{subsection}' edits : - token : subsection sub : [ '\\)\\(' , '_' ] - token : subsection sub : [ '[()]' , '' ] If this template is given the citation, \"42 usc 1988\", the name builder will use the title and section numbers to write \"42 U.S.C. \u00a7 1983\". The '{subsection}' part is omitted because the citation has no subsection. Likewise, the URL builder will make this URL , ignoring the blank token and the edits that rely on it. Given the citation \"29 USC \u00a7 158(b)(4)\", however, the URL builder will take the subsection and subject it to two edits, first to change it from '(b)(4)' to '(b_4)', and then to change that to 'b_4'. Having done that, it can fill in the '#{subsection}' part, and create this URL . Miscellaneous The following features aren't crucial to what a template is, or what it does, but they're nice to have when you're trying to write a whole lot of templates without reinventing the wheel too many times. Metadata A template can have a meta attribute that contains a dictionary of values that will be accessible to the template's patterns and string builders just like a token is. Note that token edits in string builders can override metadata values using the output tag. Template Inheritance A template can inherit any already-defined template, such that it will copy any characteristics of that template except for those that are expressly overwritten. This is useful when two templates are both very, very complicated, but they are largely similar in format. For instance, citations to the Code of Federal Regulations are very similar to the U.S. code, so most of this horrible mess only needs to be written once: U.S. Code : meta : name regex : 'U\\. ?S\\. ?C(ode|\\.)|USC|United States Code' abbreviation : U.S.C. tokens : title : { regex : \\d+ } section : { regex : '\\d[\\w.-]*\\w|\\d' } subsection : regex : '(\\(\\w{1,4}\\))+' severable : yes patterns : - - &title ([Tt]itle )?{title} - ',? {name regex}(,? )?(' - &section_sign ((&sect;|&#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.)) - ')? ?{section}' - &subsec '(((,? )?sub(sections?|divisions?|(sec|d(iv)?)?s?\\.))? ?{subsection})?' - [ '[Tt]itle {title},? (' , *section_sign , ')? ?{section}' , *subsec , ' of the {name regex}' ] - [ '(' , *section_sign , ')? ?{section}' , *subsec , ' of [Tt]itle {title} of the {name regex}' ] idform patterns : - '[Ii]d\\.( at)?( \u00a7\u00a7?)? ?{section}( ?{subsection})?' - '((&sect;|&#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.)) {section}( ?{subsection})?(?! of)' - '[Ii]d\\. at {subsection}' name builder : parts : - '{title} {abbreviation} \u00a7 {section}' - '{subsection}' URL builder : parts : - https://www.law.cornell.edu/uscode/text/{title}/{section} - '#{subsection}' edits : - token : subsection sub : [ '\\)\\(' , '_' ] - token : subsection sub : [ '[()]' , '' ] Code of Federal Regulations : inherit : U.S. Code meta : name regex : 'C\\.? ?F\\.? ?R\\.?|Code of Federal Regulations' abbreviation : C.F.R. URL builder : parts : - 'https://ecfr.federalregister.gov/cfr-reference?cfr%5Bdate%5D=current&cfr%5Breference%5D={title} CFR {section} '' - ' #p-{section}{subsection}'","title":"Writing Your Own Templates"},{"location":"template-yamls/#writing-your-own-templates","text":"CiteURL has built-in templates to support most of the major sources of U.S. state and federal law, but that's still a very small fraction of the universe of references a document might contain. Municipal ordinances, other countries' laws, and most subject-specific materials are simply outside the scope of what CiteURL's built-in templates can reasonably cover. This page details how you can write your own citation templates to supplement or replace the built-in ones. Before you proceed, make sure you're a little familiar with regular expressions (regex), because a citation template is essentially a bunch of them glued together. You'll also need some basic knowledge of YAML , because that's the glue. Note : CiteURL's built-in templates are all written in the same format described on this page, so they're a helpful resource to learn and copy from when writing your own.","title":"Writing Your Own Templates"},{"location":"template-yamls/#introduction","text":"Essentially, a citation template does three things. First, it recognizes whether a given bit of text is a valid citation. Second, it extracts the relevant data from the citation, like the page or section numbers it references. Third, the template defines how to do useful things with that data, like turn it into a URL. Here's a simple template that does all of those things: U.S. Code : tokens : title : regex : \\d+ section : regex : \\d+[A-Z]? pattern : '{title} U\\.?S\\.?C\\.? ?\u00a7? {section}' URL builder : parts : - 'https://www.law.cornell.edu/uscode/text/{title}/{section}' name builder : parts : - '{title} U.S.C. \u00a7 {section}' First, the template defines two tokens that a U.S. code citation can contain. The first is something called \"title\", and the second is \"section\". The fact that title is listed before section in the tokens list is important; it indicates that titles contain sections. Each token has its own regex that defines what inputs are valid for that part of the citation. Here, titles are just one or more digits, i.e. \\d+ , whereas section numbers can optionally have a single capital letter afterwards. Next, the template provides a pattern for what citations need to look like. The pattern is a regular expression, except that any tokens listed in curly braces are replaced by a regex capture group matching the relevant regex. So, when CiteURL actually runs, the pattern is used to generate this regex: (?P<title>\\d+) U\\.?S\\.?C\\.? \u00a7? ?(?P<section>\\d+[A-Z]?) That regex lets the template know that \"42 U.S.C. \u00a7 1988\" is a reference to section 1988 of Title 42 of the U.S. Code, and so are a few similar-looking things like \"42 USC 1988\". Either way, \"42\" and \"1988\" will be stored as tokens and can be inserted into the URL builder to make this link . The name builder works the same way. Regardless of any formatting differences in the text that was matched, it lets CiteURL display that citation as \"42 U.S.C. \u00a7 1988.\" Now that you've got the basic concept, let's go over the parts in more detail.","title":"Introduction"},{"location":"template-yamls/#tokens","text":"Tokens are the discrete pieces of information found in a citation. They can represent anything from a page number to a named chapter of law. Each token must have a regex indicating what text is valid input for that token, and it may also have a list of edits used to process and normalize the token text as soon as it is matched. Sometimes, like in the U.S. Code example above, it's as simple as storing whatever text is found in a particular part of the citation. No edits were needed, because \"1988\" would only be written in one specific way. Other times, however, it is necessary to perform various string processing operations to normalize the data. Consider the following example: U.S. Constitution : ... tokens : article : regex : [ 1-7 ]| [IV]{1,3}|One|Two|Three|Four|Five|Six|Seven edits : - number style : digit ... Here, the regex can recognize a number between one and seven, no matter whether it is given as a digit, a Roman numeral, or a word. But it would not be useful to store this value without normalization---it is important that \"3\", \"III\", and \"Three\" are all treated as equivalent. To accomplish this, the template uses a number style edit to coerce the number into digit format. As a result, no matter whether the template matched \"Article III\", \"Article 3\", or \"Article Three\", the resulting citation will have an article value of \"3\".","title":"Tokens"},{"location":"template-yamls/#edits","text":"Edits are simple predefined string operations that can be performed on tokens. They are useful in two contexts. First, as described above, they can be included in the token definition in order to normalize its input. Second, they can be used in string builders in order to temporarily-modify tokens for the sole purpose of building the string. In either case, the following edits are available: Edit Description Example case Convert the given token to the specified capitalization, either upper , lower , or title . In the latter case, only the first letter of every word is capitalized. case: upper sub Perform a regex substitution on the token, replacing each occurrences of the first listed string (treated as a regex) with the second listed string. sub: ['\\W+', '-'] lpad Add zeroes to the left side of the token as necessary until it is the specified length. lpad: 3 lookup * Use case-insensitive regex matching to check whether the token matches any of the keys in the given dictionary. If the token matches a key, it will be replaced with the associated value. lookup: {'[Pp]attern': 'replacement', '[Pp]otato': 'tomato'} number style * Assume that the token is a number, and convert it to the specified format, which can be any of the following: digit , roman numeral , cardinal , or ordinal . The latter two options may be followed with spaced or unspaced to clarify how to handle words like \"twenty-seven\". The default is to use dashes. number style: cardinal","title":"Edits"},{"location":"template-yamls/#failed-edits","text":"The lookup and number style edits are unique in that it is possible for them to fail. A token may fail a lookup if it does not match any of the provided regexes, while it may fail a number style edit if it cannot be recognized as a number. When this happens, the default behavior depends on whether the failed edit is part of a token definition, or instead part of a string builder. If the edit is part of the token definition, it will cause the entire citation to fail as if it had never matched the template in the first place. On the other hand, if the token is being used in a string builder, failure will simply cause the affected token's value to be set to null for purposes of the string builder. You can change the default behavior by adding the following tag to an edit: mandatory: no . If an edit with this tag fails, the edit will simply be ignored. For instance, the following \"reporter\" token can be any string of up to ten characters, but if it is \"F. Supp.\" or \"P. 2d\" it will be replaced with \"F.Supp.\" or \"P.2d\", respectively. Because the lookup is tagged as not mandatory, tokens that don't match either of these strings will be unaffected. Without that tag, the entire citation would be discarded if it did not match either of those values. ... tokens : reporter : regex : .{1,10} edits : - mandatory : no lookup : F\\. ?Supp\\. : F.Supp. P\\. ?2d : P.2d ...","title":"Failed Edits"},{"location":"template-yamls/#chaining-multiple-edits","text":"Edits can be chained, and they will take effect in the order they are listed. For instance, if you wanted to store the article numbers as lower-case Roman numerals, you could do this: tokens : article : regex : [ 1-7 ]| [IV]{1,3}|One|Two|Three|Four|Five|Six|Seven edits : - number style : roman - case : lower","title":"Chaining Multiple Edits"},{"location":"template-yamls/#severability","text":"Ordinarily, if two citations both have a token and that token differs between the two of them, the two citations are thought to be completely unrelated. For instance, \"33 USC \u00a7 10\" is a totally different law than \"33 USC \u00a7 100\", even though \"100\" starts with \"10\". However, sometimes it is relevant that one token begins with the same value as another. For instance, the Code of Federal Regulations template has a \"subsection\" token that matches a sequence of one or more numbers or letters in parentheses. But ordinarily, CiteURL would treat \"21 CFR \u00a7 820.1(a)\" and \"21 CFR \u00a7 820.1(a)(1)\" as totally unrelated subsections since \"(a)\" is not the same as \"(a)(1)\". This is wrong, since the former citation encompasses the latter. To handle these situations, tokens can be given the severable: yes tag, to indicate that when the only difference between two citations is that the second one has a severable token that extends longer than the first one's, the first citation is thought to include the second one. ... tokens : subsection : regex : '(\\(\\w{1,4}\\))+' severable : yes ... Note that the severable tag is unnecessary when the difference is that one citation is simply missing a possible token. For instance, \"U.S. Const. Article III\" is known to include \"U.S. Const. Article III, \u00a7 2\" just because the U.S. Constitution template defines the article token before the section token.","title":"Severability"},{"location":"template-yamls/#default-values","text":"Often a citation may be valid even if it does not contain all tokens that it possibly could. For instance, a citation to a court opinion may or may not have a pincite to a specific page. Normally, when such a token is omitted, its value is None . However, you can also specify a different default value if you wish: ... tokens : section : regex : \\d+ default : '1' ...","title":"Default Values"},{"location":"template-yamls/#patterns","text":"Patterns are essentially the regular expressions that a template uses to detect overall citations. However, a pattern is not a pure regex---instead of including a regex for each token the pattern can recognize, the pattern simply contains a reference to the token itself. This is useful as a way to avoid redefining a token's regex when it is used in multiple patterns. As such. A template's patterns are responsible for recognizing one or more formats of typical long-form citations to the given body of law. In addition to these, a template can also have shortform patterns and idform patterns , which are triggered once a longform citation has already been recognized. When this occurs, CiteURL looks for \"idform\" citations until it encounters a different intervening citation, and it looks for shortforms anywhere until the end of the document. In addition, a template can have broad patterns , which are exactly like longform patterns except that they are only used in search engine-like contexts, where user convenience is more important than avoiding false positives.","title":"Patterns"},{"location":"template-yamls/#pattern-format","text":"Regardless of the type of pattern, they share a few key points of formatting. First, it is possible to specify patterns either in singular form or in list form. For instance, either of these would be valid: ... pattern : '{volume} USC \u00a7 {section}' ... ... patterns : - '{volume USC (\u00a7|[Ss]ec(tion|t?\\.) {section}' - '(\u00a7|[Ss]ec(tion|t?\\.) {section} of [Vv]olume {volume} of the U\\.S\\. Code' ... This is not to be confused with another feature of patterns: An individual pattern can be provided either as a single string, or as a list of strings. This is useful so that you can take advantage of YAML anchors to avoid rewriting certain common bits of regex. Consider the following example: ... patterns : - [ '{volume} USC ' , &sec_sign '(\u00a7|[Ss]ec(tion|t?\\.)' , ' {section}' ] - [ *sec_sign , ' {section} of [Vv]olume {volume} of the U\\.S\\. Code' ] ... The above example defines a YAML anchor called sec_sign to represent any string that is either \"\u00a7\", \"Section\", or various abbreviations thereof. Because it would be a pain to write that string repeatedly across a large number of templates, it's useful to reuse it as a YAML anchor. Although each pattern is broken into a list, it is functionally equivalent to the previous example.","title":"Pattern Format"},{"location":"template-yamls/#shortforms-and-idforms","text":"These two types of patterns are intended to recognize contextual references to a citation that was found previously in the text. To facilitate this, they both share one special feature: Values from their parent longform citation can be inserted into the shortform pattern so as to only match when the specified value is the same. Consider the following example: U.S. Caselaw : tokens : reporter : { regex : . { 3 , 10 }} volume : { regex : \\d+ } page : { regex : \\d+ } pincite : { regex : \\d+ } pattern : '{volume} {reporter} {page}(, {pincite})?' shortform pattern : '{same volume} {same reporter} at {pincite}' idform pattern : 'Id\\. at {pincite}' This template will recognize longform citations like \"413 F. Supp. 1281\". Once it has found such a citation, it can detect immediate repeat citations like \" Id. at <any number>\", because of its idform pattern . The shortform pattern , meanwhile, will match any subsequent occurrence of \"413 F. Supp. <any number>\" anywhere in the text.","title":"Shortforms and Idforms"},{"location":"template-yamls/#string-builders","text":"The two kinds of string builder are a template's name builder and its URL builder , and they both work the same way. They use a citation's tokens to fill placeholders in a pattern and output a uniform string representation of that citation. This is the source of each citation's name and URL properties. A string builder is made up of one or more parts , and optionally a list of edits . The first value, parts , is a list of strings that will be concatenated to make the result. Each part can contain placeholder values in curly braces. The placeholders will be replaced with the corresponding token values or metadata values. If a part references a blank token, that part will be omitted from the overall string. edits is a list of token edits that will be performed on the tokens and metadata just before they are inserted into the string. They work just like the token edits described earlier, except for two differences. First, whereas the edits described earlier serve to normalize tokens after they are matched in text, these ones are only used in order to build a string---they do not permanently modify the underlying tokens. Second, because these edits are not listed by token, you must specify which token each one operates on, by giving it a token value. You can also optionally give it an output value, in which the result of the edit will be saved to the specified token instead of modifying the input. Here's an example of each kind of string builder: U.S. Code : ... name builder : parts : - '{title} U.S.C. \u00a7 {section}' - '{subsection}' URL builder : parts : - https://www.law.cornell.edu/uscode/text/{title}/{section} - '#{subsection}' edits : - token : subsection sub : [ '\\)\\(' , '_' ] - token : subsection sub : [ '[()]' , '' ] If this template is given the citation, \"42 usc 1988\", the name builder will use the title and section numbers to write \"42 U.S.C. \u00a7 1983\". The '{subsection}' part is omitted because the citation has no subsection. Likewise, the URL builder will make this URL , ignoring the blank token and the edits that rely on it. Given the citation \"29 USC \u00a7 158(b)(4)\", however, the URL builder will take the subsection and subject it to two edits, first to change it from '(b)(4)' to '(b_4)', and then to change that to 'b_4'. Having done that, it can fill in the '#{subsection}' part, and create this URL .","title":"String Builders"},{"location":"template-yamls/#miscellaneous","text":"The following features aren't crucial to what a template is, or what it does, but they're nice to have when you're trying to write a whole lot of templates without reinventing the wheel too many times.","title":"Miscellaneous"},{"location":"template-yamls/#metadata","text":"A template can have a meta attribute that contains a dictionary of values that will be accessible to the template's patterns and string builders just like a token is. Note that token edits in string builders can override metadata values using the output tag.","title":"Metadata"},{"location":"template-yamls/#template-inheritance","text":"A template can inherit any already-defined template, such that it will copy any characteristics of that template except for those that are expressly overwritten. This is useful when two templates are both very, very complicated, but they are largely similar in format. For instance, citations to the Code of Federal Regulations are very similar to the U.S. code, so most of this horrible mess only needs to be written once: U.S. Code : meta : name regex : 'U\\. ?S\\. ?C(ode|\\.)|USC|United States Code' abbreviation : U.S.C. tokens : title : { regex : \\d+ } section : { regex : '\\d[\\w.-]*\\w|\\d' } subsection : regex : '(\\(\\w{1,4}\\))+' severable : yes patterns : - - &title ([Tt]itle )?{title} - ',? {name regex}(,? )?(' - &section_sign ((&sect;|&#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.)) - ')? ?{section}' - &subsec '(((,? )?sub(sections?|divisions?|(sec|d(iv)?)?s?\\.))? ?{subsection})?' - [ '[Tt]itle {title},? (' , *section_sign , ')? ?{section}' , *subsec , ' of the {name regex}' ] - [ '(' , *section_sign , ')? ?{section}' , *subsec , ' of [Tt]itle {title} of the {name regex}' ] idform patterns : - '[Ii]d\\.( at)?( \u00a7\u00a7?)? ?{section}( ?{subsection})?' - '((&sect;|&#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.)) {section}( ?{subsection})?(?! of)' - '[Ii]d\\. at {subsection}' name builder : parts : - '{title} {abbreviation} \u00a7 {section}' - '{subsection}' URL builder : parts : - https://www.law.cornell.edu/uscode/text/{title}/{section} - '#{subsection}' edits : - token : subsection sub : [ '\\)\\(' , '_' ] - token : subsection sub : [ '[()]' , '' ] Code of Federal Regulations : inherit : U.S. Code meta : name regex : 'C\\.? ?F\\.? ?R\\.?|Code of Federal Regulations' abbreviation : C.F.R. URL builder : parts : - 'https://ecfr.federalregister.gov/cfr-reference?cfr%5Bdate%5D=current&cfr%5Breference%5D={title} CFR {section} '' - ' #p-{section}{subsection}'","title":"Template Inheritance"}]}