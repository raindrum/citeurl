{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>CiteURL is an extensible tool that parses legal citations and makes links to websites where you can read the relevant law for free. It can be used to quickly look up a reference, or to insert a hyperlink for every long- or short-form citation found in a longer text.</p> <p>If you want to quickly try it out, it's available as a web app at citation.link.</p> <p>Here's a sample of the links CiteURL can make:</p> <p>Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78.</p> <p>By default, CiteURL supports Bluebook-style citations to over 130 sources of U.S. law, including:</p> <ul> <li>most reported state and federal court opinions</li> <li>the U.S. Code and Code of Federal Regulations</li> <li>the U.S. Constitution and all state constitutions</li> <li>the codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico.</li> </ul> <p>You can also add more sources of law by writing your own citation templates in YAML format.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install just enough to make CiteURL work, run this command:</p> <pre><code>python3 -m pip install citeurl\n</code></pre> <p>Substitute <code>citeurl[full]</code> for <code>citeurl</code> if you want to install the optional dependencies <code>flask</code> and <code>appdirs</code>, necessary for hosting citeurl as a website and reading custom templates from the user's home directory.</p>"},{"location":"#usage","title":"Usage","text":"<p>CiteURL provides four command-line tools:</p> <ul> <li><code>citeurl process</code>: Parse a text and insert an HTML hyperlink for every citation it contains, including shortform citations.</li> <li><code>citeurl lookup</code>: Look up a single citation and display information about it.</li> <li><code>citeurl host</code>: Host an instance of CiteURL as a web app like citation.link.</li> <li><code>citeurl makejs</code>: Export an instance of CiteURL's lookup feature as JavaScript or a static web page. More info is available here.</li> </ul> <p>Each command has its own command-line arguments you can view with the <code>-h</code> option. They all share the <code>-t</code> option, which allows you to load a list of custom citation templates in YAML form.</p> <p>Here are a few common use cases:</p> <pre><code># Process a court opinion and output a version where each citation is hyperlinked:\nciteurl process -i INPUT_FILE.html -o OUTPUT_FILE.html\n</code></pre> <pre><code># Look up a single citation and open it directly in a browser\nciteurl lookup \"42 USC 1983\" -b\n</code></pre> <pre><code># List the top ten authorities cited in a text, from most citations to least:\ncat INPUT_FILE.html | citeurl process -a 10\n</code></pre> <pre><code># Host a lookup tool with custom templates, and serve it on the local network:\nciteurl host -t PATH_TO_YOUR_TEMPLATES.YAML -s\n</code></pre> <p>CiteURL is also available in a few other forms besides the command-line tool: </p> <ul> <li>citation.link, the web app</li> <li>a flexible Python library</li> <li>an extension to Python-Markdown</li> <li>a desktop search provider for Linux users with the GNOME shell</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>Many thanks to these websites, which CiteURL's default templates frequently link to:</p> <ul> <li>Harvard's Caselaw Access Project - for most court cases</li> <li>CourtListener - for other court cases</li> <li>Cornell's Legal Information Institute - for the U.S. Code and many federal rules</li> <li>Ballotpedia - for the vast majority of state constitutions</li> <li>LawServer.com - for statutes in about a dozen states and territories whose websites don't have a compatible URL scheme</li> </ul>"},{"location":"frontends/","title":"CiteURL Frontends","text":"<p>CiteURL can be used in a few forms besides the command-line tool and the Python library. Here's what they are:</p>"},{"location":"frontends/#citeurl-server","title":"CiteURL Server","text":"<p>If you just want to use CiteURL from your web browser, it's hosted as a web app at citation.link.</p> <p>You can also host your own instance of it on your local network or beyond. This is useful if you want to add support for your own custom citation templates. The simplest way is to run this command:</p> <pre><code>citeurl host -st PATH_TO_YOUR_TEMPLATES.YAML\n</code></pre> <p>Or, if you're using a hosting provider like pythonanywhere.com, you can give it direct access to CiteURL as a Flask application:</p> <pre><code>from citeurl.web.server import App\nfrom citeurl import Citator\n\nAPP = App(Citator(yaml_paths=['PATH_TO_YOUR_TEMPLATES.YAML']))\n</code></pre>"},{"location":"frontends/#javascript","title":"JavaScript","text":"<p>Although CiteURL is primarily a Python program, you can also use it to generate a JavaScript implementation of its citation lookup functionality, including any extra citation templates you've written. This allows it to be hosted on a static website (like mine, for example), or distributed as an HTML file that people can save to their own computers and bookmark as a custom search engine.</p> <p>To make a JavaScript implementation, first make a YAML file with any custom citation templates you'd like to support. Next, open a command line and run the following command:</p> <pre><code>citeurl makejs -e -o output.html -t PATH_TO_YOUR_TEMPLATES.YAML\n</code></pre> <p>Alternatively, to omit CiteURL's default templates, include the <code>-n</code> option in that command. For more info, run <code>citeurl makejs -h</code>.</p>"},{"location":"frontends/#markdown-extension","title":"Markdown Extension","text":"<p>CiteURL can also be used as an extension to Python-Markdown. You can load the extension as <code>citeurl</code>, and it supports the following options:</p> <ul> <li><code>custom_templates</code>: A list of paths to YAML files containing custom citation templates. Defaults to none.</li> <li><code>use_defaults</code>: Whether CiteURL should load the default citation templates. Defaults to <code>True</code>.</li> <li><code>attributes</code>: A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to <code>{'class': 'citation'}</code>.</li> <li><code>redundant_links</code>: Whether to insert a link even when its URL would be the same as the last one.</li> <li><code>URL_optional</code>: Whether to insert a link even when it doesn't have a URL.</li> <li><code>break_id_on_regex</code>: Anywhere this string (parsed as regex) appears in the text, chains of citations like <code>id.</code> will be interrupted. Note that this is based on the output HTML, not the original Markdown text. Defaults to <code>L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst)</code></li> <li><code>ignore_markup</code>: Whether CiteURL should detect citations even when they are interrupted by markup, like \"\\Id.\\ at 37.\" Defaults to <code>True</code>.</li> </ul>"},{"location":"frontends/#gnome-shell-search-provider","title":"GNOME Shell Search Provider","text":"<p>If you use the GNOME desktop environment, you can install my other project to look up citations directly from your desktop!</p>"},{"location":"library/","title":"Library Reference","text":"<p>This page documents how to include CiteURL in your Python programming projects.</p> <p>The first step is to instantiate a Citator, which by default contains all of CiteURL's built-in Templates:</p> <pre><code>from citeurl import Citator\ncitator = Citator()\n</code></pre> <p>After that, you can feed it text to return a list of Citations it finds:</p> <pre><code>text = \"\"\"\nFederal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78.\n\"\"\"\ncitations = citator.list_cites(text)\n</code></pre> <p>Once you have a list of citations, you can get information about each one:</p> <pre><code>print(citations[0].text)\n# 42 USC \u00a7 1988(b)\nprint(citations[0].tokens)\n# {'Title': '42', 'Section': '1988', 'subsection': '(b)'}\nprint(citations[0].URL)\n# https://www.law.cornell.edu/uscode/text/42/1988#b\n</code></pre> <p>You can also compare citations to one another, to determine whether they reference the same material or a subsection thereof:</p> <pre><code>art_I = citator.cite('U.S. Const. Art. I')\nalso_art_I = citator.cite('Article I of the U.S. Constitution')\nart_I_sec_3 = citator.cite('U.S. Const. Art. I, \u00a7 3')\n\nassert art_I == also_art_I\nassert art_I_sec_3 in art_I\n</code></pre> <p>If you don't want to bother with all the details, you can also just use insert_links() to turn all the citations in a text into hyperlinks:</p> <pre><code>from citeurl import insert_links\n\ntext = \"42 USC \u00a7 1988. &lt;i&gt;Id.&lt;/i&gt; at (b).\"\noutput = insert_links(text)\n\nassert output == '&lt;a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988\" title=\"42 U.S.C. \u00a7 1988\"&gt;42 USC \u00a7 1988&lt;/a&gt;. &lt;a class=\"citation\" href=\"https://www.law.cornell.edu/uscode/text/42/1988#b\" title=\"42 U.S.C. \u00a7 1988(b)\"&gt;&lt;i&gt;Id.&lt;/i&gt; at (b)&lt;/a&gt;.'\n</code></pre>"},{"location":"library/#citator","title":"Citator","text":"<p>A collection of citation templates, and the tools to match text against them en masse.</p> <p>Attributes:</p> Name Type Description <code>templates</code> <p>a dictionary of citation templates that this citator will try to match against</p> Source code in <code>citeurl/citator.py</code> <pre><code>class Citator:\n    \"\"\"\n    A collection of citation templates, and the tools to match text\n    against them en masse.\n\n    Attributes:\n        templates: a dictionary of citation templates that this citator\n            will try to match against\n    \"\"\"\n\n    def __init__(\n        self,\n        defaults = [\n            'caselaw',\n            'general federal law',\n            'specific federal laws',\n            'state law',\n            'secondary sources',\n        ],\n        yaml_paths: list[str] = [],\n        templates: dict[str, Template] = {},\n    ):\n        \"\"\"\n        Create a citator from any combination of CiteURL's default\n        template sets (by default, all of them), plus any custom\n        templates you want, either by pointing to custom YAML files or\n        making Template objects at runtime.\n\n        Arguments:\n            defaults: names of files to load from the citeurl/templates\n                folder. Each file contains one or more of CiteURL's\n                built-in templates relevant to the given topic.\n            yaml_paths: paths to custom YAML files to load templates\n                from. These are loaded after the defaults, so they can\n                inherit and/or overwrite them. If \n            templates: optional list of Template objects to load\n                directly. These are loaded last, after the defaults and\n                any yaml_paths.\n        \"\"\"\n        self.templates = {}\n\n        yamls_path = Path(__file__).parent.absolute() / 'templates'    \n        for name in defaults or []:\n            yaml_file = yamls_path / f'{name}.yaml'\n            self.load_yaml(yaml_file.read_text())\n\n        for path in yaml_paths:\n            self.load_yaml(Path(path).read_text())\n        self.templates.update(templates)\n\n    @classmethod\n    def from_yaml(cls, yaml: str):\n        \"\"\"\n        Create a citator from scratch (i.e. without the default\n        templates) by loading templates from the specified YAML string.\n        \"\"\"\n        citator = cls(defaults=None)\n        citator.load_yaml(yaml)\n        return citator\n\n    def to_yaml(self):\n        \"Save this citator to a YAML string to load later\"\n        yamls = [t.to_yaml() for t in self.templates.values()]\n        return '\\n\\n'.join(yamls)\n\n    def load_yaml(self, yaml: str):\n        \"\"\"\n        Load templates from the given YAML, overwriting any existing\n        templates with the same name.\n        \"\"\"\n        for name, data in safe_load(yaml).items():\n            self.templates[name] = Template.from_dict(\n                name, data, inheritables=self.templates\n            )\n\n    def cite(self, text: str, broad: bool=True) -&gt; Citation:\n        \"\"\"\n        Check the given text against each of the citator's templates and\n        return the first citation detected, or None.\n\n        If broad is true, matching is case-insensitive and each\n        template's broad regexes are used in addition to its normal\n        regexes.\n        \"\"\"\n        for template in self.templates.values():\n            cite = template.cite(text, broad=broad)\n            if cite:\n                return cite\n        else:\n            return None\n\n    def list_cites(\n        self,\n        text: str,\n        id_breaks: re.Pattern = None,\n    ) -&gt; list[Citation]:\n        \"\"\"\n        Find all citations in the given text, whether longform,\n        shortform, or idform. They will be listed in order of\n        appearance. If any two citations overlap, the shorter one will\n        be deleted. \n\n        Wherever the id_breaks pattern appears, it will interrupt chains\n        of id-form citations. This is helpful for handling unrecognized\n        citations that would otherwise cause CiteURL's notion of \"id.\"\n        to get out of sync with what the text is talking about.\n        \"\"\"\n        # first get a list of all long and shortform (not id.) citations\n        longforms = []\n        for template in self.templates.values():\n            longforms += template.list_longform_cites(text)\n\n        shortforms = []\n        for citation in longforms:\n            shortforms += citation.get_shortform_cites()\n\n        citations = longforms + shortforms\n        _sort_and_remove_overlaps(citations)\n\n        # Figure out where to interrupt chains of idform citations,\n        # i.e. anywhere a longform or shortform citation starts, plus\n        # the start of any substring that matches the id_breaks pattern\n        breakpoints = [c.span[0] for c in citations]\n        if id_breaks:\n            breakpoints += [\n                match.span()[0] for match in\n                id_breaks.finditer(text)\n            ]\n        breakpoints = sorted(set(breakpoints))\n        breakpoints.append(len(text))\n\n        # for each cite, look for idform citations until the next cite\n        # or until the next breakpoint\n        idforms = []\n        for cite in citations:\n            # find the next relevant breakpoint, and delete any\n            # breakpoints that are already behind the current citation\n            for i, breakpoint in enumerate(breakpoints):\n                if breakpoint &gt;= cite.span[1]:\n                    breakpoints = breakpoints[i:]\n                    break\n            try:\n                breakpoint = breakpoints[0]\n            except IndexError:\n                breakpoint = None\n\n            # find the first idform reference to the citation, then the\n            # first idform reference to that idform, and so on, until\n            # the breakpoint\n            idform = cite.get_idform_cite(until_index=breakpoint)\n            while idform:\n                idforms.append(idform)\n                idform = idform.get_idform_cite(until_index=breakpoint)\n\n        citations += idforms\n        _sort_and_remove_overlaps(citations)\n        return citations\n\n    def list_authorities(\n        self,\n        text: str,\n        ignored_tokens = ['subsection', 'clause', 'pincite', 'paragraph'],\n        known_authorities: list = [],\n        sort_by_cites: bool = True,\n        id_breaks: re.Pattern = None,\n    ) -&gt; list[Authority]:\n        \"\"\"\n        Find each distinct authority mentioned in the given text, and \n        return Authority objects whose `citations` attribute lists the\n        references to each.\n\n        Arguments:\n            text: The string to be scanned for citations\n            ignored_tokens: the names of tokens whose values are\n                irrelevant to whether the citation matches an authority,\n                because they  just designate portions within a single\n                authority\n            sort_by_cites: Whether to sort the resulting list of\n                authorities by the number of citations to each one\n        \"\"\"\n        cites = self.list_cites(text, id_breaks=id_breaks)\n        return list_authorities(\n            cites,\n            ignored_tokens = ignored_tokens,\n            known_authorities = known_authorities,\n            sort_by_cites = sort_by_cites,\n        )        \n\n    def insert_links(\n        self,\n        text: str,\n        attrs: dict = {'class': 'citation'},\n        add_title: bool = True,\n        URL_optional: bool = False,\n        redundant_links: bool = True,\n        id_breaks: re.Pattern = None,\n        ignore_markup: bool = True,\n        markup_format = 'html',\n    ) -&gt; str:\n        \"\"\"\n        Scan a text for citations, and return a text with each citation\n        converted to a hyperlink.\n\n        Arguments:\n            text: the string to scan for citations.\n            attrs: various HTML link attributes to give to each link.\n                Only relevant when markup_format is html\n            add_title: whether to use citation.name for link titles.\n                Only relevant when markup_format is html\n            URL_optional: whether to insert an &lt;a&gt; element even when the\n                citation does not have an associated URL. Only relevant\n                when markup_format is html; in markdown a link needs a\n                URL.\n            redundant_links: whether to insert a hyperlink if it would\n                point to the same URL as the previous link\n            id_breaks: wherever this regex appears, interrupt chains of\n                \"Id.\"-style citations.\n            ignore_markup: whether to preprocess and postprocess the\n                text so that CiteURL can detect citations even when\n                they contain inline markup, like \"&lt;i&gt;Id.&lt;/i&gt; at 32\"\n            markup_format: Either 'html' or 'markdown'. Determines\n                what markup to ignore, and also what format to use\n                for inserted links.\n\n        Returns:\n            text, with an HTML `a` element for each citation. \n        \"\"\"\n\n        # pull out all the inline HTML tags, e.g. &lt;b&gt;,\n        # so they don't interfere with citation matching\n        if ignore_markup:\n            text, stored_tags = _strip_inline_tags(text, markup_format)\n\n        cite_offsets = []\n        running_offset = 0\n\n        last_URL = None\n        for cite in self.list_cites(text, id_breaks = id_breaks):\n            if markup_format == 'html':\n                attrs['href'] = cite.URL\n                if not cite.URL and not URL_optional:\n                    continue\n                if not redundant_links and cite.URL == last_URL:\n                    continue\n                if add_title:\n                    attrs['title'] = cite.name\n\n                attr_str = ''.join([\n                    f' {k}=\"{v}\"'\n                    for k, v in attrs.items() if v\n                ])\n                link = f'&lt;a{attr_str}&gt;{cite.text}&lt;/a&gt;'\n            elif markup_format == 'markdown':\n                link = f'[{cite.text}]({cite.URL})'\n            else:\n                raise NotImplementedError()\n\n            cite_offset = len(link) - len(cite.text)   \n            cite_offsets.append((\n                cite.span[0], # beginning of citation\n                cite_offset,  # length the citation markup adds\n                cite.text,    # the text that was picked up as citation\n            ))\n\n            span = (\n                cite.span[0] + running_offset,\n                cite.span[1] + running_offset\n            )\n\n            text = text[:span[0]] + link + text[span[1]:]\n\n            running_offset += cite_offset\n            last_URL = cite.URL\n\n        if ignore_markup:\n            running_offset = 0\n            for tag in stored_tags:\n                temp_offset = 0\n                while len(cite_offsets) &gt; 0:\n                    # only offset by a cite if the tag\n                    # is after the cite start\n                    if tag[1] &gt;= cite_offsets[0][0]:\n                        offset = cite_offsets[0]\n                        # check if the tag is after the cite end\n                        tag_start = tag[1]\n                        cite_end = offset[0] + len(offset[2])\n\n                        if tag_start &gt;= cite_end:\n                            running_offset += offset[1]\n                            cite_offsets.pop(0)\n                        else:\n                            if markup_format == 'html':\n                                temp_offset = offset[1] - 4\n                            elif markup_format == 'markdown':\n                                temp_offset = 1\n                            break\n                    else:\n                        break\n                tag_pos = tag[1] + running_offset + temp_offset\n\n                text = text[:tag_pos] + tag[0] + text[tag_pos:]\n\n                running_offset += tag[2]\n\n        return text\n\n    def __iter__(self):\n        return self.templates.values().__iter__()\n\n    def __getitem__(self, key):\n        return self.templates[key]\n\n    def __setitem__(self, key, value):\n        self.templates[key] = value\n\n    def __eq__(self, other_citator):\n        return self.templates == other_citator.templates\n</code></pre>"},{"location":"library/#citeurl.Citator.__init__","title":"<code>__init__(defaults=['caselaw', 'general federal law', 'specific federal laws', 'state law', 'secondary sources'], yaml_paths=[], templates={})</code>","text":"<p>Create a citator from any combination of CiteURL's default template sets (by default, all of them), plus any custom templates you want, either by pointing to custom YAML files or making Template objects at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <p>names of files to load from the citeurl/templates folder. Each file contains one or more of CiteURL's built-in templates relevant to the given topic.</p> <code>['caselaw', 'general federal law', 'specific federal laws', 'state law', 'secondary sources']</code> <code>yaml_paths</code> <code>list[str]</code> <p>paths to custom YAML files to load templates from. These are loaded after the defaults, so they can inherit and/or overwrite them. If </p> <code>[]</code> <code>templates</code> <code>dict[str, Template]</code> <p>optional list of Template objects to load directly. These are loaded last, after the defaults and any yaml_paths.</p> <code>{}</code> Source code in <code>citeurl/citator.py</code> <pre><code>def __init__(\n    self,\n    defaults = [\n        'caselaw',\n        'general federal law',\n        'specific federal laws',\n        'state law',\n        'secondary sources',\n    ],\n    yaml_paths: list[str] = [],\n    templates: dict[str, Template] = {},\n):\n    \"\"\"\n    Create a citator from any combination of CiteURL's default\n    template sets (by default, all of them), plus any custom\n    templates you want, either by pointing to custom YAML files or\n    making Template objects at runtime.\n\n    Arguments:\n        defaults: names of files to load from the citeurl/templates\n            folder. Each file contains one or more of CiteURL's\n            built-in templates relevant to the given topic.\n        yaml_paths: paths to custom YAML files to load templates\n            from. These are loaded after the defaults, so they can\n            inherit and/or overwrite them. If \n        templates: optional list of Template objects to load\n            directly. These are loaded last, after the defaults and\n            any yaml_paths.\n    \"\"\"\n    self.templates = {}\n\n    yamls_path = Path(__file__).parent.absolute() / 'templates'    \n    for name in defaults or []:\n        yaml_file = yamls_path / f'{name}.yaml'\n        self.load_yaml(yaml_file.read_text())\n\n    for path in yaml_paths:\n        self.load_yaml(Path(path).read_text())\n    self.templates.update(templates)\n</code></pre>"},{"location":"library/#citeurl.Citator.cite","title":"<code>cite(text, broad=True)</code>","text":"<p>Check the given text against each of the citator's templates and return the first citation detected, or None.</p> <p>If broad is true, matching is case-insensitive and each template's broad regexes are used in addition to its normal regexes.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def cite(self, text: str, broad: bool=True) -&gt; Citation:\n    \"\"\"\n    Check the given text against each of the citator's templates and\n    return the first citation detected, or None.\n\n    If broad is true, matching is case-insensitive and each\n    template's broad regexes are used in addition to its normal\n    regexes.\n    \"\"\"\n    for template in self.templates.values():\n        cite = template.cite(text, broad=broad)\n        if cite:\n            return cite\n    else:\n        return None\n</code></pre>"},{"location":"library/#citeurl.Citator.from_yaml","title":"<code>from_yaml(yaml)</code>  <code>classmethod</code>","text":"<p>Create a citator from scratch (i.e. without the default templates) by loading templates from the specified YAML string.</p> Source code in <code>citeurl/citator.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml: str):\n    \"\"\"\n    Create a citator from scratch (i.e. without the default\n    templates) by loading templates from the specified YAML string.\n    \"\"\"\n    citator = cls(defaults=None)\n    citator.load_yaml(yaml)\n    return citator\n</code></pre>"},{"location":"library/#citeurl.Citator.insert_links","title":"<code>insert_links(text, attrs={'class': 'citation'}, add_title=True, URL_optional=False, redundant_links=True, id_breaks=None, ignore_markup=True, markup_format='html')</code>","text":"<p>Scan a text for citations, and return a text with each citation converted to a hyperlink.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the string to scan for citations.</p> required <code>attrs</code> <code>dict</code> <p>various HTML link attributes to give to each link. Only relevant when markup_format is html</p> <code>{'class': 'citation'}</code> <code>add_title</code> <code>bool</code> <p>whether to use citation.name for link titles. Only relevant when markup_format is html</p> <code>True</code> <code>URL_optional</code> <code>bool</code> <p>whether to insert an  element even when the citation does not have an associated URL. Only relevant when markup_format is html; in markdown a link needs a URL. <code>False</code> <code>redundant_links</code> <code>bool</code> <p>whether to insert a hyperlink if it would point to the same URL as the previous link</p> <code>True</code> <code>id_breaks</code> <code>Pattern</code> <p>wherever this regex appears, interrupt chains of \"Id.\"-style citations.</p> <code>None</code> <code>ignore_markup</code> <code>bool</code> <p>whether to preprocess and postprocess the text so that CiteURL can detect citations even when they contain inline markup, like \"Id. at 32\"</p> <code>True</code> <code>markup_format</code> <p>Either 'html' or 'markdown'. Determines what markup to ignore, and also what format to use for inserted links.</p> <code>'html'</code> <p>Returns:</p> Type Description <code>str</code> <p>text, with an HTML <code>a</code> element for each citation.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def insert_links(\n    self,\n    text: str,\n    attrs: dict = {'class': 'citation'},\n    add_title: bool = True,\n    URL_optional: bool = False,\n    redundant_links: bool = True,\n    id_breaks: re.Pattern = None,\n    ignore_markup: bool = True,\n    markup_format = 'html',\n) -&gt; str:\n    \"\"\"\n    Scan a text for citations, and return a text with each citation\n    converted to a hyperlink.\n\n    Arguments:\n        text: the string to scan for citations.\n        attrs: various HTML link attributes to give to each link.\n            Only relevant when markup_format is html\n        add_title: whether to use citation.name for link titles.\n            Only relevant when markup_format is html\n        URL_optional: whether to insert an &lt;a&gt; element even when the\n            citation does not have an associated URL. Only relevant\n            when markup_format is html; in markdown a link needs a\n            URL.\n        redundant_links: whether to insert a hyperlink if it would\n            point to the same URL as the previous link\n        id_breaks: wherever this regex appears, interrupt chains of\n            \"Id.\"-style citations.\n        ignore_markup: whether to preprocess and postprocess the\n            text so that CiteURL can detect citations even when\n            they contain inline markup, like \"&lt;i&gt;Id.&lt;/i&gt; at 32\"\n        markup_format: Either 'html' or 'markdown'. Determines\n            what markup to ignore, and also what format to use\n            for inserted links.\n\n    Returns:\n        text, with an HTML `a` element for each citation. \n    \"\"\"\n\n    # pull out all the inline HTML tags, e.g. &lt;b&gt;,\n    # so they don't interfere with citation matching\n    if ignore_markup:\n        text, stored_tags = _strip_inline_tags(text, markup_format)\n\n    cite_offsets = []\n    running_offset = 0\n\n    last_URL = None\n    for cite in self.list_cites(text, id_breaks = id_breaks):\n        if markup_format == 'html':\n            attrs['href'] = cite.URL\n            if not cite.URL and not URL_optional:\n                continue\n            if not redundant_links and cite.URL == last_URL:\n                continue\n            if add_title:\n                attrs['title'] = cite.name\n\n            attr_str = ''.join([\n                f' {k}=\"{v}\"'\n                for k, v in attrs.items() if v\n            ])\n            link = f'&lt;a{attr_str}&gt;{cite.text}&lt;/a&gt;'\n        elif markup_format == 'markdown':\n            link = f'[{cite.text}]({cite.URL})'\n        else:\n            raise NotImplementedError()\n\n        cite_offset = len(link) - len(cite.text)   \n        cite_offsets.append((\n            cite.span[0], # beginning of citation\n            cite_offset,  # length the citation markup adds\n            cite.text,    # the text that was picked up as citation\n        ))\n\n        span = (\n            cite.span[0] + running_offset,\n            cite.span[1] + running_offset\n        )\n\n        text = text[:span[0]] + link + text[span[1]:]\n\n        running_offset += cite_offset\n        last_URL = cite.URL\n\n    if ignore_markup:\n        running_offset = 0\n        for tag in stored_tags:\n            temp_offset = 0\n            while len(cite_offsets) &gt; 0:\n                # only offset by a cite if the tag\n                # is after the cite start\n                if tag[1] &gt;= cite_offsets[0][0]:\n                    offset = cite_offsets[0]\n                    # check if the tag is after the cite end\n                    tag_start = tag[1]\n                    cite_end = offset[0] + len(offset[2])\n\n                    if tag_start &gt;= cite_end:\n                        running_offset += offset[1]\n                        cite_offsets.pop(0)\n                    else:\n                        if markup_format == 'html':\n                            temp_offset = offset[1] - 4\n                        elif markup_format == 'markdown':\n                            temp_offset = 1\n                        break\n                else:\n                    break\n            tag_pos = tag[1] + running_offset + temp_offset\n\n            text = text[:tag_pos] + tag[0] + text[tag_pos:]\n\n            running_offset += tag[2]\n\n    return text\n</code></pre>"},{"location":"library/#citeurl.Citator.list_authorities","title":"<code>list_authorities(text, ignored_tokens=['subsection', 'clause', 'pincite', 'paragraph'], known_authorities=[], sort_by_cites=True, id_breaks=None)</code>","text":"<p>Find each distinct authority mentioned in the given text, and  return Authority objects whose <code>citations</code> attribute lists the references to each.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to be scanned for citations</p> required <code>ignored_tokens</code> <p>the names of tokens whose values are irrelevant to whether the citation matches an authority, because they  just designate portions within a single authority</p> <code>['subsection', 'clause', 'pincite', 'paragraph']</code> <code>sort_by_cites</code> <code>bool</code> <p>Whether to sort the resulting list of authorities by the number of citations to each one</p> <code>True</code> Source code in <code>citeurl/citator.py</code> <pre><code>def list_authorities(\n    self,\n    text: str,\n    ignored_tokens = ['subsection', 'clause', 'pincite', 'paragraph'],\n    known_authorities: list = [],\n    sort_by_cites: bool = True,\n    id_breaks: re.Pattern = None,\n) -&gt; list[Authority]:\n    \"\"\"\n    Find each distinct authority mentioned in the given text, and \n    return Authority objects whose `citations` attribute lists the\n    references to each.\n\n    Arguments:\n        text: The string to be scanned for citations\n        ignored_tokens: the names of tokens whose values are\n            irrelevant to whether the citation matches an authority,\n            because they  just designate portions within a single\n            authority\n        sort_by_cites: Whether to sort the resulting list of\n            authorities by the number of citations to each one\n    \"\"\"\n    cites = self.list_cites(text, id_breaks=id_breaks)\n    return list_authorities(\n        cites,\n        ignored_tokens = ignored_tokens,\n        known_authorities = known_authorities,\n        sort_by_cites = sort_by_cites,\n    )        \n</code></pre>"},{"location":"library/#citeurl.Citator.list_cites","title":"<code>list_cites(text, id_breaks=None)</code>","text":"<p>Find all citations in the given text, whether longform, shortform, or idform. They will be listed in order of appearance. If any two citations overlap, the shorter one will be deleted. </p> <p>Wherever the id_breaks pattern appears, it will interrupt chains of id-form citations. This is helpful for handling unrecognized citations that would otherwise cause CiteURL's notion of \"id.\" to get out of sync with what the text is talking about.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def list_cites(\n    self,\n    text: str,\n    id_breaks: re.Pattern = None,\n) -&gt; list[Citation]:\n    \"\"\"\n    Find all citations in the given text, whether longform,\n    shortform, or idform. They will be listed in order of\n    appearance. If any two citations overlap, the shorter one will\n    be deleted. \n\n    Wherever the id_breaks pattern appears, it will interrupt chains\n    of id-form citations. This is helpful for handling unrecognized\n    citations that would otherwise cause CiteURL's notion of \"id.\"\n    to get out of sync with what the text is talking about.\n    \"\"\"\n    # first get a list of all long and shortform (not id.) citations\n    longforms = []\n    for template in self.templates.values():\n        longforms += template.list_longform_cites(text)\n\n    shortforms = []\n    for citation in longforms:\n        shortforms += citation.get_shortform_cites()\n\n    citations = longforms + shortforms\n    _sort_and_remove_overlaps(citations)\n\n    # Figure out where to interrupt chains of idform citations,\n    # i.e. anywhere a longform or shortform citation starts, plus\n    # the start of any substring that matches the id_breaks pattern\n    breakpoints = [c.span[0] for c in citations]\n    if id_breaks:\n        breakpoints += [\n            match.span()[0] for match in\n            id_breaks.finditer(text)\n        ]\n    breakpoints = sorted(set(breakpoints))\n    breakpoints.append(len(text))\n\n    # for each cite, look for idform citations until the next cite\n    # or until the next breakpoint\n    idforms = []\n    for cite in citations:\n        # find the next relevant breakpoint, and delete any\n        # breakpoints that are already behind the current citation\n        for i, breakpoint in enumerate(breakpoints):\n            if breakpoint &gt;= cite.span[1]:\n                breakpoints = breakpoints[i:]\n                break\n        try:\n            breakpoint = breakpoints[0]\n        except IndexError:\n            breakpoint = None\n\n        # find the first idform reference to the citation, then the\n        # first idform reference to that idform, and so on, until\n        # the breakpoint\n        idform = cite.get_idform_cite(until_index=breakpoint)\n        while idform:\n            idforms.append(idform)\n            idform = idform.get_idform_cite(until_index=breakpoint)\n\n    citations += idforms\n    _sort_and_remove_overlaps(citations)\n    return citations\n</code></pre>"},{"location":"library/#citeurl.Citator.load_yaml","title":"<code>load_yaml(yaml)</code>","text":"<p>Load templates from the given YAML, overwriting any existing templates with the same name.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def load_yaml(self, yaml: str):\n    \"\"\"\n    Load templates from the given YAML, overwriting any existing\n    templates with the same name.\n    \"\"\"\n    for name, data in safe_load(yaml).items():\n        self.templates[name] = Template.from_dict(\n            name, data, inheritables=self.templates\n        )\n</code></pre>"},{"location":"library/#citeurl.Citator.to_yaml","title":"<code>to_yaml()</code>","text":"<p>Save this citator to a YAML string to load later</p> Source code in <code>citeurl/citator.py</code> <pre><code>def to_yaml(self):\n    \"Save this citator to a YAML string to load later\"\n    yamls = [t.to_yaml() for t in self.templates.values()]\n    return '\\n\\n'.join(yamls)\n</code></pre>"},{"location":"library/#citation","title":"Citation","text":"<p>A legal reference found in text.</p> <p>Attributes:</p> Name Type Description <code>tokens</code> <p>dictionary of the values that define this citation, such as its volume and page number, or its title, section, and subsection, etc</p> <code>URL</code> <code>str</code> <p>the location, if any, where this citation can be found online, defined by the template's URL_builder</p> <code>name</code> <code>str</code> <p>a uniform, human-readable representation of this citation, written by the template's name_builder</p> <code>text</code> <p>the actual text of this citation as found in the source text</p> <code>source_text</code> <p>the full text that this citation was found in</p> <code>template</code> <p>the template whose regexes found this citation or its parent</p> <code>parent</code> <p>the earlier citation, if any, that this citation is a shortform or idform child of</p> <code>raw_tokens</code> <p>dictionary of tokens as captured in the original regex match, before normalization. Note that for child citations, raw_tokens will include any raw_tokens inferred from the parent citation.</p> <code>idform_regexes</code> <p>list of regex pattern objects to find child citations later in the text, valid until the next different citation appears.</p> <code>shortform_regexes</code> <p>list of regex pattern objects to find child citations anywhere in the subsequent text</p> Source code in <code>citeurl/citation.py</code> <pre><code>class Citation:\n    \"\"\"\n    A legal reference found in text.\n\n    Attributes:\n        tokens: dictionary of the values that define this citation, such\n            as its volume and page number, or its title, section, and\n            subsection, etc\n\n        URL: the location, if any, where this citation can be found\n            online, defined by the template's URL_builder\n\n        name: a uniform, human-readable representation of this citation,\n            written by the template's name_builder\n\n        text: the actual text of this citation as found in the source\n            text\n\n        source_text: the full text that this citation was found in\n\n        template: the template whose regexes found this citation or its\n            parent\n\n        parent: the earlier citation, if any, that this citation is a\n            shortform or idform child of\n\n        raw_tokens: dictionary of tokens as captured in the original\n            regex match, before normalization. Note that for child\n            citations, raw_tokens will include any raw_tokens inferred\n            from the parent citation.\n\n        idform_regexes: list of regex pattern objects to find child\n            citations later in the text, valid until the next different\n            citation appears.\n\n        shortform_regexes: list of regex pattern objects to find\n            child citations anywhere in the subsequent text\n    \"\"\"\n\n    def __init__(\n        self,\n        match: re.match,\n        template,\n        parent = None,\n    ):\n        self.match = match\n        self.text = match.group(0)\n        self.source_text = match.string\n        self.span = match.span()\n        self.template = template\n        self.parent = parent\n        self.tokens = {}\n        self.raw_tokens = match.groupdict()\n\n        # copy raw_tokens (in order) from the parent citation, but\n        # stop at the first one that the child citation overwrites\n        if parent:\n            merged_tokens = {}\n            for k in template.tokens.keys():\n                if self.raw_tokens.get(k):\n                    merged_tokens.update(self.raw_tokens)\n                    break\n                else:\n                    merged_tokens[k] = parent.raw_tokens.get(k)\n            self.raw_tokens = merged_tokens\n\n        # normalize raw_tokens to get consistent token values across\n        # differently-formatted citations to the same source.\n        # This will raise a SyntaxError if a mandatory edit fails\n        for name, ttype in template.tokens.items():\n            value = self.raw_tokens.get(name)\n            self.tokens[name] = ttype.normalize(value)\n\n        # Finally, compile the citation's idform and shortform regexes.\n        # To avoid unneccessary work, first try to copy regexes from the\n        # parent citation if applicable.\n\n        if parent and parent.raw_tokens == self.raw_tokens:\n        # then we can safely copy the parent's regexes to the child\n            self.idform_regexes = parent.idform_regexes\n            self.shortform_regexes = parent.shortform_regexes\n            return\n\n        # otherwise we'll need to compile new shortform regexes,\n        # but we can still copy some of them from the parent\n\n        kwargs = {\n            'replacements': self.raw_tokens,\n            'token_prefix': 'same',\n        }\n        if parent:\n        # we can copy regexes, but only if they do not reference a\n        # specific value from the citation, e.g. {same volume}.\n            self.shortform_regexes = [\n                (\n                    re.compile(process_pattern(pattern, **kwargs))\n                    if '{same ' in pattern else parent.shortform_regexes[i]\n                )\n                for i, pattern in enumerate(template._processed_shortforms)\n            ]\n\n            self.idform_regexes = [\n                (\n                    re.compile(process_pattern(pattern, **kwargs))\n                    if '{same ' in pattern else parent.idform_regexes[i]\n                )\n                for i, pattern in enumerate(template._processed_idforms)\n            ]\n\n        else: # compile all-new idforms and shortforms\n            self.shortform_regexes = [\n                re.compile(process_pattern(pattern, **kwargs))\n                for pattern in self.template._processed_shortforms\n            ]\n            self.idform_regexes = [\n                re.compile(process_pattern(pattern, **kwargs))\n                for pattern in self.template._processed_idforms\n            ]\n        self.idform_regexes.append(BASIC_ID_REGEX)\n\n    @property\n    def URL(self) -&gt; str:\n        if self.template.URL_builder:\n            url =  self.template.URL_builder(self.tokens)\n            if url:\n                url = url.replace(' ', '%20')\n        else:\n            url = None\n        return url\n\n    @property\n    def name(self) -&gt; str:\n        if self.template.name_builder:\n            return self.template.name_builder(self.tokens)\n        else:\n            return None\n\n    def get_shortform_cites(self) -&gt; Iterable:\n        keep_trying = True\n        span_start = self.span[1]\n        while keep_trying:\n            try:\n                match = next(match_regexes(\n                    regexes=self.shortform_regexes,\n                    text=self.source_text,\n                    span=(span_start,),\n                ))\n                span_start = match.span()[1]\n                try:\n                    yield Citation(\n                        match=match,\n                        template=self.template,\n                        parent=self,\n                    )\n                except SyntaxError: # it's an invalid citation\n                    pass\n            except StopIteration:\n                keep_trying = False\n\n    def get_idform_cite(self, until_index: int=None):\n        try:\n            match = next(match_regexes(\n                regexes = self.idform_regexes,\n                text = self.source_text,\n                span = (self.span[1], until_index)\n            ))\n            return Citation(match=match, template=self.template, parent=self)\n        except StopIteration:\n            return None\n        except SyntaxError:\n            return None\n\n    def get_next_child(self, span: tuple=None):\n        try:\n            match = next(match_regexes(\n                regexes = self.shortform_regexes + self.idform_regexes,\n                text = self.source_text,\n                span = span if span else (self.span[1], ),\n            ))\n            return Citation(match=match, template=self.template, parent=self)\n        except StopIteration:\n            return None\n\n    def __str__(self):\n        return str(self.text)\n\n    def __repr__(self):\n        return str(self.text)\n        return (\n            f'Citation(match={self.match}, template={repr(self.template)}'\n            + (f', parent={repr(self.parent)}' if self.parent else '')\n        )\n\n    def __contains__(self, other_cite):\n        \"\"\"\n        Returns True if both citations are from templates with the same\n        name, and the only difference between their tokens is that the\n        other one has a more specific (i.e. higher-indexed) token than\n        any of this one's. Severable tokens are considered a match if\n        the other token's value *starts with* this one's.\n        \"\"\"\n        if (\n            other_cite.template.name != self.template.name\n            or other_cite.tokens == self.tokens\n        ):\n            return False\n        for key, value in self.tokens.items():\n            if value and other_cite.tokens.get(key) != value:\n                if (\n                    self.template.tokens[key].severable\n                    and other_cite.tokens[key]\n                    and other_cite.tokens[key].startswith(value)\n                ):\n                    continue\n                else:\n                    return False\n        else:\n            return True\n\n    def __eq__(self, other_cite):\n        \"\"\"\n        Returns True if both citations are from templates with the same\n        name, and they have the exact same token values.\n        \"\"\"\n        return (\n            other_cite.template.name == self.template.name\n            and other_cite.tokens == self.tokens\n        )\n\n    def __len__(self):\n        return len(self.text)\n</code></pre>"},{"location":"library/#citeurl.Citation.__contains__","title":"<code>__contains__(other_cite)</code>","text":"<p>Returns True if both citations are from templates with the same name, and the only difference between their tokens is that the other one has a more specific (i.e. higher-indexed) token than any of this one's. Severable tokens are considered a match if the other token's value starts with this one's.</p> Source code in <code>citeurl/citation.py</code> <pre><code>def __contains__(self, other_cite):\n    \"\"\"\n    Returns True if both citations are from templates with the same\n    name, and the only difference between their tokens is that the\n    other one has a more specific (i.e. higher-indexed) token than\n    any of this one's. Severable tokens are considered a match if\n    the other token's value *starts with* this one's.\n    \"\"\"\n    if (\n        other_cite.template.name != self.template.name\n        or other_cite.tokens == self.tokens\n    ):\n        return False\n    for key, value in self.tokens.items():\n        if value and other_cite.tokens.get(key) != value:\n            if (\n                self.template.tokens[key].severable\n                and other_cite.tokens[key]\n                and other_cite.tokens[key].startswith(value)\n            ):\n                continue\n            else:\n                return False\n    else:\n        return True\n</code></pre>"},{"location":"library/#citeurl.Citation.__eq__","title":"<code>__eq__(other_cite)</code>","text":"<p>Returns True if both citations are from templates with the same name, and they have the exact same token values.</p> Source code in <code>citeurl/citation.py</code> <pre><code>def __eq__(self, other_cite):\n    \"\"\"\n    Returns True if both citations are from templates with the same\n    name, and they have the exact same token values.\n    \"\"\"\n    return (\n        other_cite.template.name == self.template.name\n        and other_cite.tokens == self.tokens\n    )\n</code></pre>"},{"location":"library/#template","title":"Template","text":"<p>A pattern to recognize a single kind of citation and extract information from it.</p> Source code in <code>citeurl/citator.py</code> <pre><code>class Template:\n    \"\"\"\n    A pattern to recognize a single kind of citation and extract\n    information from it.\n    \"\"\"\n    def __init__(\n        self,\n        name: str,\n        tokens: dict[str, TokenType] = {},\n        meta: dict[str, str] = {},\n        patterns: list[str] = [],\n        broad_patterns: list[str] = [],\n        shortform_patterns: list[str] = [],\n        idform_patterns: list[str] = [],\n        name_builder: StringBuilder = None,\n        URL_builder: StringBuilder = None,\n        inherit_template = None,\n    ):\n        \"\"\"\n        Arguments:\n            name: the name of this template\n\n            tokens: The full dictionary of TokenTypes that citations from\n                this template can contain. These must be listed in order\n                from least-specific to most. For instance, the U.S.\n                Constitution's template puts 'article' before 'section'\n                before 'clause', because articles contain sections, and\n                sections contain clauses.\n\n            patterns: Patterns are essentially regexes to recognize\n                recognize long-form citations to this template. However,\n                wherever a token would appear in the regex, it should be\n                replaced by the name of the token, enclosed in curly\n                braces.\n\n                Patterns are matched in the order that they are listed,\n                so if there is a pattern that can only find a subset of\n                tokens, it should be listed after the more-complete\n                pattern so that the better match won't be precluded.\n\n            broad_patterns: Same as `patterns`, except that they will\n                only be used in contexts like search engines, where\n                convenience is more important than avoiding false\n                positive matches. When used, they will be used in\n                addition to the normal patterns.\n\n            shortform_patterns: Same as `patterns`, but these will only\n                go into effect after a longform citation has been\n                recognized. If a shortform pattern includes \"same\n                TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the\n                bracketed portion will be replaced with the exact text\n                of the corresponding `raw_token` from the long-form\n                citation.\n\n            idform_patterns: Same as `shortform_patterns`, except that\n                they will only be used to scan text until the next\n                different citation occurs.\n\n            URL_builder: `StringBuilder` to construct URLs for found\n                citations\n\n            name_builder: `StringBuilder` to construct canonical names\n                of found citations\n\n            meta: Optional metadata relating to this template. Patterns\n                and StringBuilders can access metadata fields as if they\n                were tokens, though fields can be overridden by tokens\n                with the same name.\n\n            inherit_template: another `Template` whose values this one\n                should copy unless expressly overwritten.\n        \"\"\"\n        kwargs = locals()\n        for attr, default in {\n            'name':               None,\n            'tokens':             {},\n            'patterns':           [],\n            'broad_patterns':     [],\n            'shortform_patterns': [],\n            'idform_patterns':    [],\n            'URL_builder':        None,\n            'name_builder':       None,\n            'meta':               {},\n        }.items():\n            if inherit_template and kwargs[attr] == default:\n                value = inherit_template.__dict__.get(attr)\n            elif attr.endswith('patterns') and not kwargs[attr]:\n                value = []\n            else:\n                value = kwargs[attr]\n            self.__dict__[attr] = value\n\n        # update inherited StringBuilders with the correct metadata\n        if inherit_template and self.meta:\n            if self.URL_builder:\n                self.URL_builder = copy(self.URL_builder)\n                self.URL_builder.defaults = self.meta\n            if self.name_builder:\n                self.name_builder = copy(self.name_builder)\n                self.name_builder.defaults = self.meta\n\n        # use the template's metadata and tokens to make a dictionary\n        # of replacements to insert into the regexes before compilation\n        replacements = {k:str(v) for (k, v) in self.meta.items()}\n        replacements.update({\n            k:fr'(?P&lt;{k}&gt;{v.regex})(?!\\w)'\n            for (k,v) in self.tokens.items()\n        })\n\n        # compile the template's regexes and broad_regexes\n        self.regexes = []\n        self.broad_regexes = []\n        for kind in ['regexes', 'broad_regexes']:\n            if kind == 'broad_regexes':\n                pattern_list = self.patterns + self.broad_patterns\n                flags = re.I\n            else:\n                pattern_list = self.patterns\n                flags = 0\n\n            for p in pattern_list:\n                pattern = process_pattern(\n                    p,\n                    replacements,\n                    add_word_breaks=True\n                )\n                try:\n                    regex = re.compile(pattern, flags)\n                    self.__dict__[kind].append(regex)\n                except re.error as e:\n                    i = 'broad ' if kind == 'broad_regexes' else ''\n                    raise re.error(\n                        f'{self} template\\'s {i}pattern \"{pattern}\" has '\n                        f'an error: {e}'\n                    )\n\n        self._processed_shortforms = [\n            process_pattern(p, replacements, add_word_breaks=True)\n            for p in self.shortform_patterns\n        ]\n        self._processed_idforms = [\n            process_pattern(p, replacements, add_word_breaks=True)\n            for p in self.idform_patterns\n        ]\n\n    @classmethod\n    def from_dict(cls, name: str, values: dict, inheritables: dict={}):\n        \"\"\"\n        Return a template from a dictionary of values, like a dictionary\n        created by parsing a template from YAML format.\n        \"\"\"\n        values = {\n            k.replace(' ', '_'):v\n            for k,v in values.items()\n        }\n\n        # when pattern is listed in singular form,\n        # replace it with a one-item list\n        items = values.items()\n        values = {}\n        for key, value in items:\n            if key.endswith('pattern'):\n                values[key + 's'] = [value]\n            else:\n                values[key] = value\n\n        # unrelated: when a single pattern is split\n        # into a list (likely to take advantage of\n        # YAML anchors), join it into one string\n        for k,v in values.items():\n            if not k.endswith('patterns'):\n                continue\n            elif v is None:\n                values[k] = None\n                continue\n            for i, pattern in enumerate(v):\n                if type(pattern) is list:\n                    values[k][i] = ''.join(pattern)\n\n        inherit = values.get('inherit')\n\n        if inherit:\n            values.pop('inherit')\n            try:\n                values['inherit_template'] = inheritables[inherit]\n            except KeyError:\n                raise KeyError(\n                    f'The {name} template tried to reference template '\n                    f'\"{inherit}\" but could not find it. Note that '\n                    f'templates can only reference others that are '\n                    f'defined higher up in the list, not lower.'\n                )\n\n        for key in ['name_builder', 'URL_builder']:\n            data = values.get(key)\n            if data:\n                data['defaults'] = values.get('meta') or {}\n                values[key] = StringBuilder.from_dict(data)\n        values['tokens'] = {\n            k: TokenType.from_dict(k, v)\n            for k,v in values.get('tokens', {}).items()\n        }\n        return cls(name=name, **values)\n\n    def to_dict(self) -&gt; dict:\n        \"save this Template to a dictionary of values\"\n        output = {}\n        if self.meta:\n            output['meta'] = self.meta\n        output['tokens'] = {\n            k:v.to_dict() for k, v in self.tokens.items()\n        }\n        for key in ['patterns', 'shortform_patterns', 'idform_patterns']:\n            value = self.__dict__.get(key)\n            if not value:\n                continue\n            elif len(value) &gt; 1:\n                output[key] = value\n            else: # de-pluralize lists that contain only one pattern\n                output[key[:-1]] = value[0]\n        for key in ['name_builder', 'URL_builder']:\n            if self.__dict__.get(key):\n                output[key] = self.__dict__[key].to_dict()\n\n        spaced_output = {k.replace('_', ' '):v for k, v in output.items()}\n\n        return spaced_output\n\n    def to_yaml(self) -&gt; str:\n        \"save this Template to a YAML string\"\n        return safe_dump(\n            {self.name: self.to_dict()},\n            sort_keys = False,\n            allow_unicode = True,\n        )\n\n    def cite(self, text, broad: bool=True, span: tuple=(0,)) -&gt; Citation:\n        \"\"\"\n        Return the first citation that matches this template. If 'broad'\n        is True, case-insensitive matching and broad regex patterns will\n        be used. If no matches are found, return None.\n        \"\"\"\n        regexes = self.broad_regexes if broad else self.regexes\n        matches = match_regexes(text, regexes, span=span)\n        for match in matches:\n            try:\n                return Citation(match, self)\n            except SyntaxError: # invalid citation\n                continue\n        else:\n            return None\n\n    def list_longform_cites(self, text, broad: bool=False, span: tuple=(0,)):\n        \"\"\"\n        Get a list of all long-form citations to this template found in\n        the given text.\n        \"\"\"\n        cites = []\n        regexes = self.broad_regexes if broad else self.regexes\n        for match in match_regexes(text, regexes, span=span):\n            try:\n                cites.append(Citation(match, self))\n            except SyntaxError:\n                continue\n        return cites\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return (\n            f'Template(name=\"{self.name}\"'\n            + (f', tokens={self.tokens}' if self.tokens else '')\n            + (f', meta={self.meta}' if self.meta else '')\n            + (f', patterns={self.patterns}' if self.patterns else '')\n            + (\n                f', broad_patterns={self.broad_patterns}' \n                if self.broad_patterns else ''\n            )\n            + (\n                f', shortform_patterns={self.shortform_patterns}'\n                if self.shortform_patterns else ''\n            )\n            + (\n                f', idform_patterns={self.idform_patterns}'\n                if self.idform_patterns else ''\n            )\n            + (\n                f', name_builder={self.name_builder}'\n                if self.name_builder else ''\n            )\n            + (\n                f', URL_builder={self.URL_builder}'\n                if self.URL_builder else ''\n            )\n            + ')'\n        )\n\n    def __contains__(self, citation: Citation):\n        return citation.template.name == self.name\n\n    def __eq__(self, other_template):\n        return repr(self) == repr(other_template)\n</code></pre>"},{"location":"library/#citeurl.Template.__init__","title":"<code>__init__(name, tokens={}, meta={}, patterns=[], broad_patterns=[], shortform_patterns=[], idform_patterns=[], name_builder=None, URL_builder=None, inherit_template=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of this template</p> required <code>tokens</code> <code>dict[str, TokenType]</code> <p>The full dictionary of TokenTypes that citations from this template can contain. These must be listed in order from least-specific to most. For instance, the U.S. Constitution's template puts 'article' before 'section' before 'clause', because articles contain sections, and sections contain clauses.</p> <code>{}</code> <code>patterns</code> <code>list[str]</code> <p>Patterns are essentially regexes to recognize recognize long-form citations to this template. However, wherever a token would appear in the regex, it should be replaced by the name of the token, enclosed in curly braces.</p> <p>Patterns are matched in the order that they are listed, so if there is a pattern that can only find a subset of tokens, it should be listed after the more-complete pattern so that the better match won't be precluded.</p> <code>[]</code> <code>broad_patterns</code> <code>list[str]</code> <p>Same as <code>patterns</code>, except that they will only be used in contexts like search engines, where convenience is more important than avoiding false positive matches. When used, they will be used in addition to the normal patterns.</p> <code>[]</code> <code>shortform_patterns</code> <code>list[str]</code> <p>Same as <code>patterns</code>, but these will only go into effect after a longform citation has been recognized. If a shortform pattern includes \"same TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the bracketed portion will be replaced with the exact text of the corresponding <code>raw_token</code> from the long-form citation.</p> <code>[]</code> <code>idform_patterns</code> <code>list[str]</code> <p>Same as <code>shortform_patterns</code>, except that they will only be used to scan text until the next different citation occurs.</p> <code>[]</code> <code>URL_builder</code> <code>StringBuilder</code> <p><code>StringBuilder</code> to construct URLs for found citations</p> <code>None</code> <code>name_builder</code> <code>StringBuilder</code> <p><code>StringBuilder</code> to construct canonical names of found citations</p> <code>None</code> <code>meta</code> <code>dict[str, str]</code> <p>Optional metadata relating to this template. Patterns and StringBuilders can access metadata fields as if they were tokens, though fields can be overridden by tokens with the same name.</p> <code>{}</code> <code>inherit_template</code> <p>another <code>Template</code> whose values this one should copy unless expressly overwritten.</p> <code>None</code> Source code in <code>citeurl/citator.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    tokens: dict[str, TokenType] = {},\n    meta: dict[str, str] = {},\n    patterns: list[str] = [],\n    broad_patterns: list[str] = [],\n    shortform_patterns: list[str] = [],\n    idform_patterns: list[str] = [],\n    name_builder: StringBuilder = None,\n    URL_builder: StringBuilder = None,\n    inherit_template = None,\n):\n    \"\"\"\n    Arguments:\n        name: the name of this template\n\n        tokens: The full dictionary of TokenTypes that citations from\n            this template can contain. These must be listed in order\n            from least-specific to most. For instance, the U.S.\n            Constitution's template puts 'article' before 'section'\n            before 'clause', because articles contain sections, and\n            sections contain clauses.\n\n        patterns: Patterns are essentially regexes to recognize\n            recognize long-form citations to this template. However,\n            wherever a token would appear in the regex, it should be\n            replaced by the name of the token, enclosed in curly\n            braces.\n\n            Patterns are matched in the order that they are listed,\n            so if there is a pattern that can only find a subset of\n            tokens, it should be listed after the more-complete\n            pattern so that the better match won't be precluded.\n\n        broad_patterns: Same as `patterns`, except that they will\n            only be used in contexts like search engines, where\n            convenience is more important than avoiding false\n            positive matches. When used, they will be used in\n            addition to the normal patterns.\n\n        shortform_patterns: Same as `patterns`, but these will only\n            go into effect after a longform citation has been\n            recognized. If a shortform pattern includes \"same\n            TOKEN_NAME\" in curly braces, e.g. \"{same volume}\", the\n            bracketed portion will be replaced with the exact text\n            of the corresponding `raw_token` from the long-form\n            citation.\n\n        idform_patterns: Same as `shortform_patterns`, except that\n            they will only be used to scan text until the next\n            different citation occurs.\n\n        URL_builder: `StringBuilder` to construct URLs for found\n            citations\n\n        name_builder: `StringBuilder` to construct canonical names\n            of found citations\n\n        meta: Optional metadata relating to this template. Patterns\n            and StringBuilders can access metadata fields as if they\n            were tokens, though fields can be overridden by tokens\n            with the same name.\n\n        inherit_template: another `Template` whose values this one\n            should copy unless expressly overwritten.\n    \"\"\"\n    kwargs = locals()\n    for attr, default in {\n        'name':               None,\n        'tokens':             {},\n        'patterns':           [],\n        'broad_patterns':     [],\n        'shortform_patterns': [],\n        'idform_patterns':    [],\n        'URL_builder':        None,\n        'name_builder':       None,\n        'meta':               {},\n    }.items():\n        if inherit_template and kwargs[attr] == default:\n            value = inherit_template.__dict__.get(attr)\n        elif attr.endswith('patterns') and not kwargs[attr]:\n            value = []\n        else:\n            value = kwargs[attr]\n        self.__dict__[attr] = value\n\n    # update inherited StringBuilders with the correct metadata\n    if inherit_template and self.meta:\n        if self.URL_builder:\n            self.URL_builder = copy(self.URL_builder)\n            self.URL_builder.defaults = self.meta\n        if self.name_builder:\n            self.name_builder = copy(self.name_builder)\n            self.name_builder.defaults = self.meta\n\n    # use the template's metadata and tokens to make a dictionary\n    # of replacements to insert into the regexes before compilation\n    replacements = {k:str(v) for (k, v) in self.meta.items()}\n    replacements.update({\n        k:fr'(?P&lt;{k}&gt;{v.regex})(?!\\w)'\n        for (k,v) in self.tokens.items()\n    })\n\n    # compile the template's regexes and broad_regexes\n    self.regexes = []\n    self.broad_regexes = []\n    for kind in ['regexes', 'broad_regexes']:\n        if kind == 'broad_regexes':\n            pattern_list = self.patterns + self.broad_patterns\n            flags = re.I\n        else:\n            pattern_list = self.patterns\n            flags = 0\n\n        for p in pattern_list:\n            pattern = process_pattern(\n                p,\n                replacements,\n                add_word_breaks=True\n            )\n            try:\n                regex = re.compile(pattern, flags)\n                self.__dict__[kind].append(regex)\n            except re.error as e:\n                i = 'broad ' if kind == 'broad_regexes' else ''\n                raise re.error(\n                    f'{self} template\\'s {i}pattern \"{pattern}\" has '\n                    f'an error: {e}'\n                )\n\n    self._processed_shortforms = [\n        process_pattern(p, replacements, add_word_breaks=True)\n        for p in self.shortform_patterns\n    ]\n    self._processed_idforms = [\n        process_pattern(p, replacements, add_word_breaks=True)\n        for p in self.idform_patterns\n    ]\n</code></pre>"},{"location":"library/#citeurl.Template.cite","title":"<code>cite(text, broad=True, span=(0))</code>","text":"<p>Return the first citation that matches this template. If 'broad' is True, case-insensitive matching and broad regex patterns will be used. If no matches are found, return None.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def cite(self, text, broad: bool=True, span: tuple=(0,)) -&gt; Citation:\n    \"\"\"\n    Return the first citation that matches this template. If 'broad'\n    is True, case-insensitive matching and broad regex patterns will\n    be used. If no matches are found, return None.\n    \"\"\"\n    regexes = self.broad_regexes if broad else self.regexes\n    matches = match_regexes(text, regexes, span=span)\n    for match in matches:\n        try:\n            return Citation(match, self)\n        except SyntaxError: # invalid citation\n            continue\n    else:\n        return None\n</code></pre>"},{"location":"library/#citeurl.Template.from_dict","title":"<code>from_dict(name, values, inheritables={})</code>  <code>classmethod</code>","text":"<p>Return a template from a dictionary of values, like a dictionary created by parsing a template from YAML format.</p> Source code in <code>citeurl/citator.py</code> <pre><code>@classmethod\ndef from_dict(cls, name: str, values: dict, inheritables: dict={}):\n    \"\"\"\n    Return a template from a dictionary of values, like a dictionary\n    created by parsing a template from YAML format.\n    \"\"\"\n    values = {\n        k.replace(' ', '_'):v\n        for k,v in values.items()\n    }\n\n    # when pattern is listed in singular form,\n    # replace it with a one-item list\n    items = values.items()\n    values = {}\n    for key, value in items:\n        if key.endswith('pattern'):\n            values[key + 's'] = [value]\n        else:\n            values[key] = value\n\n    # unrelated: when a single pattern is split\n    # into a list (likely to take advantage of\n    # YAML anchors), join it into one string\n    for k,v in values.items():\n        if not k.endswith('patterns'):\n            continue\n        elif v is None:\n            values[k] = None\n            continue\n        for i, pattern in enumerate(v):\n            if type(pattern) is list:\n                values[k][i] = ''.join(pattern)\n\n    inherit = values.get('inherit')\n\n    if inherit:\n        values.pop('inherit')\n        try:\n            values['inherit_template'] = inheritables[inherit]\n        except KeyError:\n            raise KeyError(\n                f'The {name} template tried to reference template '\n                f'\"{inherit}\" but could not find it. Note that '\n                f'templates can only reference others that are '\n                f'defined higher up in the list, not lower.'\n            )\n\n    for key in ['name_builder', 'URL_builder']:\n        data = values.get(key)\n        if data:\n            data['defaults'] = values.get('meta') or {}\n            values[key] = StringBuilder.from_dict(data)\n    values['tokens'] = {\n        k: TokenType.from_dict(k, v)\n        for k,v in values.get('tokens', {}).items()\n    }\n    return cls(name=name, **values)\n</code></pre>"},{"location":"library/#citeurl.Template.list_longform_cites","title":"<code>list_longform_cites(text, broad=False, span=(0))</code>","text":"<p>Get a list of all long-form citations to this template found in the given text.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def list_longform_cites(self, text, broad: bool=False, span: tuple=(0,)):\n    \"\"\"\n    Get a list of all long-form citations to this template found in\n    the given text.\n    \"\"\"\n    cites = []\n    regexes = self.broad_regexes if broad else self.regexes\n    for match in match_regexes(text, regexes, span=span):\n        try:\n            cites.append(Citation(match, self))\n        except SyntaxError:\n            continue\n    return cites\n</code></pre>"},{"location":"library/#citeurl.Template.to_dict","title":"<code>to_dict()</code>","text":"<p>save this Template to a dictionary of values</p> Source code in <code>citeurl/citator.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"save this Template to a dictionary of values\"\n    output = {}\n    if self.meta:\n        output['meta'] = self.meta\n    output['tokens'] = {\n        k:v.to_dict() for k, v in self.tokens.items()\n    }\n    for key in ['patterns', 'shortform_patterns', 'idform_patterns']:\n        value = self.__dict__.get(key)\n        if not value:\n            continue\n        elif len(value) &gt; 1:\n            output[key] = value\n        else: # de-pluralize lists that contain only one pattern\n            output[key[:-1]] = value[0]\n    for key in ['name_builder', 'URL_builder']:\n        if self.__dict__.get(key):\n            output[key] = self.__dict__[key].to_dict()\n\n    spaced_output = {k.replace('_', ' '):v for k, v in output.items()}\n\n    return spaced_output\n</code></pre>"},{"location":"library/#citeurl.Template.to_yaml","title":"<code>to_yaml()</code>","text":"<p>save this Template to a YAML string</p> Source code in <code>citeurl/citator.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"save this Template to a YAML string\"\n    return safe_dump(\n        {self.name: self.to_dict()},\n        sort_keys = False,\n        allow_unicode = True,\n    )\n</code></pre>"},{"location":"library/#tokentype","title":"TokenType","text":"<p>These objects represent categories of tokens that might be found in a citation.</p> <p>Attributes:</p> Name Type Description <code>regex</code> <p>A regular expression that matches the actual text of the token as found in any document, like the \"42\" in \"42 USC \u00a7 1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\". This regex will automatically be enclosed in a named capture group and inserted into any of the template's match patterns wherever the token's name appears in curly braces.</p> <code>edits</code> <p>Steps to normalize the token as captured in the regex into a value that is consistent across multiple styles.</p> <code>default</code> <p>Set the token to this value if it is not found in the citation.</p> <code>severable</code> <p>If two citations only differ based on this token, and only because one of the tokens extends longer than the other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then <code>severable</code> means that the former citation is thought to encompass the latter.</p> Source code in <code>citeurl/tokens.py</code> <pre><code>class TokenType:\n    \"\"\"\n    These objects represent categories of tokens that might be found in\n    a citation.\n\n    Attributes:\n        regex: A regular expression that matches the actual text of the\n            token as found in any document, like the \"42\" in \"42 USC \u00a7\n            1983\" or the \"Fourteenth\" in \"The Fourteenth Amendment\".\n            This regex will automatically be enclosed in a named capture\n            group and inserted into any of the template's match patterns\n            wherever the token's name appears in curly braces.\n        edits: Steps to normalize the token as captured in the regex\n            into a value that is consistent across multiple styles.\n        default: Set the token to this value if it is not found in the\n            citation.\n        severable: If two citations only differ based on this token,\n            and only because one of the tokens extends longer than the\n            other, e.g. \"(b)(2)\" and \"(b)(2)(A)\", then `severable` means\n            that the former citation is thought to encompass the latter.\n    \"\"\"\n    def __init__(\n        self,\n        regex: str = r'\\d+',\n        edits: list[TokenOperation] = [],\n        default: str = None,\n        severable: bool = False,\n    ):\n        self.regex = regex\n        self.edits = edits\n        self.default = default\n        self.severable = severable\n\n    @classmethod\n    def from_dict(cls, name: str, data: dict):\n        \"load a TokenType from a dictionary of values\"\n        return cls(\n            regex = data['regex'],\n            default = data.get('default'),\n            edits = [\n                TokenOperation.from_dict(v)\n                for v in data.get('edits', [])\n            ],\n            severable=data.get('severable', False)\n        )\n\n    def to_dict(self) -&gt; dict:\n        \"save this TokenType to a dictionary for storage in YAML format\"\n        output = {'regex': self.regex}\n        if self.edits:\n            output['edits'] = [\n                e.to_dict() for e in self.edits\n            ]\n        if self.default:\n            output['default'] = self.default\n        if self.severable:\n            output['severable'] = True\n        return output\n\n    def normalize(self, token: str) -&gt; str:\n        if not token:\n            return self.default\n        for op in self.edits:\n            token = op(token)\n        return token\n\n    def __str__(self):\n        return self.regex\n\n    def __repr__(self):\n        norms = '[' + ', '.join([\n            repr(n) for n in self.edits or []\n        ]) + ']'\n        return (\n            f\"TokenType(regex='{self.regex}'\"\n            + (f\", default='{self.default}'\" if self.default else '')\n            + (f', edits={norms}' if self.edits else '')\n            + ')'\n        )\n</code></pre>"},{"location":"library/#citeurl.TokenType.from_dict","title":"<code>from_dict(name, data)</code>  <code>classmethod</code>","text":"<p>load a TokenType from a dictionary of values</p> Source code in <code>citeurl/tokens.py</code> <pre><code>@classmethod\ndef from_dict(cls, name: str, data: dict):\n    \"load a TokenType from a dictionary of values\"\n    return cls(\n        regex = data['regex'],\n        default = data.get('default'),\n        edits = [\n            TokenOperation.from_dict(v)\n            for v in data.get('edits', [])\n        ],\n        severable=data.get('severable', False)\n    )\n</code></pre>"},{"location":"library/#citeurl.TokenType.to_dict","title":"<code>to_dict()</code>","text":"<p>save this TokenType to a dictionary for storage in YAML format</p> Source code in <code>citeurl/tokens.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"save this TokenType to a dictionary for storage in YAML format\"\n    output = {'regex': self.regex}\n    if self.edits:\n        output['edits'] = [\n            e.to_dict() for e in self.edits\n        ]\n    if self.default:\n        output['default'] = self.default\n    if self.severable:\n        output['severable'] = True\n    return output\n</code></pre>"},{"location":"library/#tokenoperation","title":"TokenOperation","text":"<p>A function to perform a predefined string manipulation</p> Source code in <code>citeurl/tokens.py</code> <pre><code>class TokenOperation:\n    \"\"\"A function to perform a predefined string manipulation\"\"\"\n    def __init__(\n        self,\n        action: str,\n        data,\n        mandatory: bool = True,\n        token: str = None,\n        output: str = None,\n    ):\n        \"\"\"\n        Arguments:\n            action: The kind of string manipulation that this operation\n                will perform, using the given data. There are a few\n                different options:\n\n                'sub': Regex substitution to perform on the text. Needs\n                    a list of two values: [PATTERN, REPLACEMENT]\n\n                'lookup': Check if the token matches any of the given\n                    regexes (via case-insensitive matching), and if so,\n                    replace it with the corresponding value. Needs a\n                    dictionary of `regex`: `replacement` pairs.\n\n                'case': Capitalize the token in the specified way.\n                    Options are 'upper', 'lower', and 'title'.\n\n                'lpad': Left pad the token with zeros until it is the\n                    specified number of characters long. Requires an\n                    int specifying the number of characters. You can\n                    also specify the padding character by providing a\n                    tuple: (MINIMUM_LENGTH, PADDING_CHARACTER).\n\n                'number_style': Assume that the token is a number,\n                    either in the form of digits, Roman numerals, or\n                    number words like \"thirty-seven\". Convert it into\n                    the specified number format, which can be any of\n                    these:\n\n                    'cardinal', e.g. \"twenty-seven\"\n\n                    'cardinal spaced', e.g. \"twenty seven\"\n\n                    'cardinal unspaced', e.g. \"twentyseven\"\n\n                    'ordinal', e.g. \"twenty-seventh\"\n\n                    'ordinal spaced', e.g. \"twenty seventh\"\n\n                    'ordinal unspaced', e.g. \"twentyseventh\"\n\n                    'roman numeral', e.g. 'xxvii'\n\n                    'digit', e.g. '27'\n\n                    Note that number formatting only works for positive\n                    whole numbers that do not exceed 40.\n\n            data: any data that a given action needs specified, as\n                described above\n\n            mandatory: whether a failed lookup or format action should\n                invalidate the entire citation\n\n            token: Necessary for operations in StringBuilders. This\n                value lets you provide the name of input token to use,\n                allowing you to then use the modify_dict() method.\n\n            output: If this value is set, modify_dict() will save the\n                operation's output to the dictionary key with this name\n                instead of modifying the input token in place.\n        \"\"\"\n        if action == 'sub':\n            self.func = lambda x: re.sub(data[0], data[1], x)\n        elif action == 'lookup':\n            table = {\n                re.compile(k, flags=re.I):v\n                for k, v in data.items()\n            }\n            self.func = lambda x: self._lookup(x, table, mandatory)\n        elif action == 'case':\n            self.func = lambda x: self._set_case(x, data)\n        elif action == 'lpad':\n            self.func = lambda x: self._left_pad(x, data)\n        elif action == 'number_style':\n            action_options = ['cardinal', 'ordinal', 'roman', 'digit']\n            if data not in action_options:\n                raise SyntaxError(\n                    f'{data} is not a valid number style. Valid options: '\n                    f'{action_options}'\n                )\n            self.func = lambda x: self._number_style(x, data, mandatory)\n        else:\n            raise SyntaxError(\n                f'{action} is not a defined token operation.'\n            )\n\n        self.action = action\n        self.data = data\n        self.mandatory = mandatory\n        self.token = token\n        self.output = output\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"load a TokenOperation from a dictionary of values\"\n        operations = []\n        for key in ['sub', 'lookup', 'case', 'lpad', 'number style']:\n            value = data.get(key)\n            if value:\n                action = key.replace(' ', '_')\n                action_data = value\n                break\n        mandatory = data.get('mandatory', True)\n        token = data.get('token')\n        output = data.get('output')\n        return cls(action, action_data, mandatory, token, output)\n\n    def to_dict(self) -&gt; dict:\n        \"save this TokenOperation to a dictionary of values\"\n        output = {}\n        for key in ['token', 'output']:\n            if self.__dict__.get(key):\n                output[key] = self.__dict__[key]\n        output[self.action] = self.data\n        if not self.mandatory:\n            output['mandatory'] = False\n\n        spaced_output = {k.replace('_', ' '):v for k, v in output.items()}\n\n        return spaced_output\n\n    def modify_dict(self, tokens: dict):\n        \"\"\"\n        apply this operation to a dictionary of tokens,\n        editing them as appropriate\n        \"\"\"\n        if not tokens.get(self.token):\n            return\n        if self.output:\n            tokens[self.output] = self.func(tokens[self.token])\n        else:\n            tokens[self.token] = self.func(tokens[self.token])\n\n    def __call__(self, input_value):\n        return self.func(input_value)\n\n    def __repr__(self):\n        return (\n            f'TokenOperation(action=\"{self.action}\", data=\"{self.data}\"'\n            + (f', mandatory=False' if not self.mandatory else '')\n            + (f', token=\"{self.token}\"' if self.token else '')\n            + (f', output=\"{self.output}\"' if self.output else '')\n            + ')'\n        )\n\n    # ================ Token Processing Operations =================== #\n\n    def _lookup(\n        self,\n        input: str,\n        table: dict[re.Pattern, str],\n        mandatory: bool=False,\n    ) -&gt; str:\n        for pattern, repl in table.items():\n            if pattern.fullmatch(input):\n                return repl\n        if mandatory:\n            regexes = [r.pattern for r in table.keys()]\n            raise SyntaxError(f'{input} could not be found in {table}')\n        else:\n            return input\n\n    def _set_case(self, input: str, case: str) -&gt; str:\n        if case == 'upper':\n            return input.upper()\n        elif case == 'lower':\n            return input.lower()\n        elif case == 'title':\n            return input.title()\n\n    def _left_pad(self, input: str, min_length: int, pad_char='0'):\n        diff = min_length - len(input)\n        if diff &gt; 0:\n            return (pad_char*diff + input)\n        return input\n\n    def _number_style(self, input: str, form: str, throw_error: bool=False):\n        if input.isnumeric():\n            value = int(input)\n        elif input[:-2].isnumeric(): # e.g. \"2nd\"\n            value = int(input[:-2])\n        else:\n            input = input.lower()\n            for i, row in enumerate(number_words):\n                if input in row:\n                    value = i + 1\n                    break\n            else:\n                if throw_error:\n                    raise SyntaxError(\n                        f'{input} cannot be recognized as a number'\n                    )\n        if form == 'digit':\n            return str(value)\n        forms = ['roman', 'cardinal', 'ordinal']\n        try:\n            output = number_words[value - 1][forms.index(form)]\n        except IndexError:\n            return NotImplementedError(\n                f\"CiteURL cannot process a number as high as {value}\"\n            )\n        if form == 'roman':\n            return output.upper()\n        return output\n</code></pre>"},{"location":"library/#citeurl.TokenOperation.__init__","title":"<code>__init__(action, data, mandatory=True, token=None, output=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The kind of string manipulation that this operation will perform, using the given data. There are a few different options:</p> <p>'sub': Regex substitution to perform on the text. Needs     a list of two values: [PATTERN, REPLACEMENT]</p> <p>'lookup': Check if the token matches any of the given     regexes (via case-insensitive matching), and if so,     replace it with the corresponding value. Needs a     dictionary of <code>regex</code>: <code>replacement</code> pairs.</p> <p>'case': Capitalize the token in the specified way.     Options are 'upper', 'lower', and 'title'.</p> <p>'lpad': Left pad the token with zeros until it is the     specified number of characters long. Requires an     int specifying the number of characters. You can     also specify the padding character by providing a     tuple: (MINIMUM_LENGTH, PADDING_CHARACTER).</p> <p>'number_style': Assume that the token is a number,     either in the form of digits, Roman numerals, or     number words like \"thirty-seven\". Convert it into     the specified number format, which can be any of     these:</p> <pre><code>'cardinal', e.g. \"twenty-seven\"\n\n'cardinal spaced', e.g. \"twenty seven\"\n\n'cardinal unspaced', e.g. \"twentyseven\"\n\n'ordinal', e.g. \"twenty-seventh\"\n\n'ordinal spaced', e.g. \"twenty seventh\"\n\n'ordinal unspaced', e.g. \"twentyseventh\"\n\n'roman numeral', e.g. 'xxvii'\n\n'digit', e.g. '27'\n\nNote that number formatting only works for positive\nwhole numbers that do not exceed 40.\n</code></pre> required <code>data</code> <p>any data that a given action needs specified, as described above</p> required <code>mandatory</code> <code>bool</code> <p>whether a failed lookup or format action should invalidate the entire citation</p> <code>True</code> <code>token</code> <code>str</code> <p>Necessary for operations in StringBuilders. This value lets you provide the name of input token to use, allowing you to then use the modify_dict() method.</p> <code>None</code> <code>output</code> <code>str</code> <p>If this value is set, modify_dict() will save the operation's output to the dictionary key with this name instead of modifying the input token in place.</p> <code>None</code> Source code in <code>citeurl/tokens.py</code> <pre><code>def __init__(\n    self,\n    action: str,\n    data,\n    mandatory: bool = True,\n    token: str = None,\n    output: str = None,\n):\n    \"\"\"\n    Arguments:\n        action: The kind of string manipulation that this operation\n            will perform, using the given data. There are a few\n            different options:\n\n            'sub': Regex substitution to perform on the text. Needs\n                a list of two values: [PATTERN, REPLACEMENT]\n\n            'lookup': Check if the token matches any of the given\n                regexes (via case-insensitive matching), and if so,\n                replace it with the corresponding value. Needs a\n                dictionary of `regex`: `replacement` pairs.\n\n            'case': Capitalize the token in the specified way.\n                Options are 'upper', 'lower', and 'title'.\n\n            'lpad': Left pad the token with zeros until it is the\n                specified number of characters long. Requires an\n                int specifying the number of characters. You can\n                also specify the padding character by providing a\n                tuple: (MINIMUM_LENGTH, PADDING_CHARACTER).\n\n            'number_style': Assume that the token is a number,\n                either in the form of digits, Roman numerals, or\n                number words like \"thirty-seven\". Convert it into\n                the specified number format, which can be any of\n                these:\n\n                'cardinal', e.g. \"twenty-seven\"\n\n                'cardinal spaced', e.g. \"twenty seven\"\n\n                'cardinal unspaced', e.g. \"twentyseven\"\n\n                'ordinal', e.g. \"twenty-seventh\"\n\n                'ordinal spaced', e.g. \"twenty seventh\"\n\n                'ordinal unspaced', e.g. \"twentyseventh\"\n\n                'roman numeral', e.g. 'xxvii'\n\n                'digit', e.g. '27'\n\n                Note that number formatting only works for positive\n                whole numbers that do not exceed 40.\n\n        data: any data that a given action needs specified, as\n            described above\n\n        mandatory: whether a failed lookup or format action should\n            invalidate the entire citation\n\n        token: Necessary for operations in StringBuilders. This\n            value lets you provide the name of input token to use,\n            allowing you to then use the modify_dict() method.\n\n        output: If this value is set, modify_dict() will save the\n            operation's output to the dictionary key with this name\n            instead of modifying the input token in place.\n    \"\"\"\n    if action == 'sub':\n        self.func = lambda x: re.sub(data[0], data[1], x)\n    elif action == 'lookup':\n        table = {\n            re.compile(k, flags=re.I):v\n            for k, v in data.items()\n        }\n        self.func = lambda x: self._lookup(x, table, mandatory)\n    elif action == 'case':\n        self.func = lambda x: self._set_case(x, data)\n    elif action == 'lpad':\n        self.func = lambda x: self._left_pad(x, data)\n    elif action == 'number_style':\n        action_options = ['cardinal', 'ordinal', 'roman', 'digit']\n        if data not in action_options:\n            raise SyntaxError(\n                f'{data} is not a valid number style. Valid options: '\n                f'{action_options}'\n            )\n        self.func = lambda x: self._number_style(x, data, mandatory)\n    else:\n        raise SyntaxError(\n            f'{action} is not a defined token operation.'\n        )\n\n    self.action = action\n    self.data = data\n    self.mandatory = mandatory\n    self.token = token\n    self.output = output\n</code></pre>"},{"location":"library/#citeurl.TokenOperation.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>load a TokenOperation from a dictionary of values</p> Source code in <code>citeurl/tokens.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"load a TokenOperation from a dictionary of values\"\n    operations = []\n    for key in ['sub', 'lookup', 'case', 'lpad', 'number style']:\n        value = data.get(key)\n        if value:\n            action = key.replace(' ', '_')\n            action_data = value\n            break\n    mandatory = data.get('mandatory', True)\n    token = data.get('token')\n    output = data.get('output')\n    return cls(action, action_data, mandatory, token, output)\n</code></pre>"},{"location":"library/#citeurl.TokenOperation.modify_dict","title":"<code>modify_dict(tokens)</code>","text":"<p>apply this operation to a dictionary of tokens, editing them as appropriate</p> Source code in <code>citeurl/tokens.py</code> <pre><code>def modify_dict(self, tokens: dict):\n    \"\"\"\n    apply this operation to a dictionary of tokens,\n    editing them as appropriate\n    \"\"\"\n    if not tokens.get(self.token):\n        return\n    if self.output:\n        tokens[self.output] = self.func(tokens[self.token])\n    else:\n        tokens[self.token] = self.func(tokens[self.token])\n</code></pre>"},{"location":"library/#citeurl.TokenOperation.to_dict","title":"<code>to_dict()</code>","text":"<p>save this TokenOperation to a dictionary of values</p> Source code in <code>citeurl/tokens.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"save this TokenOperation to a dictionary of values\"\n    output = {}\n    for key in ['token', 'output']:\n        if self.__dict__.get(key):\n            output[key] = self.__dict__[key]\n    output[self.action] = self.data\n    if not self.mandatory:\n        output['mandatory'] = False\n\n    spaced_output = {k.replace('_', ' '):v for k, v in output.items()}\n\n    return spaced_output\n</code></pre>"},{"location":"library/#stringbuilder","title":"StringBuilder","text":"<p>A function to take a dictionary of values and use it to construct a piece of text from them. This is used for citation templates' name builders and URL builders. </p> <p>Attributes:</p> Name Type Description <code>parts</code> <p>A list of strings that will be concatenated to create the string. Parts may contain bracketed references to citations' token values as well as templates' metadata. If a part references a token whose value is not set, the part will be omitted from the created string.</p> <code>edits</code> <p>A list of TokenOperations that will be performed on the provided tokens before the string is constructed. If the edits have <code>output</code> values, it is possible for them to define entirely new tokens for the sole purpose of building the string.</p> <code>defaults</code> <p>A dictionary of default token values to use when not overwritten by the citation. Generally these are provided by the template's meta attribute.</p> Source code in <code>citeurl/tokens.py</code> <pre><code>class StringBuilder:\n    \"\"\"\n    A function to take a dictionary of values and use it to construct a\n    piece of text from them. This is used for citation templates' name\n    builders and URL builders. \n\n    Attributes:\n        parts: A list of strings that will be concatenated to create the\n            string. Parts may contain bracketed references to citations'\n            token values as well as templates' metadata. If a part\n            references a token whose value is not set, the part will be\n            omitted from the created string.\n        edits: A list of TokenOperations that will be performed on the\n            provided tokens before the string is constructed. If the\n            edits have `output` values, it is possible for them to\n            define entirely new tokens for the sole purpose of building\n            the string.\n        defaults: A dictionary of default token values to use when not\n            overwritten by the citation. Generally these are provided by\n            the template's meta attribute.\n    \"\"\"\n    def __init__(\n        self,\n        parts: list[str],\n        edits: list[TokenOperation] = [],\n        defaults: dict[str, str] = {}\n    ):\n        self.parts = parts\n        self.edits = edits\n        self.defaults = defaults\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"load StringBuilder from dictionary of values\"\n        edits = [\n            TokenOperation.from_dict(o)\n            for o in data.get('edits', [])\n        ]\n        parts = data['parts']\n        defaults = data.get('defaults') or {}\n        return cls(parts, edits, defaults)\n\n    def to_dict(self) -&gt; dict:\n        \"save StringBuilder to a dictionary of values\"\n        output = {'parts': self.parts}\n        if self.edits:\n            output['edits'] = [op.to_dict() for op in self.edits]\n        return output\n\n    def __call__(\n        self,\n        tokens: dict[str, str],\n    ) -&gt; str:\n        if self.defaults:\n            defaults = copy(self.defaults)\n            defaults.update(tokens)\n            tokens = defaults\n        else:\n            tokens = copy(tokens)\n        tokens = {k:v for k,v in tokens.items() if v}\n        for op in self.edits:\n            try:\n                op.modify_dict(tokens)\n            except SyntaxError: # token operation failed; just skip it\n                pass\n        string_parts = []\n        for part in self.parts:\n            try:\n                string_parts.append(part.format(**tokens))\n            except KeyError: # skip parts that reference a nonexistent token\n                pass\n            # if a mandatory TokenOperation failed, don't return a URL\n            except SyntaxError:\n                string_parts = []\n                break\n        t = copy(tokens)\n        return ''.join(string_parts) or None\n\n    def __repr__(self):\n        return (\n            f'StringBuilder(parts={self.parts}'\n            + (f', edits={self.edits}' if self.edits else '')\n            + (f', defaults={self.defaults}' if self.defaults else '')\n            + ')'\n        )\n</code></pre>"},{"location":"library/#citeurl.StringBuilder.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>load StringBuilder from dictionary of values</p> Source code in <code>citeurl/tokens.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"load StringBuilder from dictionary of values\"\n    edits = [\n        TokenOperation.from_dict(o)\n        for o in data.get('edits', [])\n    ]\n    parts = data['parts']\n    defaults = data.get('defaults') or {}\n    return cls(parts, edits, defaults)\n</code></pre>"},{"location":"library/#citeurl.StringBuilder.to_dict","title":"<code>to_dict()</code>","text":"<p>save StringBuilder to a dictionary of values</p> Source code in <code>citeurl/tokens.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"save StringBuilder to a dictionary of values\"\n    output = {'parts': self.parts}\n    if self.edits:\n        output['edits'] = [op.to_dict() for op in self.edits]\n    return output\n</code></pre>"},{"location":"library/#insert_links","title":"insert_links()","text":"<p>Convenience function to hyperlink all citations in a text. For more info, see Citator.insert_links().</p> Source code in <code>citeurl/citator.py</code> <pre><code>def insert_links(\n    text: str,\n    attrs: dict = {'class': 'citation'},\n    add_title: bool = True,\n    URL_optional: bool = False,\n    redundant_links: bool = True,\n    id_breaks: re.Pattern = None,\n    ignore_markup: bool = True,\n    markup_format: str = 'html',\n    citator: Citator = None,\n):\n    \"\"\"\n    Convenience function to hyperlink all citations in a text. For more\n    info, see Citator.insert_links().\n    \"\"\"\n    citator = citator or _get_default_citator()\n    return citator.insert_links(\n        text = text,\n        attrs = attrs,\n        add_title = add_title,\n        redundant_links = redundant_links,\n        id_breaks = id_breaks,\n        ignore_markup = ignore_markup,\n        markup_format = markup_format,\n    )\n</code></pre>"},{"location":"library/#cite","title":"cite()","text":"<p>Convenience function to find a single citation in text, or None. See Citator.cite() for more info.</p> Source code in <code>citeurl/citator.py</code> <pre><code>def cite(\n    text: str,\n    broad: bool = True,\n    citator: Citator = None,\n) -&gt; Citation:\n    \"\"\"\n    Convenience function to find a single citation in text, or None. See\n    Citator.cite() for more info.\n    \"\"\"\n    citator = citator or _get_default_citator()\n    return citator.cite(text, broad=broad)\n</code></pre>"},{"location":"library/#list_cites","title":"list_cites()","text":"<p>Convenience function to list all citations in a text. For more info, see Citator.list_cites().</p> Source code in <code>citeurl/citator.py</code> <pre><code>def list_cites(text, citator: Citator = None, id_breaks=None):\n    \"\"\"\n    Convenience function to list all citations in a text. For more info,\n    see Citator.list_cites().\n    \"\"\"\n    citator = citator or _get_default_citator()\n    return citator.list_cites(text, id_breaks=id_breaks)\n</code></pre>"},{"location":"library/#default_citator","title":"DEFAULT_CITATOR","text":"<p>The insert_links, cite, and list_cites functions all make use of a built-in citator that is not defined by the library user. By default, this is the citator that is returned when you run <code>Citator()</code>. However, it is possible to add additional templates to this default citator, by installing the wonderful AppDirs library and placing the templates in one of the following directories:</p> <p>Linux: <code>~/.config/citeurl</code></p> <p>Mac: <code>~/Library/Preferences/citeurl</code></p> <p>Windows 7+: <code>C:\\Users\\&lt;username&gt;\\AppData\\Local\\raindrum\\citeurl</code></p>"},{"location":"template-yamls/","title":"Writing Your Own Templates","text":"<p>CiteURL has built-in templates to support most of the major sources of U.S. state and federal law, but that's still a very small fraction of the universe of references a document might contain. Municipal ordinances, other countries' laws, and most subject-specific materials are simply outside the scope of what CiteURL's built-in templates can reasonably cover.</p> <p>This page details how you can write your own citation templates to supplement or replace the built-in ones. Before you proceed, make sure you're a little familiar with regular expressions (regex), because a citation template is essentially a bunch of them glued together. You'll also need some basic knowledge of YAML, because that's the glue.</p> <p>Note: CiteURL's built-in templates are all written in the same format described on this page, so they're a helpful resource to learn and copy from when writing your own.</p>"},{"location":"template-yamls/#introduction","title":"Introduction","text":"<p>Essentially, a citation template does three things. First, it recognizes whether a given bit of text is a valid citation. Second, it extracts the relevant data from the citation, like the page or section numbers it references. Third, the template defines how to do useful things with that data, like turn it into a URL. Here's a simple template that does all of those things:</p> <pre><code>U.S. Code:\n  tokens:\n    title:\n      regex: \\d+\n    section:\n      regex: \\d+[A-Z]?\n  pattern: '{title} U\\.?S\\.?C\\.? ?\u00a7? {section}'\n  URL builder:\n    parts:\n      - 'https://www.law.cornell.edu/uscode/text/{title}/{section}'\n  name builder:\n    parts:\n      - '{title} U.S.C. \u00a7 {section}'\n</code></pre> <p>First, the template defines two <code>tokens</code> that a U.S. code citation can contain. The first is something called \"title\", and the second is \"section\". The fact that title is listed before section in the tokens list is important; it indicates that titles contain sections.</p> <p>Each token has its own <code>regex</code> that defines what inputs are valid for that part of the citation. Here, titles are just one or more digits, i.e. <code>\\d+</code>, whereas section numbers can optionally have a single capital letter afterwards.</p> <p>Next, the template provides a <code>pattern</code> for what citations need to look like. The pattern is a regular expression, except that any tokens listed in curly braces are replaced by a regex capture group matching the relevant regex. So, when CiteURL actually runs, the pattern is used to generate this regex:</p> <pre><code>(?P&lt;title&gt;\\d+) U\\.?S\\.?C\\.? \u00a7? ?(?P&lt;section&gt;\\d+[A-Z]?)\n</code></pre> <p>That regex lets the template know that \"42 U.S.C. \u00a7 1988\" is a reference to section 1988 of Title 42 of the U.S. Code, and so are a few similar-looking things like \"42 USC 1988\".</p> <p>Either way, \"42\" and \"1988\" will be stored as tokens and can be inserted into the <code>URL builder</code> to make this link. The <code>name builder</code> works the same way. Regardless of any formatting differences in the text that was matched, it lets CiteURL display that citation as \"42 U.S.C. \u00a7 1988.\"</p> <p>Now that you've got the basic concept, let's go over the parts in more detail.</p>"},{"location":"template-yamls/#tokens","title":"Tokens","text":"<p>Tokens are the discrete pieces of information found in a citation. They can represent anything from a page number to a named chapter of law. Each token must have a <code>regex</code> indicating what text is valid input for that token, and it may also have a list of edits used to process and normalize the token text as soon as it is matched.</p> <p>Sometimes, like in the U.S. Code example above, it's as simple as storing whatever text is found in a particular part of the citation. No edits were needed, because \"1988\" would only be written in one specific way. Other times, however, it is necessary to perform various string processing operations to normalize the data. Consider the following example:</p> <pre><code>U.S. Constitution:\n  ...\n  tokens:\n    article:\n      regex: [1-7]|[IV]{1,3}|One|Two|Three|Four|Five|Six|Seven\n      edits:\n        - number style: digit\n  ...\n</code></pre> <p>Here, the <code>regex</code> can recognize a number between one and seven, no matter whether it is given as a digit, a Roman numeral, or a word. But it would not be useful to store this value without normalization---it is important that \"3\", \"III\", and \"Three\" are all treated as equivalent. To accomplish this, the template uses a <code>number style</code> edit to coerce the number into digit format. As a result, no matter whether the template matched \"Article III\", \"Article 3\", or \"Article Three\", the resulting citation will have an article value of \"3\".</p>"},{"location":"template-yamls/#edits","title":"Edits","text":"<p>Edits are simple predefined string operations that can be performed on tokens. They are useful in two contexts. First, as described above, they can be included in the token definition in order to normalize its input. Second, they can be used in string builders in order to temporarily-modify tokens for the sole purpose of building the string. In either case, the following edits are available:</p> Edit Description Example <code>case</code> Convert the given token to the specified capitalization, either <code>upper</code>, <code>lower</code>, or <code>title</code>. In the latter case, only the first letter of every word is capitalized. <code>case: upper</code> <code>sub</code> Perform a regex substitution on the token, replacing each occurrences of the first listed string (treated as a regex) with the second listed string. <code>sub: ['\\W+', '-']</code> <code>lpad</code> Add zeroes to the left side of the token as necessary until it is the specified length. <code>lpad: 3</code> <code>lookup</code>* Use case-insensitive regex matching to check whether the token matches any of the keys in the given dictionary. If the token matches a key, it will be replaced with the associated value. <code>lookup: {'[Pp]attern': 'replacement', '[Pp]otato': 'tomato'}</code> <code>number style</code>* Assume that the token is a number, and convert it to the specified format, which can be any of the following: <code>digit</code>, <code>roman numeral</code>, <code>cardinal</code>, or <code>ordinal</code>. The latter two options may be followed with <code>spaced</code> or <code>unspaced</code> to clarify how to handle words like \"twenty-seven\". The default is to use dashes. <code>number style: cardinal</code>"},{"location":"template-yamls/#failed-edits","title":"Failed Edits","text":"<p>The <code>lookup</code> and <code>number style</code> edits are unique in that it is possible for them to fail. A token may fail a lookup if it does not match any of the provided regexes, while it may fail a number style edit if it cannot be recognized as a number. When this happens, the default behavior depends on whether the failed edit is part of a token definition, or instead part of a string builder.</p> <p>If the edit is part of the token definition, it will cause the entire citation to fail as if it had never matched the template in the first place. On the other hand, if the token is being used in a string builder, failure will simply cause the affected token's value to be set to null for purposes of the string builder.</p> <p>You can change the default behavior by adding the following tag to an edit: <code>mandatory: no</code>. If an edit with this tag fails, the edit will simply be ignored.</p> <p>For instance, the following \"reporter\" token can be any string of up to ten characters, but if it is \"F. Supp.\" or \"P. 2d\" it will be replaced with \"F.Supp.\" or \"P.2d\", respectively. Because the lookup is tagged as not mandatory, tokens that don't match either of these strings will be unaffected. Without that tag, the entire citation would be discarded if it did not match either of those values.</p> <pre><code>...\n  tokens:\n    reporter:\n      regex: .{1,10}\n      edits:\n        - mandatory: no\n          lookup:\n            F\\. ?Supp\\.: F.Supp.\n            P\\. ?2d: P.2d\n\n...\n</code></pre>"},{"location":"template-yamls/#chaining-multiple-edits","title":"Chaining Multiple Edits","text":"<p>Edits can be chained, and they will take effect in the order they are listed. For instance, if you wanted to store the article numbers as lower-case Roman numerals, you could do this:</p> <pre><code>  tokens:\n    article:\n      regex: [1-7]|[IV]{1,3}|One|Two|Three|Four|Five|Six|Seven\n      edits:\n        - number style: roman\n        - case: lower\n</code></pre>"},{"location":"template-yamls/#severability","title":"Severability","text":"<p>Ordinarily, if two citations both have a token and that token differs between the two of them, the two citations are thought to be completely unrelated. For instance, \"33 USC \u00a7 10\" is a totally different law than \"33 USC \u00a7 100\", even though \"100\" starts with \"10\".</p> <p>However, sometimes it is relevant that one token begins with the same value as another. For instance, the Code of Federal Regulations template has a \"subsection\" token that matches a sequence of one or more numbers or letters in parentheses. But ordinarily, CiteURL would treat \"21 CFR \u00a7 820.1(a)\" and \"21 CFR \u00a7 820.1(a)(1)\" as totally unrelated subsections since \"(a)\" is not the same as \"(a)(1)\". This is wrong, since the former citation encompasses the latter.</p> <p>To handle these situations, tokens can be given the <code>severable: yes</code> tag, to indicate that when the only difference between two citations is that the second one has a severable token that extends longer than the first one's, the first citation is thought to include the second one.</p> <pre><code>...\n  tokens:\n    subsection:\n      regex: '(\\(\\w{1,4}\\))+'\n      severable: yes\n...\n</code></pre> <p>Note that the <code>severable</code> tag is unnecessary when the difference is that one citation is simply missing a possible token. For instance, \"U.S. Const. Article III\" is known to include \"U.S. Const. Article III, \u00a7 2\" just because the U.S. Constitution template defines the article token before the section token.</p>"},{"location":"template-yamls/#default-values","title":"Default Values","text":"<p>Often a citation may be valid even if it does not contain all tokens that it possibly could. For instance, a citation to a court opinion may or may not have a pincite to a specific page. Normally, when such a token is omitted, its value is <code>None</code>. However, you can also specify a different default value if you wish:</p> <pre><code>...\n  tokens:\n    section:\n      regex: \\d+\n      default: '1'\n...\n</code></pre>"},{"location":"template-yamls/#patterns","title":"Patterns","text":"<p>Patterns are essentially the regular expressions that a template uses to detect overall citations. However, a pattern is not a pure regex---instead of including a regex for each token the pattern can recognize, the pattern simply contains a reference to the token itself. This is useful as a way to avoid redefining a token's regex when it is used in multiple patterns.</p> <p>A template's <code>patterns</code> are responsible for recognizing one or more formats of typical long-form citations to the given body of law. In addition to these, a template can also have <code>shortform patterns</code> and <code>idform patterns</code>, which go into effect after an ordinary <code>pattern</code> has been matched. When this happens, CiteURL looks for \"idform\" citations until it encounters a different intervening citation, and it looks for shortforms anywhere until the end of the document. In addition, a template can have <code>broad patterns</code>, which are exactly like longform patterns except that they are only used in search engine-like contexts, where user convenience is more important than avoiding false positives.</p>"},{"location":"template-yamls/#pattern-format","title":"Pattern Format","text":"<p>Regardless of the type of pattern, they share a few key points of formatting. First, it is possible to specify patterns either in singular form or in list form. For instance, either of these would be valid:</p> <pre><code>...\n  pattern: '{volume} USC \u00a7 {section}'\n...\n</code></pre> <pre><code>...\n  patterns:\n    - '{volume USC (\u00a7|[Ss]ec(tion|t?\\.) {section}'\n    - '(\u00a7|[Ss]ec(tion|t?\\.) {section} of [Vv]olume {volume} of the U\\.S\\. Code'\n...\n</code></pre> <p>This is not to be confused with another feature of patterns: An individual pattern can be provided either as a single string, or as a list of strings. This is useful so that you can take advantage of YAML anchors to avoid rewriting certain common bits of regex. Consider the following example:</p> <pre><code>...\n  patterns:\n    - ['{volume} USC ', &amp;sec_sign '(\u00a7|[Ss]ec(tion|t?\\.)', ' {section}']\n    - [*sec_sign, ' {section} of [Vv]olume {volume} of the U\\.S\\. Code']\n...\n</code></pre> <p>The above example defines a YAML anchor called <code>sec_sign</code> to represent any string that is either \"\u00a7\", \"Section\", or various abbreviations thereof. Because it would be a pain to write that string repeatedly across a large number of templates, it's useful to reuse it as a YAML anchor. Although each pattern is broken into a list, it is functionally equivalent to the previous example.</p>"},{"location":"template-yamls/#shortforms-and-idforms","title":"Shortforms and Idforms","text":"<p>These two types of patterns are intended to recognize contextual references to a citation that was found previously in the text. To facilitate this, they both share one special feature: Values from their parent longform citation can be inserted into the shortform pattern so as to only match when the specified value is the same. Consider the following example:</p> <pre><code>U.S. Caselaw:\n  tokens:\n    reporter: {regex: .{3, 10}}\n    volume: {regex: \\d+}\n    page: {regex: \\d+}\n    pincite: {regex: \\d+}\n  pattern: '{volume} {reporter} {page}(, {pincite})?'\n  shortform pattern: '{same volume} {same reporter} at {pincite}'\n  idform pattern: 'Id\\. at {pincite}'\n</code></pre> <p>This template will recognize longform citations like \"413 F. Supp. 1281\". Once it has found such a citation, it can detect immediate repeat citations like \"Id. at &lt;any number&gt;\", because of its <code>idform pattern</code>. The <code>shortform pattern</code>, meanwhile, will match any subsequent occurrence of \"413 F. Supp. &lt;any number&gt;\" anywhere in the text.</p>"},{"location":"template-yamls/#string-builders","title":"String Builders","text":"<p>The two kinds of string builder are a template's <code>name builder</code> and its <code>URL builder</code>, and they both work the same way. They use a citation's tokens to fill placeholders in a pattern and output a uniform string representation of that citation. This is the source of each citation's <code>name</code> and <code>URL</code> properties.</p> <p>A string builder is made up of one or more <code>parts</code>, and optionally a list of <code>edits</code>. The first value, <code>parts</code>, is a list of strings that will be concatenated to make the result. Each part can contain placeholder values in curly braces. The placeholders will be replaced with the corresponding token values or metadata values. If a part references a blank token, that part will be omitted from the overall string.</p> <p><code>edits</code> is a list of token edits that will be performed on the tokens and metadata just before they are inserted into the string. They work just like the token edits described earlier, except for two differences.</p> <p>First, whereas the edits described earlier serve to normalize tokens after they are matched in text, these ones are only used in order to build a string---they do not permanently modify the underlying tokens.</p> <p>Second, because these edits are not listed by token, you must specify which token each one operates on, by giving it a <code>token</code> value. You can also optionally give it an <code>output</code> value, in which the result of the edit will be saved to the specified token instead of modifying the input.</p> <p>Here's an example of each kind of string builder:</p> <pre><code>U.S. Code:\n  ...\n  name builder:\n    parts:\n      - '{title} U.S.C. \u00a7 {section}'\n      - '{subsection}'\n  URL builder:\n    parts:\n      - https://www.law.cornell.edu/uscode/text/{title}/{section}\n      - '#{subsection}'\n    edits:\n      - token: subsection\n        sub: ['\\)\\(', '_']\n      - token: subsection\n        sub: ['[()]', '']\n</code></pre> <p>If this template is given the citation, \"42 usc 1988\", the <code>name builder</code> will use the title and section numbers to write \"42 U.S.C. \u00a7 1988\". The '{subsection}' part is omitted because the citation has no subsection. Likewise, the <code>URL builder</code> will make this URL, ignoring the blank token and the edits that rely on it.</p> <p>Given the citation \"29 USC \u00a7 158(b)(4)\", however, the <code>URL builder</code> will take the subsection and subject it to two <code>edits</code>, first to change it from '(b)(4)' to '(b_4)', and then to change that to 'b_4'. Having done that, it can fill in the '#{subsection}' part, and append it to the first part to make this URL.</p>"},{"location":"template-yamls/#miscellaneous","title":"Miscellaneous","text":"<p>The following features aren't crucial to what a template is, or what it does, but they're nice to have when you're trying to write a whole lot of templates without reinventing the wheel too many times.</p>"},{"location":"template-yamls/#metadata","title":"Metadata","text":"<p>A template can have a <code>meta</code> attribute that contains a dictionary of values that will be accessible to the template's patterns and string builders just like a token is. Note that token edits in string builders can override metadata values using the <code>output</code> tag.</p>"},{"location":"template-yamls/#template-inheritance","title":"Template Inheritance","text":"<p>A template can <code>inherit</code> any already-defined template, such that it will copy any characteristics of that template except for those that are expressly overwritten. This is useful when two templates are both very, very complicated, but they are largely similar in format.</p> <p>For instance, citations to the Code of Federal Regulations are very similar to the U.S. code: They both fit the \"title, section, optional subsections in parentheses\" format, so most of this horrible mess only needs to be written once:</p> <pre><code>U.S. Code:\n  meta:\n    name regex: 'U\\. ?S\\. ?C(ode|\\.)|USC|United States Code'\n    abbreviation: U.S.C.\n  tokens:\n    title: {regex: \\d+}\n    section: {regex: '\\d[\\w.-]*\\w|\\d'}\n    subsection:\n      regex: '(\\(\\w{1,4}\\))+'\n      severable: yes\n  patterns:\n    - - &amp;title ([Tt]itle )?{title}\n      - ',? {name regex}(,? )?('\n      - &amp;section_sign ((&amp;sect;|&amp;#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.))\n      - ')? ?{section}'\n      - &amp;subsec '(((,? )?sub(sections?|divisions?|(sec|d(iv)?)?s?\\.))? ?{subsection})?'\n    - ['[Tt]itle {title},? (', *section_sign, ')? ?{section}', *subsec, ' of the {name regex}']\n    - ['(', *section_sign, ')? ?{section}', *subsec, ' of [Tt]itle {title} of the {name regex}']\n  idform patterns:\n    - '[Ii]d\\.( at)?( \u00a7\u00a7?)? ?{section}( ?{subsection})?'\n    - '((&amp;sect;|&amp;#167|\u00a7){1,2}|[Ss]ec(tions?|t?s?\\.)) {section}( ?{subsection})?(?! of)'\n    - '[Ii]d\\. at {subsection}'\n  name builder:\n    parts:\n      - '{title} {abbreviation} \u00a7 {section}'\n      - '{subsection}'\n  URL builder:\n    parts:\n      - https://www.law.cornell.edu/uscode/text/{title}/{section}\n      - '#{subsection}'\n    edits:\n      - token: subsection\n        sub: ['\\)\\(', '_']\n      - token: subsection\n        sub: ['[()]', '']\n\n\nCode of Federal Regulations:\n  inherit: U.S. Code\n  meta:\n    name regex: 'C\\.? ?F\\.? ?R\\.?|Code of Federal Regulations'\n    abbreviation: C.F.R.\n  URL builder:\n    parts:\n      - 'https://ecfr.federalregister.gov/cfr-reference?cfr%5Bdate%5D=current&amp;cfr%5Breference%5D={title} CFR {section}''\n      - '#p-{section}{subsection}'\n</code></pre>"}]}