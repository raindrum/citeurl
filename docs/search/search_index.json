{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started CiteURL is an extensible tool to process long and shortform legal citations in text and generate links to various websites where you can view the cited language for free. Here's an example of what it can do: Sample Input Output Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera , 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside , 477 U.S. at 574-78. Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b) , and, by discretion, expert fees, id. at (c) . This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera , 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside , 477 U.S. at 574-78 . By default, CiteURL supports Bluebook-style citations to over 130 sources of U.S. law, including: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico. You can also customize CiteURL to support more sources of law by writing your own citation templates in YAML format. If you want to try out CiteURL's citation lookup features without installing anything, you can use Law Search , a JavaScript implementation of CiteURL I maintain on my website. Installation CiteURL has been tested with Python version 3.9, but earlier versions probably work too. Install Python if you don't have it, then run this command: python -m pip install citeurl Usage Look up a single citation and open it directly in a browser: citeurl \"42 usc 1983\" -l -b Process a court opinion or other text, and output a version where every citation is converted into an HTML hyperlink: citeurl -i INPUT_FILE.html -o OUTPUT_FILE.html Get a list of the top 10 authorities cited in a text, ordered by the number of citations to each, including citations to custom sources that CiteURL doesn't even natively support: cat INPUT_FILE.html | citeurl -a 10 -s YOUR_TEMPLATES.YAML For more options, run citeurl -h . Besides to the command-line tool, CiteURL can be used in a few other forms: a tool to generate embeddable JavaScript so you can make your own instance of Law Search with custom sources of law a flexible Python library , albeit one that changes fairly often an extension to Python-Markdown for Linux users, a GNOME desktop search provider Credits Many thanks to these websites, which CiteURL's default templates frequently link to: Harvard's Caselaw Access Project - for court cases Cornell's Legal Information Institute - for the U.S. Code and many federal rules Ballotpedia - for the vast majority of state constitutions LawServer.com - for statutes in about a dozen states and territories whose websites don't have a compatible URL scheme By the way, if you get a lot of use out of CiteURL and want to support the project, you can use the link below: \u2615 Buy me a coffee","title":"Getting Started"},{"location":"#getting-started","text":"CiteURL is an extensible tool to process long and shortform legal citations in text and generate links to various websites where you can view the cited language for free. Here's an example of what it can do: Sample Input Output Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera , 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside , 477 U.S. at 574-78. Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b) , and, by discretion, expert fees, id. at (c) . This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera , 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside , 477 U.S. at 574-78 . By default, CiteURL supports Bluebook-style citations to over 130 sources of U.S. law, including: most state and federal court cases the U.S. Code and Code of Federal Regulations the U.S. Constitution and all state constitutions codified laws for every state and territory except Arkansas, Georgia, Guam, and Puerto Rico. You can also customize CiteURL to support more sources of law by writing your own citation templates in YAML format. If you want to try out CiteURL's citation lookup features without installing anything, you can use Law Search , a JavaScript implementation of CiteURL I maintain on my website.","title":"Getting Started"},{"location":"#installation","text":"CiteURL has been tested with Python version 3.9, but earlier versions probably work too. Install Python if you don't have it, then run this command: python -m pip install citeurl","title":"Installation"},{"location":"#usage","text":"Look up a single citation and open it directly in a browser: citeurl \"42 usc 1983\" -l -b Process a court opinion or other text, and output a version where every citation is converted into an HTML hyperlink: citeurl -i INPUT_FILE.html -o OUTPUT_FILE.html Get a list of the top 10 authorities cited in a text, ordered by the number of citations to each, including citations to custom sources that CiteURL doesn't even natively support: cat INPUT_FILE.html | citeurl -a 10 -s YOUR_TEMPLATES.YAML For more options, run citeurl -h . Besides to the command-line tool, CiteURL can be used in a few other forms: a tool to generate embeddable JavaScript so you can make your own instance of Law Search with custom sources of law a flexible Python library , albeit one that changes fairly often an extension to Python-Markdown for Linux users, a GNOME desktop search provider","title":"Usage"},{"location":"#credits","text":"Many thanks to these websites, which CiteURL's default templates frequently link to: Harvard's Caselaw Access Project - for court cases Cornell's Legal Information Institute - for the U.S. Code and many federal rules Ballotpedia - for the vast majority of state constitutions LawServer.com - for statutes in about a dozen states and territories whose websites don't have a compatible URL scheme By the way, if you get a lot of use out of CiteURL and want to support the project, you can use the link below: \u2615 Buy me a coffee","title":"Credits"},{"location":"frontends/","text":"CiteURL Frontends CiteURL can be used in a few forms besides the command-line tool and the Python library . Here's what they are: JavaScript Although CiteURL is primarily a Python program, it can also generate a JavaScript implementation of its citation lookup function, so that end users can look up citations in a web browser without having to install anything. Law Search is one such instance that I maintain on my website. You can use the citeurl-makejs command to make your own custom instances that support arbitrary sources of law. Here's how: Write a YAML file with one or more custom citation templates. Install CiteURL if you have not done so already. Open a command line and run the following: citeurl-makejs -e -o output.html PATH/TO/YOUR/TEMPLATES.YAML Alternatively, to omit the default templates, include the -n option in that command. After exporting an HTML file, you can bookmark the local file as a custom search engine . Alternatively, if you have a web page you'd like to embed CiteURL functionality into, you can also generate the JavaScript by itself. To do that, omit the -e option and save the output as a .js file. All the citation lookup functionality is available via its getUrlForQuery() function, which takes a search query string as input, and returns the completed URL. For more info, run citeurl-makejs -h . Markdown Extension CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_templates : A list of paths to YAML files containing custom citation templates . Defaults to none. use_defaults : Whether CiteURL should load the default citation templates. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . link_detailed_ids : Whether to insert links for citations like Id. at 305 . Defaults to True . link_plain_ids : Whether to insert links for citations like Id. . Defaults to False . break_id_on_regex : Anywhere this string (parsed as regex) appears in the text, chains of citations like id. will be interrupted. Note that this is based on the output HTML, not the original Markdown text. Defaults to L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst) GNOME Shell Search Provider If you use the GNOME desktop environment, you can install my other project to look up citations directly from your desktop!","title":"CiteURL Frontends"},{"location":"frontends/#citeurl-frontends","text":"CiteURL can be used in a few forms besides the command-line tool and the Python library . Here's what they are:","title":"CiteURL Frontends"},{"location":"frontends/#javascript","text":"Although CiteURL is primarily a Python program, it can also generate a JavaScript implementation of its citation lookup function, so that end users can look up citations in a web browser without having to install anything. Law Search is one such instance that I maintain on my website. You can use the citeurl-makejs command to make your own custom instances that support arbitrary sources of law. Here's how: Write a YAML file with one or more custom citation templates. Install CiteURL if you have not done so already. Open a command line and run the following: citeurl-makejs -e -o output.html PATH/TO/YOUR/TEMPLATES.YAML Alternatively, to omit the default templates, include the -n option in that command. After exporting an HTML file, you can bookmark the local file as a custom search engine . Alternatively, if you have a web page you'd like to embed CiteURL functionality into, you can also generate the JavaScript by itself. To do that, omit the -e option and save the output as a .js file. All the citation lookup functionality is available via its getUrlForQuery() function, which takes a search query string as input, and returns the completed URL. For more info, run citeurl-makejs -h .","title":"JavaScript"},{"location":"frontends/#markdown-extension","text":"CiteURL can also be used as an extension to Python-Markdown . You can load the extension as citeurl , and it supports the following options: custom_templates : A list of paths to YAML files containing custom citation templates . Defaults to none. use_defaults : Whether CiteURL should load the default citation templates. Defaults to True . attributes : A dictionary of HTML attributes to give each hyperlink that CiteURL inserts into the text. Defaults to {'class': 'citation'} . link_detailed_ids : Whether to insert links for citations like Id. at 305 . Defaults to True . link_plain_ids : Whether to insert links for citations like Id. . Defaults to False . break_id_on_regex : Anywhere this string (parsed as regex) appears in the text, chains of citations like id. will be interrupted. Note that this is based on the output HTML, not the original Markdown text. Defaults to L\\. ?Rev\\.|J\\. ?Law|\\. ?([Cc]ode|[Cc]onst)","title":"Markdown Extension"},{"location":"frontends/#gnome-shell-search-provider","text":"If you use the GNOME desktop environment, you can install my other project to look up citations directly from your desktop!","title":"GNOME Shell Search Provider"},{"location":"library/","text":"Library Reference This page documents how to include CiteURL in your Python programming projects. The first step is to instantiate a Citator , which by default contains all of CiteURL's built-in Templates : from citeurl import Citator citator = Citator () After that, you can feed it text to return a list of Citations it finds: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator . list_citations ( text ) Once you have a list of citations, you can get information about each one: print ( citations [ 0 ] . text ) # 42 USC \u00a7 1988(b) print ( citations [ 0 ] . tokens ) # {'title': '42', 'section': '1988', 'subsection': '(b)'} print ( citations [ 0 ] . URL ) # https://www.law.cornell.edu/uscode/text/42/1988#b You can also use insert_links() to insert the citations back into the source text as HTML hyperlinks: from citeurl import insert_links output = insert_links ( citations , text ) Or, you can use list_authorities() to combine all the citations into a list of all the authorities cited in the text: from citeurl import list_authorities authorities = list_authorities ( citations ) for authority in authorities : auth_cites = authority . citations print ( f \" { authority } was cited { len ( auth_cites ) } time(s)\" ) # 42 USC \u00a7 1988 was cited 2 time(s) # 477 U.S. 561 was cited 2 time(s) # 475 U.S. 717 was cited 1 time(s) Citator CiteURL's main feature: a collection of templates, and the tools to apply them to text, to find all kinds of citations in a text. Attributes: Name Type Description templates list A list of template objects that this citator will try to match against. generic_id str A common regex the citator will append to each template when it is loaded, to recognize a simple citation to the most-recently cited source. __init__ ( self , yaml_paths = [], defaults = True , generic_id = ' \\\\ b(Ib)?[Ii]d \\\\ .(< \\\\ /(i|em|u)>)?' ) special Calls load_yaml one or more times, to load the citator with templates. Parameters: Name Type Description Default defaults bool Whether to load CiteURL's default templates True yaml_paths list paths to additional YAML files with templates that should be loaded to supplement or replace the defaults. [] generic_id str a common regex to append to all templates, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. '\\\\b(Ib)?[Ii]d\\\\.(<\\\\/(i|em|u)>)?' Source code in citeurl/__init__.py def __init__ ( self , yaml_paths : list [ str ] = [], defaults : bool = True , generic_id : str = GENERIC_ID ): \"\"\" Calls load_yaml one or more times, to load the citator with templates. Arguments: defaults: Whether to load CiteURL's default templates yaml_paths: paths to additional YAML files with templates that should be loaded to supplement or replace the defaults. generic_id: a common regex to append to all templates, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. \"\"\" self . generic_id : str = generic_id self . templates : list = [] if defaults : self . load_yaml ( DEFAULT_YAML_PATH ) for path in yaml_paths : self . load_yaml ( path ) insert_links ( self , text , attrs = { 'class' : 'citation' }, url_optional = False , link_detailed_ids = True , link_plain_ids = False , id_break_regex = 'L \\\\ . ?Rev \\\\ .|J \\\\ . ?Law| \\\\ . ?([Cc]ode|[Cc]onst)' , id_break_indices = []) Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. Source code in citeurl/__init__.py def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, url_optional : bool = False , link_detailed_ids : bool = True , link_plain_ids : bool = False , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = []) -> str : \"\"\" Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. \"\"\" citations = self . list_citations ( text , id_break_regex = id_break_regex , id_break_indices = id_break_indices ) return insert_links ( citations , text , attrs = attrs , link_detailed_ids = link_detailed_ids , link_plain_ids = link_plain_ids , url_optional = url_optional ) list_authorities ( self , text ) Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. Source code in citeurl/__init__.py def list_authorities ( self , text : str ) -> list : \"\"\" Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. \"\"\" citations = self . list_citations ( text ) return list_authorities ( citations ) list_citations ( self , text , id_forms = True , id_break_regex = 'L \\\\ . ?Rev \\\\ .|J \\\\ . ?Law| \\\\ . ?([Cc]ode|[Cc]onst)' , id_break_indices = []) Scan a text and return a list of all citations in it, in order of appearance. Parameters: Name Type Description Default id_forms bool Whether to detect citations like \"Id.\" and \"Id. at 30.\" True id_break_regex str A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. 'L\\\\. ?Rev\\\\.|J\\\\. ?Law|\\\\. ?([Cc]ode|[Cc]onst)' id_break_indices list A list of positions in the text where \"id.\" citations should be interrupted [] Returns: Type Description list A list of citation objects, in order of appearance in the text. Source code in citeurl/__init__.py def list_citations ( self , text : str , id_forms : bool = True , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = [], ) -> list : \"\"\" Scan a text and return a list of all citations in it, in order of appearance. Arguments: id_forms: Whether to detect citations like \"Id.\" and \"Id. at 30.\" id_break_regex: A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. id_break_indices: A list of positions in the text where \"id.\" citations should be interrupted Returns: A list of citation objects, in order of appearance in the text. \"\"\" # First, get full citations: citations = [] for template in self . templates : citations += template . get_citations ( text ) shortform_cites = [] # Then, add shortforms for citation in citations : shortform_cites += citation . _get_shortform_citations ( text ) citations += shortform_cites citations = _sort_and_remove_overlaps ( citations ) if not id_forms : # no need to proceed return citations # determine where to break chains of id. citations for citation in citations : # break at full or short citations id_break_indices . append ( citation . span [ 0 ]) if id_break_regex : #also break at specified regexes matches = re . compile ( id_break_regex ) . finditer ( text ) for match in matches : id_break_indices . append ( match . span ()[ 0 ]) id_break_indices = sorted ( set ( id_break_indices )) # loop through all citations to find their id citations id_citations = [] for citation in citations : # find the next id break point i = - 1 for index in id_break_indices : i += 1 if index > citation . span [ 1 ]: end_point = index break else : end_point = None id_break_indices = id_break_indices [ i :] # get each citation's id citations until the break point id_citations += citation . _get_id_citations ( text , end_point = end_point ) return _sort_and_remove_overlaps ( citations + id_citations ) load_yaml ( self , path , use_generic_id = True ) Import templates from the specified YAML file into the citator. Parameters: Name Type Description Default path str path to the YAML file to load required use_generic_id bool Whether to append the citator's generic_id True Source code in citeurl/__init__.py def load_yaml ( self , path : str , use_generic_id : bool = True ): \"\"\" Import templates from the specified YAML file into the citator. Arguments: path: path to the YAML file to load use_generic_id: Whether to append the citator's generic_id citation format to the loaded templates. \"\"\" yaml_text = Path ( path ) . read_text () yaml_dict = safe_load ( yaml_text ) # read each item in the YAML into a new template for template_name , template_data in yaml_dict . items (): # if regex is specified in singular form, convert it to a # list with one item, for sake of consistency with multiple- # regex templates. for key in [ 'regex' , 'broadRegex' ]: if key in template_data : template_data [ key + 'es' ] = [ template_data . pop ( key )] # unrelated: if an individual regex is given as a list of # strings (convenient for reusing YAML anchors), concatenate # it to one string. for key in [ 'regexes' , 'broadRegexes' , 'idForms' , 'shortForms' ]: if key not in template_data : continue for i , regex in enumerate ( template_data [ key ]): if type ( regex ) is list : template_data [ key ][ i ] = '' . join ( regex ) # make the template and add it to the citator, adding the # generic id-form citation if applicable new_template = Template ( name = template_name , ** template_data ) if use_generic_id and self . generic_id : new_template . idForms . append ( self . generic_id ) self . templates . append ( new_template ) lookup ( self , query , broad = True ) Convenience method to get the first citation from the first matching template, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Parameters: Name Type Description Default broad bool Whether to use case-insensitive regex matching and, if available, each template's broadRegex. True query str The text to scan for a citation required Returns: Type Description Citation A single citation object, or None Source code in citeurl/__init__.py def lookup ( self , query : str , broad : bool = True ) -> Citation : \"\"\" Convenience method to get the first citation from the first matching template, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Arguments: broad: Whether to use case-insensitive regex matching and, if available, each template's broadRegex. query: The text to scan for a citation Returns: A single citation object, or None \"\"\" for template in self . templates : citation = next ( template . get_citations ( query , broad = broad ), None ) if citation : return citation return None Template A pattern to recognize a single kind of citation and generate URLs from matches. In most cases, it is more useful to use the Citator class to load templates from YAML files and apply them en masse, rather than use the Template class directly. __init__ ( self , name , regexes , URL = None , broadRegexes = None , idForms = [], shortForms = [], defaults = {}, operations = [], parent_citation = None , _is_id = False ) special Template constructor. Primarily meant for use in loading YAML files and dynamically generating shortform templates, but can be run directly if needed. Parameters: Name Type Description Default name str The name of this template required regexes list A list of one or more regexes that this template will match. Each regex should be provided as a string, and should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. required URL The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed by the template The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. None defaults dict A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. {} operations list A list of operations to perform on the tokens, in sequence, to transform them from captured_tokens to processed_tokens , the tokens that are used for URL generation. Each operation must specify a token for its input. It will also be used as the output of the operation, unless output is specified. If the specified input token is not set, the operation will be skipped. The supported operations are case , sub , lookup , optionalLookup , lpad , and numberFormat . The case operation outputs the input token, set to the specified capitalization, either 'upper', 'lower', or 'title'. The sub operation performs a regex substitution. It requires a list of two strings; the first is the regex to match in the input token, and the second is the text to replace each match with. The lookup operation tries to match the input against a series of dictionary keys (using case-insensitive regex), and set the output to the corresponding value. If the dictionary does not contain a matching key, the entire template match will retroactively fail. optionalLookup works the same way, except that failed lookups will not cause the template to fail, and will simply leave tokens unmodified. The numberFormat operation assumes that the input token is a number, either in digit form or Roman numerals. It outputs the same number, converted to the specified number format, either 'roman' or 'digit'. [] shortForms list A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a template detects a longform citation to \"372 U.S. 335\" and has a shortform {volume} {reporter} at (?P<pincite>\\d+) , it will generate the following regex: 372 U.S. at (?P<pincite>\\d+) . [] idForms list Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. [] parent_citation Citation The citation, if any, that this template was created as a shortform of. This argument is for dynamically-generated templates, and there is usually no need to use it manually. None Source code in citeurl/__init__.py def __init__ ( self , name : str , regexes : list [ str ], URL = None , broadRegexes : list [ str ] = None , idForms : list [ str ] = [], shortForms : list [ str ] = [], defaults : dict = {}, operations : list [ dict ] = [], parent_citation : Citation = None , _is_id = False ): \"\"\" Template constructor. Primarily meant for use in loading YAML files and dynamically generating shortform templates, but can be run directly if needed. Arguments: name: The name of this template regexes: A list of one or more regexes that this template will match. Each regex should be provided as a string, and should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. URL: The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed by the template The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. defaults: A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. operations: A list of operations to perform on the tokens, in sequence, to transform them from `captured_tokens` to `processed_tokens`, the tokens that are used for URL generation. Each operation must specify a `token` for its input. It will also be used as the output of the operation, unless `output` is specified. If the specified input token is not set, the operation will be skipped. The supported operations are `case`, `sub`, `lookup`, `optionalLookup`, `lpad`, and `numberFormat`. The `case` operation outputs the input token, set to the specified capitalization, either 'upper', 'lower', or 'title'. The `sub` operation performs a regex substitution. It requires a list of two strings; the first is the regex to match in the input token, and the second is the text to replace each match with. The `lookup` operation tries to match the input against a series of dictionary keys (using case-insensitive regex), and set the output to the corresponding value. If the dictionary does not contain a matching key, the entire template match will retroactively fail. `optionalLookup` works the same way, except that failed lookups will not cause the template to fail, and will simply leave tokens unmodified. The `numberFormat` operation assumes that the input token is a number, either in digit form or Roman numerals. It outputs the same number, converted to the specified number format, either 'roman' or 'digit'. shortForms: A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a template detects a longform citation to \"372 U.S. 335\" and has a shortform `{volume} {reporter} at (?P<pincite>\\d+)`, it will generate the following regex: `372 U.S. at (?P<pincite>\\d+)`. idForms: Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. parent_citation: The citation, if any, that this template was created as a shortform of. This argument is for dynamically-generated templates, and there is usually no need to use it manually. \"\"\" # Basic values self . name : str = name self . regexes : str = regexes self . is_id : bool = _is_id if URL : self . URL : str = URL if type ( URL ) is list else [ URL ] # Supplemental regexes self . broadRegexes : str = broadRegexes self . idForms : list = idForms self . shortForms : list = shortForms # String operators self . defaults : dict = defaults self . operations : list = operations # Extra data for shortform citations self . parent_citation : Citation = parent_citation # hack: prevent all regexes from matching mid-word for key in [ 'regexes' , 'broadRegexes' , 'idForms' , 'shortForms' ]: regex_list = self . __dict__ [ key ] if not regex_list : continue regex_list = list ( map ( lambda x : r '(\\b|^)' + x , regex_list )) # dictionaries of compiled regexes self . _compiled_regexes : dict = {} self . _compiled_broadRegexes : dict = {} get_citations ( self , text , broad = False , span = ( 0 ,)) Generator to return all citations the template finds in text. Parameters: Name Type Description Default text str The text to scan for a citation required broad bool Whether to use case-insensitive regex matching and, if available, the template's broadRegex. False span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Iterable Generator that yields each citation the template finds in the text, or None. Source code in citeurl/__init__.py def get_citations ( self , text : str , broad : bool = False , span : tuple = ( 0 ,) ) -> Iterable : \"\"\" Generator to return all citations the template finds in text. Arguments: text: The text to scan for a citation broad: Whether to use case-insensitive regex matching and, if available, the template's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: Generator that yields each citation the template finds in the text, or None. \"\"\" matches = [] regex_count = len ( self . regexes ) if broad and self . broadRegexes : regex_count += len ( self . broadRegexes ) for index in range ( regex_count ): #print(f'scanning regex {index} for template {self}') matches += self . _compiled_re ( index , broad ) . finditer ( text , * span ) for match in matches : try : citation = Citation ( match , self ) # skip citations where lookup failed: except KeyError as e : citation = None if citation : yield citation return None lookup ( self , text , broad = True , span = ( 0 ,)) Returns the first citation it finds in the text, or None. Parameters: Name Type Description Default text str The text to scan for a citation. required broad bool Whether to use case-insensitive regex matching and, if available, the template's broadRegex. True span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Citation The first citation this template finds in the scanned text, or None. Source code in citeurl/__init__.py def lookup ( self , text : str , broad : bool = True , span : tuple = ( 0 ,) ) -> Citation : \"\"\" Returns the first citation it finds in the text, or None. Arguments: text: The text to scan for a citation. broad: Whether to use case-insensitive regex matching and, if available, the template's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: The first citation this template finds in the scanned text, or None. \"\"\" try : return next ( self . get_citations ( text , broad = broad , span = span )) except : return None Citation A single citation found in text. Attributes: Name Type Description text str The text of the citation itself, like \"42 USC \u00a7 1988(b)\" span tuple The beginning and end positions of this citation in the source text. template Template The template which recognized this citation tokens dict Dictionary of the named capture groups from the regex this citation matched. For \"id.\" and \"shortform\" citations, this includes tokens carried over from the parent citation. processed_tokens dict Dictionary of tokens after they have been modified via the template's processes. URL str The URL where a user can read this citation online authority The Authority that this citation is a reference to. This attribute is not set until list_authorities() is run. __init__ ( self , match , template ) special For internal use. There should be no need to create citations by means other than a Citator or Template object. Source code in citeurl/__init__.py def __init__ ( self , match : re . Match , template ): \"\"\" For internal use. There should be no need to create citations by means other than a Citator or Template object. \"\"\" self . span : tuple = match . span () self . template : Template = template self . text : str = match . group ( 0 ) # idForm and shortForm citations get values from parent citation # except where their regexes include space for those values if template . parent_citation : self . tokens : dict = dict ( template . parent_citation . tokens ) for key , val in match . groupdict () . items (): self . tokens [ key ] = val else : self . tokens : dict = match . groupdict () self . processed_tokens : dict = self . template . _process_tokens ( self . tokens ) self . URL : str = self . _get_url () get_link ( self , attrs = { 'class' : 'citation' }) Return citation's link element, with given attributes Source code in citeurl/__init__.py def get_link ( self , attrs : dict = { 'class' : 'citation' }): \"\"\"Return citation's link element, with given attributes\"\"\" if self . URL : attrs [ 'href' ] = self . URL else : del attrs [ 'href' ] attr_str = '' for key , value in attrs . items (): attr_str += ' %s =\" %s \"' % ( key , value ) return '<a %s > %s </a>' % ( attr_str , self . text ) Authority A single source cited one or more times in a text. Attributes: Name Type Description defining_tokens dict A dictionary of tokens that define this authority, such that any citations with incompatible token values will not match it. Note that this uses processed_tokens (those which have been modified by the template's operations). template Template The template which found all the citations to this authority citations list The list of all the citations that refer to this authority. base_citation Citation A citation object representing the hypothetical generic citation to this authority. name str The text of base_citation __init__ ( self , first_cite , allowed_differences = []) special Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Parameters: Name Type Description Default first_cite Citation A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_citation. required allowed_differences list A list of tokens whose values can differ among citations to the same authority [] Source code in citeurl/__init__.py def __init__ ( self , first_cite : Citation , allowed_differences : list = []): \"\"\" Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Arguments: first_cite: A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_citation. allowed_differences: A list of tokens whose values can differ among citations to the same authority \"\"\" long_cite = first_cite . _original_cite () self . template : Template = long_cite . template self . citations : list = [ first_cite ] # List the token values that distinguish this authority from # others in the same template. This uses processed tokens, not # raw, so that a citation to \"50 U.S. 5\" will match # a citation to \"50 U. S. 5\", etc. self . defining_tokens : dict = {} for t in first_cite . processed_tokens : if ( first_cite . processed_tokens [ t ] != None and t not in allowed_differences ): self . defining_tokens [ t ] = first_cite . processed_tokens [ t ] # Next, derive a base citation to represent this authority. # If the first_citation to this authority isn't a longform, use # whatever longform it's a child of. self . base_citation : Citation = None try : self . base_citation = self . _derive_base_citation ( long_cite ) except TypeError : self . base_citation = first_cite # Set other instance variables self . name : str = self . base_citation . text self . URL : str = self . base_citation . URL # finally, give the first citation a reference to this authority first_cite . authority = self include ( self , citation ) Adds the citation to this authority's list of citations. Also, adds the authority tag to the citation, referring back to this authority. Source code in citeurl/__init__.py def include ( self , citation ): \"\"\"Adds the citation to this authority's list of citations. Also, adds the `authority` tag to the citation, referring back to this authority.\"\"\" self . citations . append ( citation ) citation . authority = self matches ( self , citation ) Checks whether a given citation matches the template and defining tokens of this authority. Source code in citeurl/__init__.py def matches ( self , citation ) -> bool : \"\"\" Checks whether a given citation matches the template and defining tokens of this authority. \"\"\" if self . template . name != citation . template . name : return False for key , value in self . defining_tokens . items (): if ( key not in citation . processed_tokens or citation . processed_tokens [ key ] != value ): return False return True insert_links() Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Parameters: Name Type Description Default citations list A list of citation objects found in the text required text str The text the citations were found in required attrs dict HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. {'class': 'citation'} link_detailed_ids bool Whether to insert hyperlinks for citations like \"Id. at 30.\" True link_plain_ids bool Whether to insert hyperlinks for simple repeat citations like \"id.\" False url_optional bool Whether to insert link elements for citations that do not have an associated URL False Returns: Type Description str The input text, with HTML links inserted for each citation Source code in citeurl/__init__.py def insert_links ( citations : list , text : str , attrs : dict = { 'class' : 'citation' }, link_detailed_ids : bool = True , link_plain_ids : bool = False , url_optional : bool = False ) -> str : \"\"\" Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Arguments: citations: A list of citation objects found in the text text: The text the citations were found in attrs: HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. link_detailed_ids: Whether to insert hyperlinks for citations like \"Id. at 30.\" link_plain_ids: Whether to insert hyperlinks for simple repeat citations like \"id.\" url_optional: Whether to insert link elements for citations that do not have an associated URL Returns: The input text, with HTML links inserted for each citation \"\"\" offset = 0 for citation in citations : # by default, skip citations without URLs if not citation . URL and not url_optional : continue if citation . template . is_id : # check whether the matched citation is from a template that # has any named capture groups. If it doesn't, it's a # \"plain id.\" and should normally be skipped if not '(?P<' in citation . template . _compiled_re () . pattern : if not link_plain_ids : continue elif not link_detailed_ids : continue link = citation . get_link ( attrs = attrs ) # insert each link into the proper place by offsetting later # citations by however many extra characters are added by each cite_start = citation . span [ 0 ] + offset cite_end = citation . span [ 1 ] + offset text = '' . join ([ text [: cite_start ], link , text [ cite_end :]]) offset += len ( link ) - len ( citation . text ) return text list_authorities() Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an authority attribute referring to the proper authority. Parameters: Name Type Description Default citations list The list of citations to combine required irrelevant_tokens list A list of tokens whose values may differ among citations to the same authority. ['subsection', 'subdivision', 'clause', 'pincite', 'pincite_end', 'footnote'] Returns: Type Description list A list of authority objects, sorted by the number of citations that refer to each, from most to least. Source code in citeurl/__init__.py def list_authorities ( citations : list , irrelevant_tokens : list = NON_AUTHORITY_TOKENS ) -> list : \"\"\" Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an `authority` attribute referring to the proper authority. Arguments: citations: The list of citations to combine irrelevant_tokens: A list of tokens whose values may differ among citations to the same authority. Returns: A list of authority objects, sorted by the number of citations that refer to each, from most to least. \"\"\" authorities = [] for citation in citations : for authority in authorities : if authority . matches ( citation ): authority . include ( citation ) break else : authorities . append ( Authority ( citation , irrelevant_tokens )) def authority_sort_key ( authority ): return 0 - len ( authority . citations ) return sorted ( authorities , key = authority_sort_key )","title":"Library Reference"},{"location":"library/#library-reference","text":"This page documents how to include CiteURL in your Python programming projects. The first step is to instantiate a Citator , which by default contains all of CiteURL's built-in Templates : from citeurl import Citator citator = Citator () After that, you can feed it text to return a list of Citations it finds: text = \"\"\" Federal law provides that courts should award prevailing civil rights plaintiffs reasonable attorneys fees, 42 USC \u00a7 1988(b), and, by discretion, expert fees, id. at (c). This is because the importance of civil rights litigation cannot be measured by a damages judgment. See Riverside v. Rivera, 477 U.S. 561 (1986). But Evans v. Jeff D. upheld a settlement where the plaintiffs got everything they wanted, on condition that they waive attorneys' fees. 475 U.S. 717 (1986). This ruling lets savvy defendants create a wedge between plaintiffs and their attorneys, discouraging civil rights suits and undermining the court's logic in Riverside, 477 U.S. at 574-78. \"\"\" citations = citator . list_citations ( text ) Once you have a list of citations, you can get information about each one: print ( citations [ 0 ] . text ) # 42 USC \u00a7 1988(b) print ( citations [ 0 ] . tokens ) # {'title': '42', 'section': '1988', 'subsection': '(b)'} print ( citations [ 0 ] . URL ) # https://www.law.cornell.edu/uscode/text/42/1988#b You can also use insert_links() to insert the citations back into the source text as HTML hyperlinks: from citeurl import insert_links output = insert_links ( citations , text ) Or, you can use list_authorities() to combine all the citations into a list of all the authorities cited in the text: from citeurl import list_authorities authorities = list_authorities ( citations ) for authority in authorities : auth_cites = authority . citations print ( f \" { authority } was cited { len ( auth_cites ) } time(s)\" ) # 42 USC \u00a7 1988 was cited 2 time(s) # 477 U.S. 561 was cited 2 time(s) # 475 U.S. 717 was cited 1 time(s)","title":"Library Reference"},{"location":"library/#citator","text":"CiteURL's main feature: a collection of templates, and the tools to apply them to text, to find all kinds of citations in a text. Attributes: Name Type Description templates list A list of template objects that this citator will try to match against. generic_id str A common regex the citator will append to each template when it is loaded, to recognize a simple citation to the most-recently cited source.","title":"Citator"},{"location":"library/#citeurl.Citator.__init__","text":"Calls load_yaml one or more times, to load the citator with templates. Parameters: Name Type Description Default defaults bool Whether to load CiteURL's default templates True yaml_paths list paths to additional YAML files with templates that should be loaded to supplement or replace the defaults. [] generic_id str a common regex to append to all templates, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. '\\\\b(Ib)?[Ii]d\\\\.(<\\\\/(i|em|u)>)?' Source code in citeurl/__init__.py def __init__ ( self , yaml_paths : list [ str ] = [], defaults : bool = True , generic_id : str = GENERIC_ID ): \"\"\" Calls load_yaml one or more times, to load the citator with templates. Arguments: defaults: Whether to load CiteURL's default templates yaml_paths: paths to additional YAML files with templates that should be loaded to supplement or replace the defaults. generic_id: a common regex to append to all templates, to recognize a simple citation to the most-recently cited source. Detects \"id.\" or \"ibid.\" by default. To disable, set to None. \"\"\" self . generic_id : str = generic_id self . templates : list = [] if defaults : self . load_yaml ( DEFAULT_YAML_PATH ) for path in yaml_paths : self . load_yaml ( path )","title":"__init__()"},{"location":"library/#citeurl.Citator.insert_links","text":"Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. Source code in citeurl/__init__.py def insert_links ( self , text : str , attrs : dict = { 'class' : 'citation' }, url_optional : bool = False , link_detailed_ids : bool = True , link_plain_ids : bool = False , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = []) -> str : \"\"\" Convenience method to return a copy of the given text, with citation hyperlinks inserted. If you plan to do more than just insert links, it's better to get a list of citations with list_citations first, then insert those links with the module-wide insert_links function. \"\"\" citations = self . list_citations ( text , id_break_regex = id_break_regex , id_break_indices = id_break_indices ) return insert_links ( citations , text , attrs = attrs , link_detailed_ids = link_detailed_ids , link_plain_ids = link_plain_ids , url_optional = url_optional )","title":"insert_links()"},{"location":"library/#citeurl.Citator.list_authorities","text":"Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. Source code in citeurl/__init__.py def list_authorities ( self , text : str ) -> list : \"\"\" Convenience method to list all the authorities cited in a given text. If you plan to do more than list authorities, it's better to get a list of citations with list_citations, then list the unique authorities with the module-wide list_authorities function. \"\"\" citations = self . list_citations ( text ) return list_authorities ( citations )","title":"list_authorities()"},{"location":"library/#citeurl.Citator.list_citations","text":"Scan a text and return a list of all citations in it, in order of appearance. Parameters: Name Type Description Default id_forms bool Whether to detect citations like \"Id.\" and \"Id. at 30.\" True id_break_regex str A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. 'L\\\\. ?Rev\\\\.|J\\\\. ?Law|\\\\. ?([Cc]ode|[Cc]onst)' id_break_indices list A list of positions in the text where \"id.\" citations should be interrupted [] Returns: Type Description list A list of citation objects, in order of appearance in the text. Source code in citeurl/__init__.py def list_citations ( self , text : str , id_forms : bool = True , id_break_regex : str = DEFAULT_ID_BREAKS , id_break_indices : list = [], ) -> list : \"\"\" Scan a text and return a list of all citations in it, in order of appearance. Arguments: id_forms: Whether to detect citations like \"Id.\" and \"Id. at 30.\" id_break_regex: A pattern to look for in the text. Any occurrence of the pattern will interrupt a chain of \"id.\" citations as if it were another citation. id_break_indices: A list of positions in the text where \"id.\" citations should be interrupted Returns: A list of citation objects, in order of appearance in the text. \"\"\" # First, get full citations: citations = [] for template in self . templates : citations += template . get_citations ( text ) shortform_cites = [] # Then, add shortforms for citation in citations : shortform_cites += citation . _get_shortform_citations ( text ) citations += shortform_cites citations = _sort_and_remove_overlaps ( citations ) if not id_forms : # no need to proceed return citations # determine where to break chains of id. citations for citation in citations : # break at full or short citations id_break_indices . append ( citation . span [ 0 ]) if id_break_regex : #also break at specified regexes matches = re . compile ( id_break_regex ) . finditer ( text ) for match in matches : id_break_indices . append ( match . span ()[ 0 ]) id_break_indices = sorted ( set ( id_break_indices )) # loop through all citations to find their id citations id_citations = [] for citation in citations : # find the next id break point i = - 1 for index in id_break_indices : i += 1 if index > citation . span [ 1 ]: end_point = index break else : end_point = None id_break_indices = id_break_indices [ i :] # get each citation's id citations until the break point id_citations += citation . _get_id_citations ( text , end_point = end_point ) return _sort_and_remove_overlaps ( citations + id_citations )","title":"list_citations()"},{"location":"library/#citeurl.Citator.load_yaml","text":"Import templates from the specified YAML file into the citator. Parameters: Name Type Description Default path str path to the YAML file to load required use_generic_id bool Whether to append the citator's generic_id True Source code in citeurl/__init__.py def load_yaml ( self , path : str , use_generic_id : bool = True ): \"\"\" Import templates from the specified YAML file into the citator. Arguments: path: path to the YAML file to load use_generic_id: Whether to append the citator's generic_id citation format to the loaded templates. \"\"\" yaml_text = Path ( path ) . read_text () yaml_dict = safe_load ( yaml_text ) # read each item in the YAML into a new template for template_name , template_data in yaml_dict . items (): # if regex is specified in singular form, convert it to a # list with one item, for sake of consistency with multiple- # regex templates. for key in [ 'regex' , 'broadRegex' ]: if key in template_data : template_data [ key + 'es' ] = [ template_data . pop ( key )] # unrelated: if an individual regex is given as a list of # strings (convenient for reusing YAML anchors), concatenate # it to one string. for key in [ 'regexes' , 'broadRegexes' , 'idForms' , 'shortForms' ]: if key not in template_data : continue for i , regex in enumerate ( template_data [ key ]): if type ( regex ) is list : template_data [ key ][ i ] = '' . join ( regex ) # make the template and add it to the citator, adding the # generic id-form citation if applicable new_template = Template ( name = template_name , ** template_data ) if use_generic_id and self . generic_id : new_template . idForms . append ( self . generic_id ) self . templates . append ( new_template )","title":"load_yaml()"},{"location":"library/#citeurl.Citator.lookup","text":"Convenience method to get the first citation from the first matching template, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Parameters: Name Type Description Default broad bool Whether to use case-insensitive regex matching and, if available, each template's broadRegex. True query str The text to scan for a citation required Returns: Type Description Citation A single citation object, or None Source code in citeurl/__init__.py def lookup ( self , query : str , broad : bool = True ) -> Citation : \"\"\" Convenience method to get the first citation from the first matching template, or None. This is meant for cases where false positives are not an issue, so it uses broadRegex and case-insensitive matching by default. Arguments: broad: Whether to use case-insensitive regex matching and, if available, each template's broadRegex. query: The text to scan for a citation Returns: A single citation object, or None \"\"\" for template in self . templates : citation = next ( template . get_citations ( query , broad = broad ), None ) if citation : return citation return None","title":"lookup()"},{"location":"library/#template","text":"A pattern to recognize a single kind of citation and generate URLs from matches. In most cases, it is more useful to use the Citator class to load templates from YAML files and apply them en masse, rather than use the Template class directly.","title":"Template"},{"location":"library/#citeurl.Template.__init__","text":"Template constructor. Primarily meant for use in loading YAML files and dynamically generating shortform templates, but can be run directly if needed. Parameters: Name Type Description Default name str The name of this template required regexes list A list of one or more regexes that this template will match. Each regex should be provided as a string, and should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. required URL The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed by the template The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. None defaults dict A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. {} operations list A list of operations to perform on the tokens, in sequence, to transform them from captured_tokens to processed_tokens , the tokens that are used for URL generation. Each operation must specify a token for its input. It will also be used as the output of the operation, unless output is specified. If the specified input token is not set, the operation will be skipped. The supported operations are case , sub , lookup , optionalLookup , lpad , and numberFormat . The case operation outputs the input token, set to the specified capitalization, either 'upper', 'lower', or 'title'. The sub operation performs a regex substitution. It requires a list of two strings; the first is the regex to match in the input token, and the second is the text to replace each match with. The lookup operation tries to match the input against a series of dictionary keys (using case-insensitive regex), and set the output to the corresponding value. If the dictionary does not contain a matching key, the entire template match will retroactively fail. optionalLookup works the same way, except that failed lookups will not cause the template to fail, and will simply leave tokens unmodified. The numberFormat operation assumes that the input token is a number, either in digit form or Roman numerals. It outputs the same number, converted to the specified number format, either 'roman' or 'digit'. [] shortForms list A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a template detects a longform citation to \"372 U.S. 335\" and has a shortform {volume} {reporter} at (?P<pincite>\\d+) , it will generate the following regex: 372 U.S. at (?P<pincite>\\d+) . [] idForms list Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. [] parent_citation Citation The citation, if any, that this template was created as a shortform of. This argument is for dynamically-generated templates, and there is usually no need to use it manually. None Source code in citeurl/__init__.py def __init__ ( self , name : str , regexes : list [ str ], URL = None , broadRegexes : list [ str ] = None , idForms : list [ str ] = [], shortForms : list [ str ] = [], defaults : dict = {}, operations : list [ dict ] = [], parent_citation : Citation = None , _is_id = False ): \"\"\" Template constructor. Primarily meant for use in loading YAML files and dynamically generating shortform templates, but can be run directly if needed. Arguments: name: The name of this template regexes: A list of one or more regexes that this template will match. Each regex should be provided as a string, and should include one or more named capture groups (i.e. \"tokens\") that will be used to generate the URL. URL: The template by which to generate URLs from citation matches. Placeholders in {curly braces} will be replaced by the value of the token with the same name, after that token has been processed by the template The URL template can be provided either as as a string or as a list of strings to concatenate. In the latter case, if a list item contains a placeholder for which no value is set, the list item will be skipped. defaults: A dictionary of tokens and corresponding default values which should be set if the token's value is not otherwise set by a regex capture group. operations: A list of operations to perform on the tokens, in sequence, to transform them from `captured_tokens` to `processed_tokens`, the tokens that are used for URL generation. Each operation must specify a `token` for its input. It will also be used as the output of the operation, unless `output` is specified. If the specified input token is not set, the operation will be skipped. The supported operations are `case`, `sub`, `lookup`, `optionalLookup`, `lpad`, and `numberFormat`. The `case` operation outputs the input token, set to the specified capitalization, either 'upper', 'lower', or 'title'. The `sub` operation performs a regex substitution. It requires a list of two strings; the first is the regex to match in the input token, and the second is the text to replace each match with. The `lookup` operation tries to match the input against a series of dictionary keys (using case-insensitive regex), and set the output to the corresponding value. If the dictionary does not contain a matching key, the entire template match will retroactively fail. `optionalLookup` works the same way, except that failed lookups will not cause the template to fail, and will simply leave tokens unmodified. The `numberFormat` operation assumes that the input token is a number, either in digit form or Roman numerals. It outputs the same number, converted to the specified number format, either 'roman' or 'digit'. shortForms: A list of regex templates to generate regexes that recognize short-forms of a parent long-form citation that has appeared earlier in the text. Any named section in {curly braces} will be replaced by the value of the corresponding token from the parent citation. So if a template detects a longform citation to \"372 U.S. 335\" and has a shortform `{volume} {reporter} at (?P<pincite>\\d+)`, it will generate the following regex: `372 U.S. at (?P<pincite>\\d+)`. idForms: Think \"id.\", not ID. Identical to shortForms, except that these regexes will only match until the next different citation or other interruption. parent_citation: The citation, if any, that this template was created as a shortform of. This argument is for dynamically-generated templates, and there is usually no need to use it manually. \"\"\" # Basic values self . name : str = name self . regexes : str = regexes self . is_id : bool = _is_id if URL : self . URL : str = URL if type ( URL ) is list else [ URL ] # Supplemental regexes self . broadRegexes : str = broadRegexes self . idForms : list = idForms self . shortForms : list = shortForms # String operators self . defaults : dict = defaults self . operations : list = operations # Extra data for shortform citations self . parent_citation : Citation = parent_citation # hack: prevent all regexes from matching mid-word for key in [ 'regexes' , 'broadRegexes' , 'idForms' , 'shortForms' ]: regex_list = self . __dict__ [ key ] if not regex_list : continue regex_list = list ( map ( lambda x : r '(\\b|^)' + x , regex_list )) # dictionaries of compiled regexes self . _compiled_regexes : dict = {} self . _compiled_broadRegexes : dict = {}","title":"__init__()"},{"location":"library/#citeurl.Template.get_citations","text":"Generator to return all citations the template finds in text. Parameters: Name Type Description Default text str The text to scan for a citation required broad bool Whether to use case-insensitive regex matching and, if available, the template's broadRegex. False span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Iterable Generator that yields each citation the template finds in the text, or None. Source code in citeurl/__init__.py def get_citations ( self , text : str , broad : bool = False , span : tuple = ( 0 ,) ) -> Iterable : \"\"\" Generator to return all citations the template finds in text. Arguments: text: The text to scan for a citation broad: Whether to use case-insensitive regex matching and, if available, the template's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: Generator that yields each citation the template finds in the text, or None. \"\"\" matches = [] regex_count = len ( self . regexes ) if broad and self . broadRegexes : regex_count += len ( self . broadRegexes ) for index in range ( regex_count ): #print(f'scanning regex {index} for template {self}') matches += self . _compiled_re ( index , broad ) . finditer ( text , * span ) for match in matches : try : citation = Citation ( match , self ) # skip citations where lookup failed: except KeyError as e : citation = None if citation : yield citation return None","title":"get_citations()"},{"location":"library/#citeurl.Template.lookup","text":"Returns the first citation it finds in the text, or None. Parameters: Name Type Description Default text str The text to scan for a citation. required broad bool Whether to use case-insensitive regex matching and, if available, the template's broadRegex. True span tuple A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. (0,) Returns: Type Description Citation The first citation this template finds in the scanned text, or None. Source code in citeurl/__init__.py def lookup ( self , text : str , broad : bool = True , span : tuple = ( 0 ,) ) -> Citation : \"\"\" Returns the first citation it finds in the text, or None. Arguments: text: The text to scan for a citation. broad: Whether to use case-insensitive regex matching and, if available, the template's broadRegex. span: A tuple of one or two values determining the start and end index of where in the text to search for citations. Defaults to (0,) to scan the entire text. Returns: The first citation this template finds in the scanned text, or None. \"\"\" try : return next ( self . get_citations ( text , broad = broad , span = span )) except : return None","title":"lookup()"},{"location":"library/#citation","text":"A single citation found in text. Attributes: Name Type Description text str The text of the citation itself, like \"42 USC \u00a7 1988(b)\" span tuple The beginning and end positions of this citation in the source text. template Template The template which recognized this citation tokens dict Dictionary of the named capture groups from the regex this citation matched. For \"id.\" and \"shortform\" citations, this includes tokens carried over from the parent citation. processed_tokens dict Dictionary of tokens after they have been modified via the template's processes. URL str The URL where a user can read this citation online authority The Authority that this citation is a reference to. This attribute is not set until list_authorities() is run.","title":"Citation"},{"location":"library/#citeurl.Citation.__init__","text":"For internal use. There should be no need to create citations by means other than a Citator or Template object. Source code in citeurl/__init__.py def __init__ ( self , match : re . Match , template ): \"\"\" For internal use. There should be no need to create citations by means other than a Citator or Template object. \"\"\" self . span : tuple = match . span () self . template : Template = template self . text : str = match . group ( 0 ) # idForm and shortForm citations get values from parent citation # except where their regexes include space for those values if template . parent_citation : self . tokens : dict = dict ( template . parent_citation . tokens ) for key , val in match . groupdict () . items (): self . tokens [ key ] = val else : self . tokens : dict = match . groupdict () self . processed_tokens : dict = self . template . _process_tokens ( self . tokens ) self . URL : str = self . _get_url ()","title":"__init__()"},{"location":"library/#citeurl.Citation.get_link","text":"Return citation's link element, with given attributes Source code in citeurl/__init__.py def get_link ( self , attrs : dict = { 'class' : 'citation' }): \"\"\"Return citation's link element, with given attributes\"\"\" if self . URL : attrs [ 'href' ] = self . URL else : del attrs [ 'href' ] attr_str = '' for key , value in attrs . items (): attr_str += ' %s =\" %s \"' % ( key , value ) return '<a %s > %s </a>' % ( attr_str , self . text )","title":"get_link()"},{"location":"library/#authority","text":"A single source cited one or more times in a text. Attributes: Name Type Description defining_tokens dict A dictionary of tokens that define this authority, such that any citations with incompatible token values will not match it. Note that this uses processed_tokens (those which have been modified by the template's operations). template Template The template which found all the citations to this authority citations list The list of all the citations that refer to this authority. base_citation Citation A citation object representing the hypothetical generic citation to this authority. name str The text of base_citation","title":"Authority"},{"location":"library/#citeurl.Authority.__init__","text":"Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Parameters: Name Type Description Default first_cite Citation A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_citation. required allowed_differences list A list of tokens whose values can differ among citations to the same authority [] Source code in citeurl/__init__.py def __init__ ( self , first_cite : Citation , allowed_differences : list = []): \"\"\" Define an authority by providing a single long-form citation, and the list of tokens which, if present in the citation, should be discarded from the definition of the authority. Generates a base_citation to represent the generic instance of this authority. Arguments: first_cite: A long-form citation object representing the first and archetypal citation to this authority. The first_cite will be added as the first entry in the authority's citation list, and it will be used as the basis to generate the authority's base_citation. allowed_differences: A list of tokens whose values can differ among citations to the same authority \"\"\" long_cite = first_cite . _original_cite () self . template : Template = long_cite . template self . citations : list = [ first_cite ] # List the token values that distinguish this authority from # others in the same template. This uses processed tokens, not # raw, so that a citation to \"50 U.S. 5\" will match # a citation to \"50 U. S. 5\", etc. self . defining_tokens : dict = {} for t in first_cite . processed_tokens : if ( first_cite . processed_tokens [ t ] != None and t not in allowed_differences ): self . defining_tokens [ t ] = first_cite . processed_tokens [ t ] # Next, derive a base citation to represent this authority. # If the first_citation to this authority isn't a longform, use # whatever longform it's a child of. self . base_citation : Citation = None try : self . base_citation = self . _derive_base_citation ( long_cite ) except TypeError : self . base_citation = first_cite # Set other instance variables self . name : str = self . base_citation . text self . URL : str = self . base_citation . URL # finally, give the first citation a reference to this authority first_cite . authority = self","title":"__init__()"},{"location":"library/#citeurl.Authority.include","text":"Adds the citation to this authority's list of citations. Also, adds the authority tag to the citation, referring back to this authority. Source code in citeurl/__init__.py def include ( self , citation ): \"\"\"Adds the citation to this authority's list of citations. Also, adds the `authority` tag to the citation, referring back to this authority.\"\"\" self . citations . append ( citation ) citation . authority = self","title":"include()"},{"location":"library/#citeurl.Authority.matches","text":"Checks whether a given citation matches the template and defining tokens of this authority. Source code in citeurl/__init__.py def matches ( self , citation ) -> bool : \"\"\" Checks whether a given citation matches the template and defining tokens of this authority. \"\"\" if self . template . name != citation . template . name : return False for key , value in self . defining_tokens . items (): if ( key not in citation . processed_tokens or citation . processed_tokens [ key ] != value ): return False return True","title":"matches()"},{"location":"library/#insert_links","text":"Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Parameters: Name Type Description Default citations list A list of citation objects found in the text required text str The text the citations were found in required attrs dict HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. {'class': 'citation'} link_detailed_ids bool Whether to insert hyperlinks for citations like \"Id. at 30.\" True link_plain_ids bool Whether to insert hyperlinks for simple repeat citations like \"id.\" False url_optional bool Whether to insert link elements for citations that do not have an associated URL False Returns: Type Description str The input text, with HTML links inserted for each citation Source code in citeurl/__init__.py def insert_links ( citations : list , text : str , attrs : dict = { 'class' : 'citation' }, link_detailed_ids : bool = True , link_plain_ids : bool = False , url_optional : bool = False ) -> str : \"\"\" Given a text and a list of citations found in it, return a text with an HTML hyperlink inserted for each citation. Arguments: citations: A list of citation objects found in the text text: The text the citations were found in attrs: HTML tag attributes (like css class, rel, etc) to give each inserted hyperlink. link_detailed_ids: Whether to insert hyperlinks for citations like \"Id. at 30.\" link_plain_ids: Whether to insert hyperlinks for simple repeat citations like \"id.\" url_optional: Whether to insert link elements for citations that do not have an associated URL Returns: The input text, with HTML links inserted for each citation \"\"\" offset = 0 for citation in citations : # by default, skip citations without URLs if not citation . URL and not url_optional : continue if citation . template . is_id : # check whether the matched citation is from a template that # has any named capture groups. If it doesn't, it's a # \"plain id.\" and should normally be skipped if not '(?P<' in citation . template . _compiled_re () . pattern : if not link_plain_ids : continue elif not link_detailed_ids : continue link = citation . get_link ( attrs = attrs ) # insert each link into the proper place by offsetting later # citations by however many extra characters are added by each cite_start = citation . span [ 0 ] + offset cite_end = citation . span [ 1 ] + offset text = '' . join ([ text [: cite_start ], link , text [ cite_end :]]) offset += len ( link ) - len ( citation . text ) return text","title":"insert_links()"},{"location":"library/#list_authorities","text":"Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an authority attribute referring to the proper authority. Parameters: Name Type Description Default citations list The list of citations to combine required irrelevant_tokens list A list of tokens whose values may differ among citations to the same authority. ['subsection', 'subdivision', 'clause', 'pincite', 'pincite_end', 'footnote'] Returns: Type Description list A list of authority objects, sorted by the number of citations that refer to each, from most to least. Source code in citeurl/__init__.py def list_authorities ( citations : list , irrelevant_tokens : list = NON_AUTHORITY_TOKENS ) -> list : \"\"\" Combine a list of citations into a list of authorities, each of which represents all the citations to a particular source. As a side-effect, this also gives each citation an `authority` attribute referring to the proper authority. Arguments: citations: The list of citations to combine irrelevant_tokens: A list of tokens whose values may differ among citations to the same authority. Returns: A list of authority objects, sorted by the number of citations that refer to each, from most to least. \"\"\" authorities = [] for citation in citations : for authority in authorities : if authority . matches ( citation ): authority . include ( citation ) break else : authorities . append ( Authority ( citation , irrelevant_tokens )) def authority_sort_key ( authority ): return 0 - len ( authority . citations ) return sorted ( authorities , key = authority_sort_key )","title":"list_authorities()"},{"location":"template-yamls/","text":"Writing Your Own Templates CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it can never support every possible kind of citation, especially for local laws and countries outside the U.S. For that reason, CiteURL is designed so that you can write your own citation templates in YAML format, and use them in various contexts: The citeurl command lets you can load these YAMLs with the -s option. The citeurl-makejs command uses them to generate custom JavaScript search engines . The Python library lets you load YAMLs when creating a Citator , though you can also define templates at runtime . This page details how to write these template files. Before you proceed, make sure you're at least a little familiar with Python regex , because the templates rely heavily on it. You'll also need some basic knowledge of YAML . Note : CiteURL's built-in templates are written in the same YAML format described on this page, so they are a good resource to help you write your own. You can also find a step-by-step summary of how each template works by opening a browser console with ctrl+shift+i while using Law Search . The Basic Template Format Here is a simplified example of a template that you might write to recognize citations to the U.S. Code: United States Code : regex : (?P<title>\\d+) USC \u00a7 (?P<section>\\d+) URL : https://www.law.cornell.edu/uscode/text/{title}/{section} This citation template recognizes any series of one or more digits, followed by \" USC \u00a7 \", followed by another series of digits. It knows that the first string of digits is something called a \"title\" and the second is a \"section\". We will call these stored values tokens . Finally, the template also has a pattern to generate a URL based on the recognized citation. It does this by replacing the placeholders (i.e. the parts in curly braces) with the values from the captured tokens. Although this template does not have any, it could also define operations to perform on the captured tokens before inserting them into the URL. Regex Complications In the example above, the regex is provided as a single string. This is perfectly valid, but templates' regexes can be much more complicated than that, for two reasons: A regex can be provided either as a string (as shown above), or as a list of strings. In the latter case, they will be concatenated (with no spaces) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using YAML anchors . Independent of the first reason, it is possible to give a template multiple regexes to match, by using the regexes key instead of regex . Normally, this will not be necessary, because the usual solution is to just write one regex to recognize multiple citation formats. However, regexes are limited in that capture groups cannot be rearranged. The example template above can be rewritten to take advantage of these two features, like so: United States Code regexes : - [ &title '(?P<title>\\d+)' , ' USC ' , &section '(Section|\u00a7) (?P<section>\\d+)' ] - [ *section , ' of Title ' , *title , ' of the United States Code' ] URL : https://www.law.cornell.edu/uscode/text/{title}/{section} The above template looks unwieldy, and it is; its regex is a list of lists. However, it provides two advantages over the first example: First, it is possible to recognize both \"42 USC \u00a7 1983\" and \"Section 1983 of Title 42 of the United States Code,\" which would be impossible with a single regex, since title and section are in a different order. Second, by using YAML anchors it is possible to reuse common pieces of regex, like *section , which can recognize either the word \"Section\" or a section sign (\"\u00a7\"). This can make it much easier to write and maintain large libraries of templates. URL Complications Another important feature is that a template's URL, like its regex(es), can be specified as a list of strings to concatenate. Unlike with regexes, splitting a URL into a list of strings makes it function differently: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. For instance, the template below can generate anchor links to subsections of the U.S. Code, but if no subsection is specified, it simply links to the overall page for the section itself: United States Code regex : (?P<title>\\d+) USC \u00a7 (?P<section>\\d+)( \\((?P<subsection>[a-z])\\)? URL : - 'https://www.law.cornell.edu/uscode/text/{title}/{section}' - '#{subsection}' Token Processing In many cases, the tokens matched in a citation won't directly correspond with the values that need to be inserted into the URL placeholder. For example, your template might detect a court reporter called \"F. App'x.\" or \"Pa. D. & C.4th\", but Case.Law 's URL scheme needs those reporters to be called \" f-appx \" and \" pa-d-c4th \", respectively. To solve this problem, CiteURL templates can specify operations that will be performed on the dictionary of matched tokens to turn them into a new dictionary (i.e. processed_tokens ) before using it to populate the URL. This example template solves the problem by converting the reporter token to lowercase, deleting some common special characters from it, and then replacing spaces with dashes: Caselaw Access Project (Simplified) : regex : (?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+) operations : - token : reporter case : lower - token : reporter sub : [ \"[.()&,']\" , '' ] - token : reporter sub : [ ' ' , '-' ] URL : https://cite.case.law/{reporter}/{volume}/{page} As shown above, a template's operations value is a list of operations that will be performed in sequence. Each operation is a dictionary that must specify a token to process, and the kind of operation to perform. Operations process a token in place by default, but if an output is specified, that token will be set or modified instead. The above example shows two kinds of operation: case modification ( case ), and regex substitution ( sub ), but CiteURL supports others as well: Operation Description Required Contents case sets the input token to the specified capitalization upper , lower , or title sub replaces all instances of the provided regex pattern with the replacement string [PATTERN, REPL] lookup uses case-insensitive regex matching to check the token against each pattern until it fully matches one of them, in which case it outputs the corresponding replacement string. If no pattern is matched, it causes the entire template match to retroactively fail, as if there had never been a regex match in the first place. {PATTERN: REPL, PATTERN: REPL ...} optionalLookup same as lookup , except that if the lookup fails, it simply proceeds without modifying any tokens {PATTERN: REPL, PATTERN: REPL ...} lpad adds zeros to the beginning of the token until it is the specified length an integer numberFormat assumes that the token is an integer in digit or roman numeral form, and converts it to the specified form, irrespective of which format it was originally in. The outputted roman numerals are capitalized. roman or digit One final note: If an operation's input token has not been set (as distinct from being set to an empty string), the operation will be skipped. Recognizing Shortform Citations Often, once a particular authority is cited once, subsequent references to it will take a shorter, more contextual format. For example, if a text cites United States v. An Article Consisting of Boxes of Clacker Balls , 413 F. Supp. 1281 (E.D. Wis. 1976), then immediately cites a specific page of it, the second citation might look something like \" Id . at 1284.\" Later, once a different authority has been cited in the interim, the same citation might be referred back to with a citation like \"413 F. Supp. at 1289.\" To address this, CiteURL can essentially generate new templates on the fly, whenever it detects a citation. These templates can be of two forms: shortForms and idForms . In each case, the template is only applied to text after the original long-form citation. The difference is that shortForms are applied to all of the remaining text, whereas idForms are only matched against the text in between one citation and the next. Note that the Citator.list_citations() function also accepts an interruption regex, all occurrences of which will break chains of idForm citations. Like URL templates, idForms and shortForms may contain placeholders in curly braces. These placeholders will be replaced with the corresponding token matched in the long-form citation, so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a template to recognize court cases: Caselaw Access Project (Simplified) : regex : (?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+)(, (?P<pincite>\\d+))? idForms : - Id\\. at (?P<pincite>\\d+) shortForms : - { volume } { reporter } at (?P<pincite>\\d+) This template will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex 372 U\\.S\\. at (?P<pincite>\\d+) , to recognize later citations to different pincites in the same case. To be precise, placeholders are replaced by the text as originally matched in the original regex capture group, before any operations are applied. This is normally the desired behavior, since operations often turn a token into something that would never be recognized. An exception applies where the placeholder refers to a token that only exists after operations are applied. In those cases, the processed token is used. This exception is useful in a few situations. For instance, a California court opinion might reference \"California Civil Code \u00a7 1946.2\" once early on, but then shift to a format like \"CIV \u00a7 1946.2\" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the \"Civil Code\" token, either. But this can be solved by using a substitution to recognize \"Civil Code\" and, from it, generate a new token \"CIV\", then generating a short citation form from that: California Codes : regex : California (?P<code>Civil Code|Penal Code) \u00a7 (?P<section>\\d+) operations : - token : code output : abbreviatedCode lookup : { 'Civil Code' : 'CIV' , 'Penal Code' : 'PEN' } shortForms : - { abbreviatedCode } \u00a7 (?P<section>\\d+) - { code } \u00a7 (?P<section>\\d+) Using the example template above, CiteURL will be able to recognize a longform citation to \"California Civil Code \u00a7 1946.2\", and then recognize subsequent citations either to \"Civil Code\" sections or \"CIV\" sections. One last note: Unlike a template's regex , shortForms and idForms are inherently lists, since they are designed to allow multiple alternative regexes. However, like the regex entry, individual list items can optionally be lists of strings, to accommodate YAML anchors. For instance, the following template is functionally identical to the Caselaw Access Project example above; the only difference is that I structured it so that I would only need to write (?P<pincite>\\d+) once: Caselaw Access Project (Simplified) : regex : - '(?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+)(, ' - &pin '(?P<pincite>\\d+)' - ')?' idForms : - [ 'Id\\. at ' , *pin ] shortForms : - [ '{volume} {reporter} at ' , *pin ] Miscellaneous Keys defaults defaults is a dictionary of tokens whose values will be set to specified values, if they are not set by a named capture group in the matched regex. Defaults are applied prior to any operations . For instance, the template below will match citations like \"29 USC \u00a7 157\" as well as citations like \"\u00a7 1983\", but in the latter case, it assumes that the title is '42' by default. U.S. Code, but especially Title 42 : regex : ((?P<title>\\d+) USC )?\u00a7 (?P<section>\\d+) defaults : { 'title' : '42' } broadRegex broadRegex and broadRegexes are identical in format to the regex and regexes keys. They allow you to specify extra regexes that will be used, in addition to the normal regex(es), in contexts like search engines where user convenience is more important than avoiding false positives. BroadRegexes are used by default in the lookup() method, as well as in JavaScript implementations , though if you are writing templates exclusively for these use cases rather than text processing, it is not important whether you use regexes or broadRegexes .","title":"Writing Your Own Templates"},{"location":"template-yamls/#writing-your-own-templates","text":"CiteURL supports a number of citation formats out-of-the box, and I try to add more when I can. However, it can never support every possible kind of citation, especially for local laws and countries outside the U.S. For that reason, CiteURL is designed so that you can write your own citation templates in YAML format, and use them in various contexts: The citeurl command lets you can load these YAMLs with the -s option. The citeurl-makejs command uses them to generate custom JavaScript search engines . The Python library lets you load YAMLs when creating a Citator , though you can also define templates at runtime . This page details how to write these template files. Before you proceed, make sure you're at least a little familiar with Python regex , because the templates rely heavily on it. You'll also need some basic knowledge of YAML . Note : CiteURL's built-in templates are written in the same YAML format described on this page, so they are a good resource to help you write your own. You can also find a step-by-step summary of how each template works by opening a browser console with ctrl+shift+i while using Law Search .","title":"Writing Your Own Templates"},{"location":"template-yamls/#the-basic-template-format","text":"Here is a simplified example of a template that you might write to recognize citations to the U.S. Code: United States Code : regex : (?P<title>\\d+) USC \u00a7 (?P<section>\\d+) URL : https://www.law.cornell.edu/uscode/text/{title}/{section} This citation template recognizes any series of one or more digits, followed by \" USC \u00a7 \", followed by another series of digits. It knows that the first string of digits is something called a \"title\" and the second is a \"section\". We will call these stored values tokens . Finally, the template also has a pattern to generate a URL based on the recognized citation. It does this by replacing the placeholders (i.e. the parts in curly braces) with the values from the captured tokens. Although this template does not have any, it could also define operations to perform on the captured tokens before inserting them into the URL.","title":"The Basic Template Format"},{"location":"template-yamls/#regex-complications","text":"In the example above, the regex is provided as a single string. This is perfectly valid, but templates' regexes can be much more complicated than that, for two reasons: A regex can be provided either as a string (as shown above), or as a list of strings. In the latter case, they will be concatenated (with no spaces) to create the actual regex. There is no functional difference between using strings and lists, except that providing them in list form allows you to reuse common regex parts using YAML anchors . Independent of the first reason, it is possible to give a template multiple regexes to match, by using the regexes key instead of regex . Normally, this will not be necessary, because the usual solution is to just write one regex to recognize multiple citation formats. However, regexes are limited in that capture groups cannot be rearranged. The example template above can be rewritten to take advantage of these two features, like so: United States Code regexes : - [ &title '(?P<title>\\d+)' , ' USC ' , &section '(Section|\u00a7) (?P<section>\\d+)' ] - [ *section , ' of Title ' , *title , ' of the United States Code' ] URL : https://www.law.cornell.edu/uscode/text/{title}/{section} The above template looks unwieldy, and it is; its regex is a list of lists. However, it provides two advantages over the first example: First, it is possible to recognize both \"42 USC \u00a7 1983\" and \"Section 1983 of Title 42 of the United States Code,\" which would be impossible with a single regex, since title and section are in a different order. Second, by using YAML anchors it is possible to reuse common pieces of regex, like *section , which can recognize either the word \"Section\" or a section sign (\"\u00a7\"). This can make it much easier to write and maintain large libraries of templates.","title":"Regex Complications"},{"location":"template-yamls/#url-complications","text":"Another important feature is that a template's URL, like its regex(es), can be specified as a list of strings to concatenate. Unlike with regexes, splitting a URL into a list of strings makes it function differently: If a list item contains a placeholder for which no value is set, that whole list item will be omitted from the final URL. For instance, the template below can generate anchor links to subsections of the U.S. Code, but if no subsection is specified, it simply links to the overall page for the section itself: United States Code regex : (?P<title>\\d+) USC \u00a7 (?P<section>\\d+)( \\((?P<subsection>[a-z])\\)? URL : - 'https://www.law.cornell.edu/uscode/text/{title}/{section}' - '#{subsection}'","title":"URL Complications"},{"location":"template-yamls/#token-processing","text":"In many cases, the tokens matched in a citation won't directly correspond with the values that need to be inserted into the URL placeholder. For example, your template might detect a court reporter called \"F. App'x.\" or \"Pa. D. & C.4th\", but Case.Law 's URL scheme needs those reporters to be called \" f-appx \" and \" pa-d-c4th \", respectively. To solve this problem, CiteURL templates can specify operations that will be performed on the dictionary of matched tokens to turn them into a new dictionary (i.e. processed_tokens ) before using it to populate the URL. This example template solves the problem by converting the reporter token to lowercase, deleting some common special characters from it, and then replacing spaces with dashes: Caselaw Access Project (Simplified) : regex : (?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+) operations : - token : reporter case : lower - token : reporter sub : [ \"[.()&,']\" , '' ] - token : reporter sub : [ ' ' , '-' ] URL : https://cite.case.law/{reporter}/{volume}/{page} As shown above, a template's operations value is a list of operations that will be performed in sequence. Each operation is a dictionary that must specify a token to process, and the kind of operation to perform. Operations process a token in place by default, but if an output is specified, that token will be set or modified instead. The above example shows two kinds of operation: case modification ( case ), and regex substitution ( sub ), but CiteURL supports others as well: Operation Description Required Contents case sets the input token to the specified capitalization upper , lower , or title sub replaces all instances of the provided regex pattern with the replacement string [PATTERN, REPL] lookup uses case-insensitive regex matching to check the token against each pattern until it fully matches one of them, in which case it outputs the corresponding replacement string. If no pattern is matched, it causes the entire template match to retroactively fail, as if there had never been a regex match in the first place. {PATTERN: REPL, PATTERN: REPL ...} optionalLookup same as lookup , except that if the lookup fails, it simply proceeds without modifying any tokens {PATTERN: REPL, PATTERN: REPL ...} lpad adds zeros to the beginning of the token until it is the specified length an integer numberFormat assumes that the token is an integer in digit or roman numeral form, and converts it to the specified form, irrespective of which format it was originally in. The outputted roman numerals are capitalized. roman or digit One final note: If an operation's input token has not been set (as distinct from being set to an empty string), the operation will be skipped.","title":"Token Processing"},{"location":"template-yamls/#recognizing-shortform-citations","text":"Often, once a particular authority is cited once, subsequent references to it will take a shorter, more contextual format. For example, if a text cites United States v. An Article Consisting of Boxes of Clacker Balls , 413 F. Supp. 1281 (E.D. Wis. 1976), then immediately cites a specific page of it, the second citation might look something like \" Id . at 1284.\" Later, once a different authority has been cited in the interim, the same citation might be referred back to with a citation like \"413 F. Supp. at 1289.\" To address this, CiteURL can essentially generate new templates on the fly, whenever it detects a citation. These templates can be of two forms: shortForms and idForms . In each case, the template is only applied to text after the original long-form citation. The difference is that shortForms are applied to all of the remaining text, whereas idForms are only matched against the text in between one citation and the next. Note that the Citator.list_citations() function also accepts an interruption regex, all occurrences of which will break chains of idForm citations. Like URL templates, idForms and shortForms may contain placeholders in curly braces. These placeholders will be replaced with the corresponding token matched in the long-form citation, so that you can ensure that they only match citations where those tokens are unchanged. For instance, you could write a template to recognize court cases: Caselaw Access Project (Simplified) : regex : (?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+)(, (?P<pincite>\\d+))? idForms : - Id\\. at (?P<pincite>\\d+) shortForms : - { volume } { reporter } at (?P<pincite>\\d+) This template will recognize long-form citations like 372 U.S. 335 (optionally with a pincite citation afterwards). After that long-form citation is recognized, it will generate the regex 372 U\\.S\\. at (?P<pincite>\\d+) , to recognize later citations to different pincites in the same case. To be precise, placeholders are replaced by the text as originally matched in the original regex capture group, before any operations are applied. This is normally the desired behavior, since operations often turn a token into something that would never be recognized. An exception applies where the placeholder refers to a token that only exists after operations are applied. In those cases, the processed token is used. This exception is useful in a few situations. For instance, a California court opinion might reference \"California Civil Code \u00a7 1946.2\" once early on, but then shift to a format like \"CIV \u00a7 1946.2\" in later citations. This poses a problem because the new form drops reference to California, so it's too generic to be its own long-form citation, while at the same time it doesn't match the \"Civil Code\" token, either. But this can be solved by using a substitution to recognize \"Civil Code\" and, from it, generate a new token \"CIV\", then generating a short citation form from that: California Codes : regex : California (?P<code>Civil Code|Penal Code) \u00a7 (?P<section>\\d+) operations : - token : code output : abbreviatedCode lookup : { 'Civil Code' : 'CIV' , 'Penal Code' : 'PEN' } shortForms : - { abbreviatedCode } \u00a7 (?P<section>\\d+) - { code } \u00a7 (?P<section>\\d+) Using the example template above, CiteURL will be able to recognize a longform citation to \"California Civil Code \u00a7 1946.2\", and then recognize subsequent citations either to \"Civil Code\" sections or \"CIV\" sections. One last note: Unlike a template's regex , shortForms and idForms are inherently lists, since they are designed to allow multiple alternative regexes. However, like the regex entry, individual list items can optionally be lists of strings, to accommodate YAML anchors. For instance, the following template is functionally identical to the Caselaw Access Project example above; the only difference is that I structured it so that I would only need to write (?P<pincite>\\d+) once: Caselaw Access Project (Simplified) : regex : - '(?P<volume>\\d+) (?P<reporter>(\\D|\\d(d|th|rd))+?) (?P<page>\\d+)(, ' - &pin '(?P<pincite>\\d+)' - ')?' idForms : - [ 'Id\\. at ' , *pin ] shortForms : - [ '{volume} {reporter} at ' , *pin ]","title":"Recognizing Shortform Citations"},{"location":"template-yamls/#miscellaneous-keys","text":"","title":"Miscellaneous Keys"},{"location":"template-yamls/#defaults","text":"defaults is a dictionary of tokens whose values will be set to specified values, if they are not set by a named capture group in the matched regex. Defaults are applied prior to any operations . For instance, the template below will match citations like \"29 USC \u00a7 157\" as well as citations like \"\u00a7 1983\", but in the latter case, it assumes that the title is '42' by default. U.S. Code, but especially Title 42 : regex : ((?P<title>\\d+) USC )?\u00a7 (?P<section>\\d+) defaults : { 'title' : '42' }","title":"defaults"},{"location":"template-yamls/#broadregex","text":"broadRegex and broadRegexes are identical in format to the regex and regexes keys. They allow you to specify extra regexes that will be used, in addition to the normal regex(es), in contexts like search engines where user convenience is more important than avoiding false positives. BroadRegexes are used by default in the lookup() method, as well as in JavaScript implementations , though if you are writing templates exclusively for these use cases rather than text processing, it is not important whether you use regexes or broadRegexes .","title":"broadRegex"}]}